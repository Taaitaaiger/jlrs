//! Traits to check if a Rust type and a Julia type have matching layouts.
//!
//! When working with Julia values, it's always possible to access their [`DataType`]. This
//! `DataType` contains all information about the value's fields and their layout. The
//! [`ValidLayout`] and [`ValidField`] traits defined in this module are used to check if a type
//! has the same layout as a given Julia type. It is implemented automatically by JlrsReflect.jl,
//! you should not implement it manually.
//!
//! [`DataType`]: crate::data::managed::datatype::DataType

use std::ffi::c_void;

use crate::{
    convert::into_julia::IntoJulia,
    data::managed::{datatype::DataType, value::Value},
};

/// Trait used to check if a Rust type and Julia type have matching layouts.
///
/// All wrappers generated by JlrsReflect.jl derive this trait. In this case all fields are
/// checked recursively to determine if the value can be unboxed as that type.
pub unsafe trait ValidLayout {
    /// Must be `true` if the Rust type is a pointer wrapper type, i.e. if `Self` implements
    /// [`ManagedRef`], `false` otherwise.
    ///
    /// [`ManagedRef`]: crate::data::managed::ManagedRef
    const IS_REF: bool = false;

    /// Check if the layout of the implementor is compatible with the layout of `ty`. This
    /// argument is a `Value` to account for the fact that a field type can be a `Union`,
    /// `UnionAll` or `Union{}`.
    fn valid_layout(ty: Value) -> bool;
}

#[doc(hidden)]
#[macro_export]
macro_rules! impl_valid_layout {
    ($type:ty, $($lt:lifetime),+) => {
        unsafe impl<$($lt),+> $crate::layout::valid_layout::ValidLayout for $type {
            #[inline(always)]
            fn valid_layout(v: $crate::data::managed::value::Value) -> bool {
                if let Ok(dt) = v.cast::<$crate::data::managed::datatype::DataType>() {
                    dt.is::<$type>()
                } else {
                    false
                }
            }

            const IS_REF: bool = true;
        }

        unsafe impl<$($lt),+> $crate::layout::valid_layout::ValidField for $type {
            #[inline(always)]
            fn valid_field(v: $crate::data::managed::value::Value) -> bool {
                if let Ok(dt) = v.cast::<$crate::data::managed::datatype::DataType>() {
                    dt.is::<$type>()
                } else {
                    false
                }
            }
        }
    };
    ($t:ty) => {
        unsafe impl $crate::layout::valid_layout::ValidLayout for $t {
            #[inline(always)]
            fn valid_layout(v: $crate::data::managed::value::Value) -> bool {
                if let Ok(dt) =  v.cast::<$crate::data::managed::datatype::DataType>() {
                    dt.is::<$t>()
                } else {
                    false
                }
            }

            const IS_REF: bool = false;
        }

        unsafe impl $crate::layout::valid_layout::ValidField for $t {
            #[inline(always)]
            fn valid_field(v: $crate::data::managed::value::Value) -> bool {
                if let Ok(dt) =  v.cast::<$crate::data::managed::datatype::DataType>() {
                    dt.is::<$t>()
                } else {
                    false
                }
            }
        }
    }
}

impl_valid_layout!(bool);
impl_valid_layout!(char);
impl_valid_layout!(i8);
impl_valid_layout!(i16);
impl_valid_layout!(i32);
impl_valid_layout!(i64);
impl_valid_layout!(isize);
impl_valid_layout!(u8);
impl_valid_layout!(u16);
impl_valid_layout!(u32);
impl_valid_layout!(u64);
impl_valid_layout!(usize);
impl_valid_layout!(f32);
impl_valid_layout!(f64);
impl_valid_layout!(*mut c_void);

unsafe impl<T: IntoJulia> ValidLayout for *mut T {
    #[inline(always)]
    fn valid_layout(v: Value) -> bool {
        if let Ok(dt) = v.cast::<DataType>() {
            dt.is::<*mut T>()
        } else {
            false
        }
    }

    const IS_REF: bool = false;
}

/// Trait used to check if a field of a Rust type and Julia type have matching layouts.
///
/// Wrappers for immutable types generated by JlrsReflect.jl derive this trait. Mutable types
/// must use `Option<ValueRef>` because they're not stored inline when used as a field type.
pub unsafe trait ValidField {
    /// Returns `true` if `Self` is the correct representation for Julia data of type `ty`
    /// when it's used as a field type.
    fn valid_field(ty: Value) -> bool;
}
