//! Expose Rust types to Julia.
//!
//! All data in Julia is an instance of some [`DataType`]. While `DataType`s typically have layout
//! requirements that are not compatible with arbitrary Rust data, it is possible to create types
//! that have opaque layouts, allowing many types of Rust data to be exposed to Julia.
//!
//! Two ways to expose a Rust type are provided, you can implement either the `OpaqueType` or the
//! `ForeignType` trait. The difference is that an opaque type is a normal, mutable type with no
//! fields in Julia and can't contain references to Julia data internally, while a foreign type
//! has a custom mark function that is used by the GC to mark all internal references to Julia
//! data.
//!
//! Unless the type contains references to Julia data you should implement `OpaqueType`. Types
//! that implement either of these traits and their methods can be exported with the
//! `julia_module` macro as follows:
//!
//! ```ignore
//! struct ExportedType {
//!     vector: Vec<u8>,
//! }
//!
//! impl ExportedType {
//!     // Methods can take `self` by (mutable) reference. Methods that do so must return a
//!     // `RustResult` because the borrow is tracked to prevent aliasing a mutable borrow, if
//!     // this fails an error is returned.
//!     pub fn takes_mut_self(&mut self, arg2: usize) -> RustResultRet<Nothing> {
//!         todo!()
//!     }
//!
//!     pub fn doesnt_take_self(arg: usize) -> u32 {
//!         todo!()
//!     }
//! }
//!
//! unsafe impl OpaqueType for ExportedType {}
//!
//! julia_module! {
//!     become module_jl_init;
//!
//!     struct ExportedType;
//!     in ExportedType fn takes_mut_self(&mut self, arg2: usize) -> RustResultRet<Nothing>;
//!     in ExportedType fn doesnt_take_self(arg: usize) -> u32;
//! }
//! ```
//!
//! Implementations of these traits additionally implement `IntoJulia`, `ValidLayout`,
//! `Typecheck`, `Unbox` and `ConstructType`. (Mutable) references to their content can be
//! obtained by tracking the data. If you want to use an opaque or foreign type in an exported
//! method or function as a named argument, a `TypedValue` must be used.
//!
//! These types must be created before they can be used. The init function generated by
//! `julia_module` automatically takes care of this, otherwise you must manually call
//! `OpaqueType::create_type` or `OpaqueType::reinit_type`. The first must be called if the
//! type doesn't exist yet, the second if the module that defines the type has been precompiled.
use std::{any::TypeId, ffi::c_void, mem::MaybeUninit, ptr::NonNull, sync::RwLock};

#[julia_version(except = ["1.7"])]
use jl_sys::jl_gc_schedule_foreign_sweepfunc;
#[julia_version(since = "1.9")]
use jl_sys::jl_reinit_foreign_type;
use jl_sys::{jl_emptysvec, jl_gc_alloc_typed, jl_new_datatype, jl_new_foreign_type, jl_value_t};
use jlrs_macros::julia_version;

use super::typecheck::Typecheck;
use crate::{
    convert::{into_julia::IntoJulia, unbox::Unbox},
    data::{
        layout::valid_layout::ValidLayout,
        managed::{
            datatype::{DataType, DataTypeData},
            module::Module,
            private::ManagedPriv,
            symbol::Symbol,
            value::{Value, ValueData, ValueRef},
            Managed,
        },
        types::construct_type::ConstructType,
    },
    memory::{
        get_tls,
        target::{ExtendedTarget, Target},
        PTls,
    },
    private::Private,
};

static FOREIGN_TYPE_REGISTRY: ForeignTypes = ForeignTypes::new();

struct ForeignTypes {
    data: RwLock<Vec<(TypeId, DataType<'static>)>>,
}

impl ForeignTypes {
    const fn new() -> Self {
        ForeignTypes {
            data: RwLock::new(Vec::new()),
        }
    }

    fn find<T: 'static>(&self) -> Option<DataType> {
        let tid = TypeId::of::<T>();
        self.data
            .read()
            .expect("Lock poisoned")
            .iter()
            .find_map(|s| match s {
                &(type_id, ty) if type_id == tid => Some(ty),
                _ => None,
            })
    }
}

unsafe impl Sync for ForeignTypes {}
unsafe impl Send for ForeignTypes {}

/// A trait that allows Rust data to be converted to Julia data.
///
/// Safety:
///
/// The implementor can't contain any references to Julia data unless `ForeignType` is also
/// implemented; all implementations of `ForeignType` automatically implement `OpaqueType`.
///
/// The type cannot be used in Julia until `OpaqueType::create_type` has been called.
pub unsafe trait OpaqueType: Sized + Send + 'static {
    #[doc(hidden)]
    const IS_FOREIGN: bool = false;
    #[doc(hidden)]
    const TYPE_FN: Option<unsafe fn() -> DataType<'static>> = None;

    /// The super-type of this type, `Core.Any` by default.
    fn super_type<'target, Tgt>(target: Tgt) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        DataType::any_type(&target).root(target)
    }

    /// Creates a new opaque type named `name` in `module`.
    ///
    /// An opaque type must be created if it doesn't exist yet in `module`. This method is called
    /// automatically by init functions generated with the `julia_module` macro.
    ///
    /// Safety:
    ///
    /// The new type is not set as a constant in `module`, you must do this manually after calling
    /// this function. You must not override the default implementation.
    unsafe fn create_type<'target, Tgt>(
        target: Tgt,
        name: Symbol,
        module: Module,
    ) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        create_opaque_type::<Self, Tgt>(target, name, module)
    }

    /// Reinitializes the previously created type `datatype`.
    ///
    /// An opaque type must be reinitialized if it has been created in a precompiled module and
    /// this module is loaded. This method is called automatically by init functions generated
    /// with the `julia_module` macro.
    ///
    /// Safety:
    ///
    /// The datatype must have been originally created by calling `OpaqueType::create_type`. You
    /// must not override the default implementation.
    unsafe fn reinit_type(datatype: DataType) -> bool {
        reinit_opaque_type::<Self>(datatype)
    }
}

/// A trait that allows Rust data with internal references to Julia data to be converted to Julia.
///
/// A `ForeignType` can contain references to Julia data because it has a custom mark function.
/// This function is called by the GC to mark all internal references during its marking phase,
/// types that contain no references to Julia data should implement the `OpaqueType` trait
/// instead.
///
/// Because this trait has a `'static` lifetime bound, it's necessary to erase the lifetimes of
/// referenced Julia data present in the implementor. This can be done by using the `Ret`-aliases
/// that all managed types provide, lifetimes can be erased by calling either [`Ref::leak`] or
/// [`Managed::leak`].
///
/// Safety:
///
/// All implementations of this trait automatically implement `OpaqueType`, and like direct
/// implementations of that trait the type must be created before it can be used by Julia.
///
/// If the implementor contains references to Julia data, [`ForeignType::HAS_POINTERS`] must be
/// set to `true` and the implementation of the `mark` method must mark all these references.
///
/// The type cannot be used in Julia until `OpaqueType::create_type` has been called.
///
/// Like other types with that contain references to Julia data, Julia is only aware of these
/// references after that data has been converted to a `Value`. Whenever an internal reference to
/// Julia data is changed while it's managed by Julia, [`write_barrier`] must be called to
/// ensure GC invariants are maintained.
///
/// [`Ref::leak`]: crate::data::managed::Ref::leak
/// [`write_barrier`]: crate::memory::gc::write_barrier
pub unsafe trait ForeignType: Sized + Send + 'static {
    #[doc(hidden)]
    const TYPE_FN: Option<unsafe fn() -> DataType<'static>> = None;

    /// Whether or not this type should be considered to be large.
    ///
    /// If the size of an instance of this type is larger than 2032 bytes this constant must be
    /// set to `true`, otherwise it can be `false`. This is the default. If this constant is
    /// `true` Julia will internally use `malloc` when allocating a value of this type, otherwise
    /// a preallocated pool is used.
    const LARGE: bool = ::std::mem::size_of::<Self>() > 2032;

    /// Whether or not this type contains references to Julia data.
    ///
    /// If this is not `true` you should implement `OpaqueType` instead.
    const HAS_POINTERS: bool = true;

    /// The super-type of this type, `Core.Any` by default.
    fn super_type<'target, T>(target: T) -> DataTypeData<'target, T>
    where
        T: Target<'target>,
    {
        DataType::any_type(&target).root(target)
    }

    /// Convert a reference to this foreign type to a `ValueRef`.
    fn as_value_ref<'scope>(&'scope self) -> ValueRef<'scope, 'static> {
        unsafe { ValueRef::wrap(NonNull::new_unchecked(self as *const _ as *mut jl_value_t)) }
    }

    /// Mark all references to Julia data.
    ///
    /// For each reference to Julia data you must call [`mark_queue_obj`], if `self` constains an
    /// array-like object with references [`mark_queue_objarray`] can be used instead. This
    /// method should return the number of times `mark_queue_obj` returned `true`, or 0 if only
    /// `mark_queue_objarray` is called.
    ///
    /// [`mark_queue_obj`]: crate::memory::gc::mark_queue_obj
    /// [`mark_queue_objarray`]: crate::memory::gc::mark_queue_objarray
    fn mark(ptls: PTls, data: &Self) -> usize;
}

unsafe impl<T: ForeignType> OpaqueType for T {
    const IS_FOREIGN: bool = true;
    const TYPE_FN: Option<unsafe fn() -> DataType<'static>> = <T as ForeignType>::TYPE_FN;

    fn super_type<'target, Tgt>(target: Tgt) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        <Self as ForeignType>::super_type(target)
    }

    unsafe fn create_type<'target, Tgt>(
        target: Tgt,
        name: Symbol,
        module: Module,
    ) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        create_foreign_type::<Self, Tgt>(target, name, module)
    }

    unsafe fn reinit_type(datatype: DataType) -> bool {
        reinit_foreign_type::<Self>(datatype)
    }
}

unsafe fn create_foreign_type<'target, U, T>(
    target: T,
    name: Symbol,
    module: Module,
) -> DataTypeData<'target, T>
where
    U: ForeignType,
    T: Target<'target>,
{
    if let Some(ty) = FOREIGN_TYPE_REGISTRY.find::<U>() {
        return target.data_from_ptr(ty.unwrap_non_null(Private), Private);
    }

    let large = U::LARGE as _;
    let has_pointers = U::HAS_POINTERS as _;

    unsafe extern "C" fn mark<T: ForeignType>(ptls: PTls, value: *mut jl_value_t) -> usize {
        T::mark(ptls, NonNull::new_unchecked(value.cast()).as_ref())
    }

    unsafe extern "C" fn sweep<T: ForeignType>(value: *mut jl_value_t) {
        do_sweep::<T>(&mut *value.cast())
    }

    let super_type = U::super_type(&target).ptr().as_ptr();

    let ty = jl_new_foreign_type(
        name.unwrap(Private),
        module.unwrap(Private),
        super_type,
        Some(mark::<U>),
        Some(sweep::<U>),
        has_pointers,
        large,
    );

    debug_assert!(!ty.is_null());
    FOREIGN_TYPE_REGISTRY
        .data
        .write()
        .expect("Foreign type lock was poisoned")
        .push((
            TypeId::of::<U>(),
            DataType::wrap_non_null(NonNull::new_unchecked(ty), Private),
        ));

    target.data_from_ptr(NonNull::new_unchecked(ty), Private)
}

unsafe fn create_opaque_type<'target, U, T>(
    target: T,
    name: Symbol,
    module: Module,
) -> DataTypeData<'target, T>
where
    U: OpaqueType,
    T: Target<'target>,
{
    if let Some(ty) = FOREIGN_TYPE_REGISTRY.find::<U>() {
        return target.data_from_ptr(ty.unwrap_non_null(Private), Private);
    }

    let super_type = U::super_type(&target).ptr().as_ptr();

    #[cfg(feature = "julia-1-6")]
    let ty = jl_new_datatype(
        name.unwrap(Private),
        module.unwrap(Private),
        super_type,
        jl_emptysvec,
        jl_emptysvec,
        jl_emptysvec,
        0,
        1,
        0,
    );

    #[cfg(not(feature = "julia-1-6"))]
    let ty = jl_new_datatype(
        name.unwrap(Private),
        module.unwrap(Private),
        super_type,
        jl_emptysvec,
        jl_emptysvec,
        jl_emptysvec,
        jl_emptysvec,
        0,
        1,
        0,
    );

    debug_assert!(!ty.is_null());
    FOREIGN_TYPE_REGISTRY
        .data
        .write()
        .expect("Foreign type lock was poisoned")
        .push((
            TypeId::of::<U>(),
            DataType::wrap_non_null(NonNull::new_unchecked(ty), Private),
        ));

    target.data_from_ptr(NonNull::new_unchecked(ty), Private)
}

pub(crate) unsafe fn create_foreign_type_internal<'target, U, T>(
    target: T,
    name: Symbol,
    module: Module,
) -> DataTypeData<'target, T>
where
    U: ForeignType,
    T: Target<'target>,
{
    let large = U::LARGE as _;
    let has_pointers = U::HAS_POINTERS as _;

    unsafe extern "C" fn mark<T: ForeignType>(ptls: PTls, value: *mut jl_value_t) -> usize {
        T::mark(ptls, NonNull::new_unchecked(value.cast()).as_ref())
    }

    unsafe extern "C" fn sweep<T: ForeignType>(value: *mut jl_value_t) {
        do_sweep::<T>(NonNull::new_unchecked(value.cast()).as_mut())
    }

    let super_type = U::super_type(&target).ptr().as_ptr();

    let ty = jl_new_foreign_type(
        name.unwrap(Private),
        module.unwrap(Private),
        super_type,
        Some(mark::<U>),
        Some(sweep::<U>),
        has_pointers,
        large,
    );

    target.data_from_ptr(NonNull::new_unchecked(ty), Private)
}

#[julia_version(since = "1.9")]
unsafe fn reinit_foreign_type<U>(datatype: DataType) -> bool
where
    U: ForeignType,
{
    if let Some(_) = FOREIGN_TYPE_REGISTRY.find::<U>() {
        return true;
    }

    unsafe extern "C" fn mark<T: ForeignType>(ptls: PTls, value: *mut jl_value_t) -> usize {
        T::mark(ptls, NonNull::new_unchecked(value.cast()).as_ref())
    }

    unsafe extern "C" fn sweep<T: ForeignType>(value: *mut jl_value_t) {
        do_sweep::<T>(NonNull::new_unchecked(value.cast()).as_mut())
    }

    let ty = datatype.unwrap(Private);
    let ret = jl_reinit_foreign_type(ty, Some(mark::<U>), Some(sweep::<U>));
    if ret != 0 {
        FOREIGN_TYPE_REGISTRY
            .data
            .write()
            .expect("Foreign type lock was poisoned")
            .push((
                TypeId::of::<U>(),
                DataType::wrap_non_null(NonNull::new_unchecked(ty), Private),
            ));
        true
    } else {
        panic!()
    }
}

#[julia_version(until = "1.8")]
unsafe fn reinit_foreign_type<U>(datatype: DataType) -> bool
where
    U: ForeignType,
{
    reinit_opaque_type::<U>(datatype)
}

unsafe fn reinit_opaque_type<U>(ty: DataType) -> bool
where
    U: OpaqueType,
{
    if let Some(_) = FOREIGN_TYPE_REGISTRY.find::<U>() {
        return true;
    }

    FOREIGN_TYPE_REGISTRY
        .data
        .write()
        .expect("Foreign type lock was poisoned")
        .push((
            TypeId::of::<U>(),
            DataType::wrap_non_null(ty.unwrap_non_null(Private), Private),
        ));
    true
}

#[julia_version(since = "1.7", until = "1.7")]
#[inline(always)]
unsafe fn do_sweep<T>(_: &mut ForeignValue<T>)
where
    T: ForeignType,
{
    // Sweep is called while the data is still reachable, a finalizer is used instead.
}

#[julia_version(except = ["1.7"])]
#[inline(always)]
unsafe fn do_sweep<T>(data: &mut ForeignValue<T>)
where
    T: ForeignType,
{
    data.data.assume_init_drop();
}

unsafe impl<F: OpaqueType> IntoJulia for F {
    fn julia_type<'scope, T>(target: T) -> DataTypeData<'scope, T>
    where
        T: Target<'scope>,
    {
        let ty = FOREIGN_TYPE_REGISTRY.find::<F>().expect("Doesn't exist");
        unsafe { target.data_from_ptr(ty.unwrap_non_null(Private), Private) }
    }

    fn into_julia<'scope, T>(self, target: T) -> ValueData<'scope, 'static, T>
    where
        T: Target<'scope>,
    {
        unsafe {
            let ptls = get_tls();
            let sz = std::mem::size_of::<Self>();
            let maybe_ty = FOREIGN_TYPE_REGISTRY.find::<F>();

            let ty = match maybe_ty {
                None => {
                    if let Some(func) = Self::TYPE_FN {
                        let mut guard = FOREIGN_TYPE_REGISTRY
                            .data
                            .write()
                            .expect("Foreign type lock was poisoned");

                        // Check again
                        let tid = TypeId::of::<Self>();
                        if let Some(ty) = guard.iter().find_map(|s| match s {
                            &(type_id, ty) if type_id == tid => Some(ty),
                            _ => None,
                        }) {
                            ty
                        } else {
                            let ty = func();
                            guard.push((TypeId::of::<Self>(), ty));
                            ty
                        }
                    } else {
                        maybe_ty.expect("Doesn't exist")
                    }
                }
                Some(t) => t,
            };

            let ptr: *mut Self = jl_gc_alloc_typed(ptls, sz, ty.unwrap(Private).cast()).cast();
            ptr.write(self);
            let res = target.data_from_ptr(NonNull::new_unchecked(ptr.cast()), Private);

            if Self::IS_FOREIGN {
                // Use a finalizer for Julia 1.7 because sweep is called even though the data is rooted.
                #[cfg(any(feature = "julia-1-7"))]
                jl_sys::jl_gc_add_ptr_finalizer(
                    ptls,
                    ptr.cast(),
                    drop_opaque::<Self> as *mut c_void,
                );
                #[cfg(not(feature = "julia-1-7"))]
                jl_gc_schedule_foreign_sweepfunc(ptls, ptr.cast());
            } else {
                jl_sys::jl_gc_add_ptr_finalizer(
                    ptls,
                    ptr.cast(),
                    drop_opaque::<Self> as *mut c_void,
                );
            }

            res
        }
    }
}

unsafe impl<T: OpaqueType> ValidLayout for T {
    fn valid_layout(ty: Value) -> bool {
        if let Ok(dt) = ty.cast::<DataType>() {
            if let Some(ty) = FOREIGN_TYPE_REGISTRY.find::<T>() {
                dt.unwrap(Private) == ty.unwrap(Private)
            } else {
                false
            }
        } else {
            false
        }
    }
}

unsafe impl<T: OpaqueType> Typecheck for T {
    fn typecheck(ty: DataType) -> bool {
        T::valid_layout(ty.as_value())
    }
}

unsafe impl<T: OpaqueType + Clone> Unbox for T {
    type Output = T;
}

#[repr(transparent)]
struct ForeignValue<T: ForeignType> {
    #[allow(dead_code)]
    pub data: MaybeUninit<T>,
}

unsafe extern "C" fn drop_opaque<T: OpaqueType>(data: *mut c_void) {
    let p = data as *mut MaybeUninit<T>;
    NonNull::new_unchecked(p).as_mut().assume_init_drop()
}

unsafe impl<T: OpaqueType> ConstructType for T {
    fn construct_type<'target, Tgt>(
        target: ExtendedTarget<'target, '_, '_, Tgt>,
    ) -> ValueData<'target, 'static, Tgt>
    where
        Tgt: Target<'target>,
    {
        let (target, _) = target.split();
        FOREIGN_TYPE_REGISTRY
            .find::<T>()
            .unwrap()
            .as_value()
            .root(target)
    }

    fn base_type<'target, Tgt>(_target: &Tgt) -> Option<Value<'target, 'static>>
    where
        Tgt: Target<'target>,
    {
        Some(FOREIGN_TYPE_REGISTRY.find::<T>().unwrap().as_value())
    }
}
