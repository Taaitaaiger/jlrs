//! Expose Rust types to Julia.
//!
//! All data in Julia is an instance of some [`DataType`]. While `DataType`s typically have layout
//! requirements that are not compatible with arbitrary Rust data, it is possible to create types
//! that have opaque layouts, allowing many types of Rust data to be exposed to Julia.
//!
//! Two ways to expose a Rust type are provided, you can implement either the `OpaqueType` or the
//! `ForeignType` trait. The difference is that an opaque type is a normal, mutable type with no
//! fields in Julia and can't contain references to Julia data internally, while a foreign type
//! has a custom mark function that is used by the GC to mark all internal references to Julia
//! data.
//!
//! Unless the type contains references to Julia data you should implement `OpaqueType`. Types
//! that implement either of these traits and their methods can be exported with the
//! `julia_module` macro as follows:
//!
//! ```ignore
//! struct ExportedType {
//!     vector: Vec<u8>,
//! }
//!
//! impl ExportedType {
//!     pub fn takes_mut_self(&mut self, arg2: usize) -> JlrsResult<Nothing> {
//!         todo!()
//!     }
//!
//!     pub fn doesnt_take_self(arg: usize) -> u32 {
//!         todo!()
//!     }
//! }
//!
//! unsafe impl OpaqueType for ExportedType {}
//!
//! julia_module! {
//!     become module_jl_init;
//!
//!     struct ExportedType;
//!     in ExportedType fn takes_mut_self(&mut self, arg2: usize) -> RustResultRet<Nothing>;
//!     in ExportedType fn doesnt_take_self(arg: usize) -> u32;
//! }
//! ```
//!
//! Implementations of these traits additionally implement `IntoJulia`, `ValidLayout`,
//! `Typecheck`, `Unbox` and `ConstructType`. (Mutable) references to their content can be
//! obtained by tracking the data. If you want to use an opaque or foreign type in an exported
//! method or function as a named argument, a `TypedValue` must be used.
//!
//! These types must be created before they can be used. The init function generated by
//! `julia_module` automatically takes care of this, otherwise you must manually call
//! `OpaqueType::create_type` or `OpaqueType::reinit_type`. The first must be called if the
//! type doesn't exist yet, the second if the module that defines the type has been precompiled.
use std::{
    any::{Any, TypeId},
    ffi::c_void,
    marker::PhantomData,
    mem::MaybeUninit,
    ptr::NonNull,
};

use fnv::FnvHashMap;
#[julia_version(except = ["1.7"])]
use jl_sys::jl_gc_schedule_foreign_sweepfunc;
#[julia_version(since = "1.9")]
use jl_sys::jl_reinit_foreign_type;
use jl_sys::{
    jl_any_type, jl_emptysvec, jl_gc_alloc_typed, jl_new_datatype, jl_new_foreign_type, jl_value_t,
};
use jlrs_macros::julia_version;

use super::{
    construct_type::{TypeVarConstructor, TypeVarName},
    typecheck::Typecheck,
};
use crate::{
    convert::{into_julia::IntoJulia, unbox::Unbox},
    data::{
        layout::valid_layout::ValidLayout,
        managed::{
            datatype::{DataType, DataTypeData},
            erase_scope_lifetime,
            module::Module,
            private::ManagedPriv,
            simple_vector::{SimpleVector, SimpleVectorData},
            symbol::Symbol,
            value::{Value, ValueData, ValueRef},
            Managed,
        },
        types::construct_type::ConstructType,
    },
    gc_safe::{GcSafeOnceLock, GcSafeRwLock},
    memory::{get_tls, target::Target, PTls},
    private::Private,
};

static FOREIGN_TYPE_REGISTRY: GcSafeOnceLock<ForeignTypes> = GcSafeOnceLock::new();

pub(crate) unsafe fn init_foreign_type_registry() {
    FOREIGN_TYPE_REGISTRY.set(ForeignTypes::new()).ok();
}

struct Key<K>(PhantomData<K>);

struct ForeignTypes {
    data: GcSafeRwLock<FnvHashMap<TypeId, DataType<'static>>>,
}

impl ForeignTypes {
    #[inline]
    fn new() -> Self {
        ForeignTypes {
            data: GcSafeRwLock::default(),
        }
    }

    #[inline]
    fn find<T: 'static>(&self) -> Option<DataType> {
        let tid = TypeId::of::<T>();
        self.data.read().get(&tid).copied()
    }

    // Safety: ty must be the datatype associated with T.
    #[inline]
    unsafe fn insert<T: 'static>(&self, ty: DataType<'static>) {
        let tid = TypeId::of::<T>();
        self.data.write().insert(tid, ty);
    }
}

unsafe impl Sync for ForeignTypes {}
unsafe impl Send for ForeignTypes {}

/// A trait that allows Rust data to be converted to Julia data.
///
/// Safety:
///
/// The implementor can't contain any references to Julia data unless `ForeignType` is also
/// implemented; all implementations of `ForeignType` automatically implement `OpaqueType`.
///
/// The type cannot be used in Julia until `OpaqueType::create_type` has been called.
pub unsafe trait OpaqueType: Sized + Send + 'static {
    #[doc(hidden)]
    const IS_FOREIGN: bool = false;
    #[doc(hidden)]
    const TYPE_FN: Option<unsafe fn() -> DataType<'static>> = None;

    /// The super-type of this type, `Core.Any` by default.
    #[inline]
    fn super_type<'target, Tgt>(target: Tgt) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        DataType::any_type(&target).root(target)
    }

    /// Creates a new opaque type named `name` in `module`.
    ///
    /// An opaque type must be created if it doesn't exist yet in `module`. This method is called
    /// automatically by init functions generated with the `julia_module` macro.
    ///
    /// Safety:
    ///
    /// The new type is not set as a constant in `module`, you must do this manually after calling
    /// this function. You must not override the default implementation.
    #[inline]
    unsafe fn create_type<'target, Tgt>(
        target: Tgt,
        name: Symbol,
        module: Module,
    ) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        create_opaque_type::<Self, Tgt>(target, name, module)
    }

    /// Reinitializes the previously created type `datatype`.
    ///
    /// An opaque type must be reinitialized if it has been created in a precompiled module and
    /// this module is loaded. This method is called automatically by init functions generated
    /// with the `julia_module` macro.
    ///
    /// Safety:
    ///
    /// The datatype must have been originally created by calling `OpaqueType::create_type`. You
    /// must not override the default implementation.
    #[inline]
    unsafe fn reinit_type(datatype: DataType) -> bool {
        reinit_opaque_type::<Self>(datatype)
    }
}

pub trait Bounds {
    fn construct_bounds<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>;
}

impl<N, U, L> Bounds for TypeVarConstructor<N, U, L>
where
    N: TypeVarName,
    U: ConstructType,
    L: ConstructType,
{
    fn construct_bounds<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        target.with_local_scope::<_, _, 2>(|target, mut frame| {
            let svec = unsafe { SimpleVector::with_capacity_uninit(&mut frame, 1) };
            let tvar = Self::construct_type(&mut frame);
            unsafe {
                svec.data().set(0, Some(tvar)).unwrap();
            }
            svec.root(target)
        })
    }
}

impl<N0, U0, L0, N1, U1, L1> Bounds
    for (
        TypeVarConstructor<N0, U0, L0>,
        TypeVarConstructor<N1, U1, L1>,
    )
where
    N0: TypeVarName,
    U0: ConstructType,
    L0: ConstructType,
    N1: TypeVarName,
    U1: ConstructType,
    L1: ConstructType,
{
    fn construct_bounds<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        target.with_local_scope::<_, _, 3>(|target, mut frame| {
            let svec = unsafe { SimpleVector::with_capacity_uninit(&mut frame, 2) };
            let tvar_1 = TypeVarConstructor::<N0, U0, L0>::construct_type(&mut frame);
            let tvar_2 = TypeVarConstructor::<N1, U1, L1>::construct_type(&mut frame);
            unsafe {
                let svec_ref = svec.data();
                svec_ref.set(0, Some(tvar_1)).unwrap();
                svec_ref.set(1, Some(tvar_2)).unwrap();
            }
            svec.root(target)
        })
    }
}

impl<N0, U0, L0, N1, U1, L1, N2, U2, L2> Bounds
    for (
        TypeVarConstructor<N0, U0, L0>,
        TypeVarConstructor<N1, U1, L1>,
        TypeVarConstructor<N2, U2, L2>,
    )
where
    N0: TypeVarName,
    U0: ConstructType,
    L0: ConstructType,
    N1: TypeVarName,
    U1: ConstructType,
    L1: ConstructType,
    N2: TypeVarName,
    U2: ConstructType,
    L2: ConstructType,
{
    fn construct_bounds<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        target.with_local_scope::<_, _, 4>(|target, mut frame| {
            let svec = unsafe { SimpleVector::with_capacity_uninit(&mut frame, 3) };
            let tvar_1 = TypeVarConstructor::<N0, U0, L0>::construct_type(&mut frame);
            let tvar_2 = TypeVarConstructor::<N1, U1, L1>::construct_type(&mut frame);
            let tvar_3 = TypeVarConstructor::<N2, U2, L2>::construct_type(&mut frame);
            unsafe {
                let svec_ref = svec.data();
                svec_ref.set(0, Some(tvar_1)).unwrap();
                svec_ref.set(1, Some(tvar_2)).unwrap();
                svec_ref.set(2, Some(tvar_3)).unwrap();
            }
            svec.root(target)
        })
    }
}

pub struct DefaultBounds1<N: TypeVarName>(PhantomData<N>);

impl<N> Bounds for N
where
    N: TypeVarName,
{
    fn construct_bounds<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        target.with_local_scope::<_, _, 2>(|target, mut frame| {
            let svec = unsafe { SimpleVector::with_capacity_uninit(&mut frame, 1) };
            let tvar = TypeVarConstructor::<N>::construct_type(&mut frame);
            unsafe {
                svec.data().set(0, Some(tvar)).unwrap();
            }
            svec.root(target)
        })
    }
}

impl<N> Bounds for DefaultBounds1<N>
where
    N: TypeVarName,
{
    fn construct_bounds<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        target.with_local_scope::<_, _, 2>(|target, mut frame| {
            let svec = unsafe { SimpleVector::with_capacity_uninit(&mut frame, 1) };
            let tvar = TypeVarConstructor::<N>::construct_type(&mut frame);
            unsafe {
                svec.data().set(0, Some(tvar)).unwrap();
            }
            svec.root(target)
        })
    }
}

pub struct DefaultBounds2<N0: TypeVarName, N1: TypeVarName>(PhantomData<(N0, N1)>);

impl<N0, N1> Bounds for DefaultBounds2<N0, N1>
where
    N0: TypeVarName,
    N1: TypeVarName,
{
    fn construct_bounds<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        target.with_local_scope::<_, _, 3>(|target, mut frame| {
            let svec = unsafe { SimpleVector::with_capacity_uninit(&mut frame, 2) };
            let tvar_1 = TypeVarConstructor::<N0>::construct_type(&mut frame);
            let tvar_2 = TypeVarConstructor::<N1>::construct_type(&mut frame);
            unsafe {
                let svec_ref = svec.data();
                svec_ref.set(0, Some(tvar_1)).unwrap();
                svec_ref.set(1, Some(tvar_2)).unwrap();
            }
            svec.root(target)
        })
    }
}

pub struct DefaultBounds3<N0: TypeVarName, N1: TypeVarName, N2: TypeVarName>(
    PhantomData<(N0, N1, N2)>,
);

impl<N0, N1, N2> Bounds for DefaultBounds3<N0, N1, N2>
where
    N0: TypeVarName,
    N1: TypeVarName,
    N2: TypeVarName,
{
    fn construct_bounds<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        target.with_local_scope::<_, _, 4>(|target, mut frame| {
            let svec = unsafe { SimpleVector::with_capacity_uninit(&mut frame, 3) };
            let tvar_1 = TypeVarConstructor::<N0>::construct_type(&mut frame);
            let tvar_2 = TypeVarConstructor::<N1>::construct_type(&mut frame);
            let tvar_3 = TypeVarConstructor::<N2>::construct_type(&mut frame);
            unsafe {
                let svec_ref = svec.data();
                svec_ref.set(0, Some(tvar_1)).unwrap();
                svec_ref.set(1, Some(tvar_2)).unwrap();
                svec_ref.set(2, Some(tvar_3)).unwrap();
            }
            svec.root(target)
        })
    }
}

pub unsafe trait ParametricBase: Sized + Send + 'static {
    /// Key for this family of opaque types.
    ///
    /// Must be unique, and must not depend on any of the type parameters of the implementing
    /// type. If this trait is implemented for `Foo<T>`, `Foo<f64>` may be used as a key, but
    /// `Foo<T>` may not.
    type Key: Any;

    fn type_parameters<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>;

    /// The super-type of this type, `Core.Any` by default.
    #[inline]
    fn super_type<'target, Tgt>(target: Tgt) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        DataType::any_type(&target).root(target)
    }

    /// Creates a new opaque type named `name` in `module`.
    ///
    /// An opaque type must be created if it doesn't exist yet in `module`. This method is called
    /// automatically by init functions generated with the `julia_module` macro.
    ///
    /// Safety:
    ///
    /// The new type is not set as a constant in `module`, you must do this manually after calling
    /// this function. You must not override the default implementation.
    #[inline]
    unsafe fn create_type<'target, Tgt>(
        target: Tgt,
        name: Symbol,
        module: Module,
    ) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        create_parametric_opaque_type::<Self, Tgt>(target, name, module)
    }

    /// Reinitializes the previously created type `datatype`.
    ///
    /// An opaque type must be reinitialized if it has been created in a precompiled module and
    /// this module is loaded. This method is called automatically by init functions generated
    /// with the `julia_module` macro.
    ///
    /// Safety:
    ///
    /// The datatype must have been originally created by calling `OpaqueType::create_type`. You
    /// must not override the default implementation.
    #[inline]
    unsafe fn reinit_type(datatype: DataType) -> bool {
        reinit_parametric_opaque_type::<Self>(datatype)
    }
}

#[macro_export(local_inner_macros)]
macro_rules! count_exprs {
    ($t:literal) => {
        1
    };
    ($t:ty) => {
        1
    };
    ($t:literal <: $ub:ty) => {
        1
    };
    ($t:literal <: $ub:ty >: $lb:ty) => {
        1
    };
    ($t:literal >: $lb:ty) => {
        1
    };
    () => {
        0
    };
    ($t:literal, $($x:tt),*) => {
        1 + $crate::count_exprs!($($x),*)
    };
    ($t:ty, $($x:tt),*) => {
        1 + $crate::count_exprs!($($x),*)
    };
    ($t:literal <: $ub:ty, $($x:tt)*) => {
        1 + $crate::count_exprs!($($x)*)
    };
    ($t:literal <: $ub:ty >: $lb:ty, $($x:tt)*) => {
        1 + $crate::count_exprs!($($x)*)
    };
    ($t:literal >: $lb:ty, $($x:tt)*) => {
        1 + $crate::count_exprs!($($x)*)
    };
}

#[macro_export(local_inner_macros)]
macro_rules! expand_type_bound {
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:literal, $($rest:tt)*) => {
        {
            type Ctor = $crate::data::types::construct_type::TypeVarConstructor::<$crate::data::types::construct_type::ConstantChar<$t>>;
            let tvar = <Ctor as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(tvar)).unwrap();
        }
        expand_type_bound!($nth + 1, $frame, $svec_ref, $($rest)*)
    };
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:literal) => {
        {
            type Ctor = $crate::data::types::construct_type::TypeVarConstructor::<$crate::data::types::construct_type::ConstantChar<$t>>;
            let tvar = <Ctor as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(tvar)).unwrap();
        }
    };
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:ty, $($rest:tt)*) => {
        {
            let ty = <$t as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(ty)).unwrap();
        }
        expand_type_bound!($nth + 1, $frame, $svec_ref, $($rest)*)
    };
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:ty) => {
        {
            let ty = <$t as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(ty)).unwrap();
        }
    };
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:literal <: $ub:ty, $($rest:tt)*) => {
        {
            type Ctor = $crate::data::types::construct_type::TypeVarConstructor::<$crate::data::types::construct_type::ConstantChar<$t>, $ub>;
            let tvar = <Ctor as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(tvar)).unwrap();
        }
        expand_type_bound!($nth + 1, $frame, $svec_ref, $($rest)*)
    };
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:literal <: $ub:ty) => {
        {
            type Ctor = $crate::data::types::construct_type::TypeVarConstructor::<$crate::data::types::construct_type::ConstantChar<$t>, $ub>;
            let tvar = <Ctor as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(tvar)).unwrap();
        }
    };
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:literal >: $lb:ty, $($rest:tt)*) => {
        {
            type Ctor = $crate::data::types::construct_type::TypeVarConstructor::<$crate::data::types::construct_type::ConstantChar<$t>, $crate::data::types::abstract_type::AnyType, $lb>;
            let tvar = <Ctor as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(tvar)).unwrap();
        }
        expand_type_bound!($nth + 1, $frame, $svec_ref, $($rest)*)
    };
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:literal >: $lb:ty) => {
        {
            type Ctor = $crate::data::types::construct_type::TypeVarConstructor::<$crate::data::types::construct_type::ConstantChar<$t>, $crate::data::types::abstract_type::AnyType, $lb>;
            let tvar = <Ctor as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(tvar)).unwrap();
        }
    };
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:literal <: $ub:ty >: $lb:ty, $($rest:tt)*) => {
        {
            type Ctor = $crate::data::types::construct_type::TypeVarConstructor::<$crate::data::types::construct_type::ConstantChar<$t>, $ub, $lb>;
            let tvar = <Ctor as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(tvar)).unwrap();
        }
        expand_type_bound!($nth + 1, $frame, $svec_ref, $($rest)*)
    };
    ($nth:expr, $frame:expr, $svec_ref:expr, $t:literal <: $ub:ty >: $lb:ty) => {
        {
            type Ctor = $crate::data::types::construct_type::TypeVarConstructor::<$crate::data::types::construct_type::ConstantChar<$t>, $ub, $lb>;
            let tvar = <Ctor as $crate::data::types::construct_type::ConstructType>::construct_type($frame);
            $svec_ref.set($nth, Some(tvar)).unwrap();
        }
    };
}

#[macro_export]
macro_rules! impl_type_parameters {
    () => {
        #[inline]
        fn type_parameters<'target, Tgt>(
            target: Tgt,
        ) -> $crate::data::managed::simple_vector::SimpleVectorData<'target, Tgt>
        where
            Tgt: $crate::memory::target::Target<'target>,
        {
            let svec = $crate::data::managed::simple_vector::SimpleVector::emptysvec(&target);
            <$crate::data::managed::simple_vector::SimpleVector as $crate::data::managed::Managed>::root(svec, target)
        }
    };
    ($($t:tt)+) => {
        fn type_parameters<'target, Tgt>(
            target: Tgt,
        ) -> $crate::data::managed::simple_vector::SimpleVectorData<'target, Tgt>
        where
            Tgt: $crate::memory::target::Target<'target>,
        {

            const N: usize = $crate::count_exprs!($($t)+);
            const M: usize = N + 1;
            target.with_local_scope::<_, _, M>(|target, mut frame| unsafe {
                let svec = $crate::data::managed::simple_vector::SimpleVector::with_capacity_uninit(&mut frame, N);

                {
                    let mut svec_ref = svec.data();
                    $crate::expand_type_bound!(0, &mut frame, svec_ref, $($t)+);
                }

                <$crate::data::managed::simple_vector::SimpleVector as $crate::data::managed::Managed>::root(svec, target)
            })
        }
    };
}

#[macro_export]
macro_rules! impl_variant_parameters {
    () => {
        #[inline]
        fn variant_parameters<'target, Tgt>(
            target: Tgt,
        ) -> $crate::data::managed::simple_vector::SimpleVectorData<'target, Tgt>
        where
            Tgt: $crate::memory::target::Target<'target>,
        {
            let svec = $crate::data::managed::simple_vector::SimpleVector::emptysvec(&target);
            <$crate::data::managed::simple_vector::SimpleVector as $crate::data::managed::Managed>::root(svec, target)
        }
    };
    ($($t:tt)+) => {
        fn variant_parameters<'target, Tgt>(
            target: Tgt,
        ) -> $crate::data::managed::simple_vector::SimpleVectorData<'target, Tgt>
        where
            Tgt: $crate::memory::target::Target<'target>,
        {
            const N: usize = $crate::count_exprs!($($t)+);
            const M: usize = N + 1;

            target.with_local_scope::<_, _, M>(|target, mut frame| unsafe {
                let svec = $crate::data::managed::simple_vector::SimpleVector::with_capacity_uninit(&mut frame, N);

                {
                    let mut svec_ref = svec.data();
                    $crate::expand_type_bound!(0, &mut frame, svec_ref, $($t)+);
                }

                <$crate::data::managed::simple_vector::SimpleVector as $crate::data::managed::Managed>::root(svec, target)
            })
        }
    };
}

pub unsafe trait ParametricVariant: ParametricBase {
    #[doc(hidden)]
    const IS_FOREIGN: bool = false;
    #[doc(hidden)]
    const TYPE_FN: Option<unsafe fn() -> DataType<'static>> = None;

    fn variant_parameters<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>;

    unsafe fn create_variant<'target, Tgt>(target: Tgt, name: Symbol) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        create_parametric_opaque_variant::<Self, Tgt>(target, name)
    }

    /// Reinitializes the previously created type `datatype`.
    ///
    /// An opaque type must be reinitialized if it has been created in a precompiled module and
    /// this module is loaded. This method is called automatically by init functions generated
    /// with the `julia_module` macro.
    ///
    /// Safety:
    ///
    /// The datatype must have been originally created by calling `OpaqueType::create_type`. You
    /// must not override the default implementation.
    #[inline]
    unsafe fn reinit_variant(datatype: DataType) -> bool {
        reinit_parametric_opaque_variant::<Self>(datatype)
    }
}

/// A trait that allows Rust data with internal references to Julia data to be converted to Julia.
///
/// A `ForeignType` can contain references to Julia data because it has a custom mark function.
/// This function is called by the GC to mark all internal references during its marking phase,
/// types that contain no references to Julia data should implement the `OpaqueType` trait
/// instead.
///
/// Because this trait has a `'static` lifetime bound, it's necessary to erase the lifetimes of
/// referenced Julia data present in the implementor. This can be done by using the `Ret`-aliases
/// that all managed types provide, lifetimes can be erased by calling either [`Ref::leak`] or
/// [`Managed::leak`].
///
/// Safety:
///
/// All implementations of this trait automatically implement `OpaqueType`, and like direct
/// implementations of that trait the type must be created before it can be used by Julia.
///
/// If the implementor contains references to Julia data, [`ForeignType::HAS_POINTERS`] must be
/// set to `true` and the implementation of the `mark` method must mark all these references.
///
/// The type cannot be used in Julia until `OpaqueType::create_type` has been called.
///
/// Like other types with that contain references to Julia data, Julia is only aware of these
/// references after that data has been converted to a `Value`. Whenever an internal reference to
/// Julia data is changed while it's managed by Julia, [`write_barrier`] must be called to
/// ensure GC invariants are maintained.
///
/// [`Ref::leak`]: crate::data::managed::Ref::leak
/// [`write_barrier`]: crate::memory::gc::write_barrier

#[cfg_attr(
    feature = "diagnostics",
    diagnostic::on_unimplemented(
        message = "the trait bound `{Self}: ForeignLayout` is not satisfied",
        label = "the trait `ForeignLayout` is not implemented for `{Self}`",
        note = "Unless you are calling a function that explicitly takes an implementation of \
    `ForeignType`, this diagnostic is likely incorrect",
        note = "It is more likely that the issue lies with not implementing `ValidLayout`, `IntoJulia`, `Typecheck`, `Unbox` or `ConstructType`",
        note = "Custom types that implement the traits mentioned in the previous note should be generated with JlrsCore.reflect",
        note = "Do not implement `ForeignType`, `OpaqueType`, or `ParametricVariant` unless this type is exported to Julia with `julia_module!`"
    )
)]
pub unsafe trait ForeignType: Sized + Send + 'static {
    #[doc(hidden)]
    const TYPE_FN: Option<unsafe fn() -> DataType<'static>> = None;

    /// Whether or not this type should be considered to be large.
    ///
    /// If the size of an instance of this type is larger than 2032 bytes this constant must be
    /// set to `true`, otherwise it can be `false`. This is the default. If this constant is
    /// `true` Julia will internally use `malloc` when allocating a value of this type, otherwise
    /// a preallocated pool is used.
    const LARGE: bool = ::std::mem::size_of::<Self>() > 2032;

    /// Whether or not this type contains references to Julia data.
    ///
    /// If this is not `true` you should implement `OpaqueType` instead.
    const HAS_POINTERS: bool = true;

    /// The super-type of this type, `Core.Any` by default.
    #[inline]
    fn super_type<'target, Tgt>(target: Tgt) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        DataType::any_type(&target).root(target)
    }

    /// Convert a reference to this foreign type to a `ValueRef`.
    #[inline]
    fn as_value_ref<'scope>(&'scope self) -> ValueRef<'scope, 'static> {
        unsafe { ValueRef::wrap(NonNull::new_unchecked(self as *const _ as *mut jl_value_t)) }
    }

    /// Mark all references to Julia data.
    ///
    /// For each reference to Julia data you must call [`mark_queue_obj`], if `self` constains an
    /// array-like object with references [`mark_queue_objarray`] can be used instead. This
    /// method should return the number of times `mark_queue_obj` returned `true`, or 0 if only
    /// `mark_queue_objarray` is called.
    ///
    /// [`mark_queue_obj`]: crate::memory::gc::mark_queue_obj
    /// [`mark_queue_objarray`]: crate::memory::gc::mark_queue_objarray
    fn mark(ptls: PTls, data: &Self) -> usize;
}

unsafe impl<T: ForeignType> OpaqueType for T {
    const IS_FOREIGN: bool = true;
    const TYPE_FN: Option<unsafe fn() -> DataType<'static>> = <T as ForeignType>::TYPE_FN;

    #[inline]
    fn super_type<'target, Tgt>(target: Tgt) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        <Self as ForeignType>::super_type(target)
    }

    #[inline]
    unsafe fn create_type<'target, Tgt>(
        target: Tgt,
        name: Symbol,
        module: Module,
    ) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        create_foreign_type::<Self, Tgt>(target, name, module)
    }

    #[inline]
    unsafe fn reinit_type(datatype: DataType) -> bool {
        reinit_foreign_type::<Self>(datatype)
    }
}

unsafe impl<T: OpaqueType> ParametricBase for T {
    type Key = Self;

    #[inline]
    fn type_parameters<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        SimpleVector::emptysvec(&target).root(target)
    }

    #[inline]
    fn super_type<'target, Tgt>(target: Tgt) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        <Self as OpaqueType>::super_type(target)
    }

    #[inline]
    unsafe fn create_type<'target, Tgt>(
        target: Tgt,
        name: Symbol,
        module: Module,
    ) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        <Self as OpaqueType>::create_type(target, name, module)
    }

    #[inline]
    unsafe fn reinit_type(datatype: DataType) -> bool {
        <Self as OpaqueType>::reinit_type(datatype)
    }
}

unsafe impl<T: OpaqueType> ParametricVariant for T {
    const TYPE_FN: Option<unsafe fn() -> DataType<'static>> = T::TYPE_FN;

    #[inline]
    fn variant_parameters<'target, Tgt>(target: Tgt) -> SimpleVectorData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        SimpleVector::emptysvec(&target).root(target)
    }

    #[inline]
    unsafe fn create_variant<'target, Tgt>(
        _target: Tgt,
        _name: Symbol,
    ) -> DataTypeData<'target, Tgt>
    where
        Tgt: Target<'target>,
    {
        unimplemented!("OpaqueTypes can't have variants")
    }

    #[inline]
    unsafe fn reinit_variant(_datatype: DataType) -> bool {
        unimplemented!("OpaqueTypes can't have variants")
    }
}

#[inline]
unsafe fn create_foreign_type<'target, U, Tgt>(
    target: Tgt,
    name: Symbol,
    module: Module,
) -> DataTypeData<'target, Tgt>
where
    U: ForeignType,
    Tgt: Target<'target>,
{
    create_foreign_type_nostack::<U, _>(target, name, module)
}

pub(crate) unsafe fn create_foreign_type_nostack<'target, U, Tgt>(
    target: Tgt,
    name: Symbol,
    module: Module,
) -> DataTypeData<'target, Tgt>
where
    U: ForeignType,
    Tgt: Target<'target>,
{
    if let Some(ty) = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<U>() {
        return target.data_from_ptr(ty.unwrap_non_null(Private), Private);
    }

    let large = U::LARGE as _;
    let has_pointers = U::HAS_POINTERS as _;

    unsafe extern "C" fn mark<T: ForeignType>(ptls: PTls, value: *mut jl_value_t) -> usize {
        T::mark(ptls, NonNull::new_unchecked(value.cast()).as_ref())
    }

    unsafe extern "C" fn sweep<T: ForeignType>(value: *mut jl_value_t) {
        do_sweep::<T>(&mut *value.cast())
    }

    let super_type = jl_any_type;

    let ty = jl_new_foreign_type(
        name.unwrap(Private),
        module.unwrap(Private),
        super_type,
        mark::<U>,
        sweep::<U>,
        has_pointers,
        large,
    );

    debug_assert!(!ty.is_null());
    FOREIGN_TYPE_REGISTRY
        .get_unchecked()
        .insert::<U>(DataType::wrap_non_null(NonNull::new_unchecked(ty), Private));
    target.data_from_ptr(NonNull::new_unchecked(ty), Private)
}

unsafe fn create_opaque_type<'target, U, Tgt>(
    target: Tgt,
    name: Symbol,
    module: Module,
) -> DataTypeData<'target, Tgt>
where
    U: OpaqueType,
    Tgt: Target<'target>,
{
    if let Some(ty) = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<U>() {
        return target.data_from_ptr(ty.unwrap_non_null(Private), Private);
    }

    target.with_local_scope::<_, _, 1>(|target, mut frame| {
        let super_type = U::super_type(&mut frame).unwrap(Private);

        #[cfg(feature = "julia-1-6")]
        let ty = jl_new_datatype(
            name.unwrap(Private),
            module.unwrap(Private),
            super_type,
            jl_emptysvec,
            jl_emptysvec,
            jl_emptysvec,
            0,
            1,
            0,
        );

        #[cfg(not(feature = "julia-1-6"))]
        let ty = jl_new_datatype(
            name.unwrap(Private),
            module.unwrap(Private),
            super_type,
            jl_emptysvec,
            jl_emptysvec,
            jl_emptysvec,
            jl_emptysvec,
            0,
            1,
            0,
        );

        debug_assert!(!ty.is_null());
        FOREIGN_TYPE_REGISTRY
            .get_unchecked()
            .insert::<U>(DataType::wrap_non_null(NonNull::new_unchecked(ty), Private));

        target.data_from_ptr(NonNull::new_unchecked(ty), Private)
    })
}

unsafe fn create_parametric_opaque_variant<'target, U, Tgt>(
    target: Tgt,
    name: Symbol,
) -> DataTypeData<'target, Tgt>
where
    U: ParametricVariant,
    Tgt: Target<'target>,
{
    if let Some(ty) = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<U>() {
        return target.data_from_ptr(ty.unwrap_non_null(Private), Private);
    }

    let base_ty = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<Key<U::Key>>();
    if base_ty.is_none() {
        panic!("Type {} was not registered", name.as_str().unwrap());
    }

    target.with_local_scope::<_, _, 3>(|target, mut frame| {
        let params = U::variant_parameters(&mut frame);
        let params = params.data();
        let params_slice = params.as_atomic_slice().assume_immutable_non_null();

        let ty = base_ty
            .unwrap_unchecked()
            .rewrap(&mut frame)
            .apply_type(&mut frame, params_slice)
            .unwrap()
            .cast::<DataType>()
            .unwrap();

        FOREIGN_TYPE_REGISTRY
            .get_unchecked()
            .insert::<U>(erase_scope_lifetime(ty));

        ty.root(target)
    })
}

unsafe fn create_parametric_opaque_type<'target, U, Tgt>(
    target: Tgt,
    name: Symbol,
    module: Module,
) -> DataTypeData<'target, Tgt>
where
    U: ParametricBase,
    Tgt: Target<'target>,
{
    if let Some(ty) = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<Key<U::Key>>() {
        return target.data_from_ptr(ty.unwrap_non_null(Private), Private);
    }

    target.with_local_scope::<_, _, 2>(|target, mut frame| {
        let super_type = U::super_type(&mut frame);
        let bounds = U::type_parameters(&mut frame);

        #[cfg(feature = "julia-1-6")]
        let ty = jl_new_datatype(
            name.unwrap(Private),
            module.unwrap(Private),
            super_type.unwrap(Private),
            bounds.unwrap(Private),
            jl_emptysvec,
            jl_emptysvec,
            0,
            1,
            0,
        );

        #[cfg(not(feature = "julia-1-6"))]
        let ty = jl_new_datatype(
            name.unwrap(Private),
            module.unwrap(Private),
            super_type.unwrap(Private),
            bounds.unwrap(Private),
            jl_emptysvec,
            jl_emptysvec,
            jl_emptysvec,
            0,
            1,
            0,
        );

        debug_assert!(!ty.is_null());
        FOREIGN_TYPE_REGISTRY
            .get_unchecked()
            .insert::<Key<U::Key>>(DataType::wrap_non_null(NonNull::new_unchecked(ty), Private));

        target.data_from_ptr::<DataType>(NonNull::new_unchecked(ty), Private)
    })
}

pub(crate) unsafe fn create_foreign_type_internal<'target, U, Tgt>(
    target: Tgt,
    name: Symbol,
    module: Module,
) -> DataTypeData<'target, Tgt>
where
    U: ForeignType,
    Tgt: Target<'target>,
{
    let large = U::LARGE as _;
    let has_pointers = U::HAS_POINTERS as _;

    unsafe extern "C" fn mark<T: ForeignType>(ptls: PTls, value: *mut jl_value_t) -> usize {
        T::mark(ptls, NonNull::new_unchecked(value.cast()).as_ref())
    }

    unsafe extern "C" fn sweep<T: ForeignType>(value: *mut jl_value_t) {
        do_sweep::<T>(&mut *value.cast())
    }

    let super_type = jl_any_type;

    let ty = jl_new_foreign_type(
        name.unwrap(Private),
        module.unwrap(Private),
        super_type,
        mark::<U>,
        sweep::<U>,
        has_pointers,
        large,
    );

    target.data_from_ptr(NonNull::new_unchecked(ty), Private)
}

#[julia_version(since = "1.9")]
unsafe fn reinit_foreign_type<U>(datatype: DataType) -> bool
where
    U: ForeignType,
{
    if let Some(_) = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<U>() {
        return true;
    }

    unsafe extern "C" fn mark<T: ForeignType>(ptls: PTls, value: *mut jl_value_t) -> usize {
        T::mark(ptls, NonNull::new_unchecked(value.cast()).as_ref())
    }

    unsafe extern "C" fn sweep<T: ForeignType>(value: *mut jl_value_t) {
        do_sweep::<T>(&mut *value.cast())
    }

    let ty = datatype.unwrap(Private);
    let ret = jl_reinit_foreign_type(ty, mark::<U>, sweep::<U>);
    if ret != 0 {
        FOREIGN_TYPE_REGISTRY
            .get_unchecked()
            .insert::<U>(DataType::wrap_non_null(NonNull::new_unchecked(ty), Private));
        true
    } else {
        panic!()
    }
}

#[julia_version(until = "1.8")]
#[inline]
unsafe fn reinit_foreign_type<U>(datatype: DataType) -> bool
where
    U: ForeignType,
{
    reinit_opaque_type::<U>(datatype)
}

unsafe fn reinit_opaque_type<U>(ty: DataType) -> bool
where
    U: OpaqueType,
{
    if let Some(_) = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<U>() {
        return true;
    }

    FOREIGN_TYPE_REGISTRY
        .get_unchecked()
        .insert::<U>(erase_scope_lifetime(ty));
    true
}

unsafe fn reinit_parametric_opaque_type<U>(ty: DataType) -> bool
where
    U: ParametricBase,
{
    if let Some(_) = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<Key<U::Key>>() {
        return true;
    }

    FOREIGN_TYPE_REGISTRY
        .get_unchecked()
        .insert::<Key<U::Key>>(erase_scope_lifetime(ty));
    true
}

unsafe fn reinit_parametric_opaque_variant<U>(ty: DataType) -> bool
where
    U: ParametricVariant,
{
    if let Some(_) = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<U>() {
        return true;
    }

    FOREIGN_TYPE_REGISTRY
        .get_unchecked()
        .insert::<U>(erase_scope_lifetime(ty));
    true
}

#[julia_version(since = "1.7", until = "1.7")]
#[inline]
unsafe fn do_sweep<T>(_: &mut ForeignValue<T>)
where
    T: ForeignType,
{
    // Sweep is called while the data is still reachable, a finalizer is used instead.
}

#[julia_version(except = ["1.7"])]
#[inline]
unsafe fn do_sweep<T>(data: &mut ForeignValue<T>)
where
    T: ForeignType,
{
    data.data.assume_init_drop();
}

unsafe impl<F: ParametricVariant> IntoJulia for F {
    #[inline]
    fn julia_type<'scope, Tgt>(target: Tgt) -> DataTypeData<'scope, Tgt>
    where
        Tgt: Target<'scope>,
    {
        unsafe {
            FOREIGN_TYPE_REGISTRY
                .get_unchecked()
                .find::<F>()
                .expect("Doesn't exist")
                .root(target)
        }
    }

    fn into_julia<'scope, Tgt>(self, target: Tgt) -> ValueData<'scope, 'static, Tgt>
    where
        Tgt: Target<'scope>,
    {
        unsafe {
            let sz = std::mem::size_of::<Self>();
            let maybe_ty = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<F>();

            let ty = match maybe_ty {
                None => {
                    if let Some(func) = Self::TYPE_FN {
                        let mut guard = FOREIGN_TYPE_REGISTRY.get_unchecked().data.write();

                        // Check again
                        let tid = TypeId::of::<Self>();
                        let res = if let Some(ty) = guard.get(&tid).copied() {
                            ty
                        } else {
                            let ty = func();
                            guard.insert(TypeId::of::<Self>(), ty);
                            ty
                        };

                        res
                    } else {
                        panic!("Unknown type")
                    }
                }
                Some(t) => t,
            };

            let ptls = get_tls();
            let ptr: *mut Self = jl_gc_alloc_typed(ptls, sz, ty.unwrap(Private).cast()).cast();
            ptr.write(self);
            let res = target.data_from_ptr(NonNull::new_unchecked(ptr.cast()), Private);

            if Self::IS_FOREIGN {
                // Use a finalizer for Julia 1.7 because sweep is called even though the data is rooted.
                #[cfg(any(feature = "julia-1-7"))]
                jl_sys::jl_gc_add_ptr_finalizer(
                    ptls,
                    ptr.cast(),
                    drop_opaque::<Self> as *mut c_void,
                );
                #[cfg(not(feature = "julia-1-7"))]
                jl_gc_schedule_foreign_sweepfunc(ptls, ptr.cast());
            } else {
                jl_sys::jl_gc_add_ptr_finalizer(
                    ptls,
                    ptr.cast(),
                    drop_opaque::<Self> as *mut c_void,
                );
            }

            res
        }
    }
}

unsafe impl<T: ParametricVariant> ValidLayout for T {
    #[inline]
    fn valid_layout(ty: Value) -> bool {
        if ty.is::<DataType>() {
            unsafe {
                if let Some(found_ty) = FOREIGN_TYPE_REGISTRY.get_unchecked().find::<T>() {
                    let dt = ty.cast_unchecked::<DataType>();
                    dt.unwrap(Private) == found_ty.unwrap(Private)
                } else {
                    false
                }
            }
        } else {
            false
        }
    }

    #[inline]
    fn type_object<'target, Tgt: Target<'target>>(_target: &Tgt) -> Value<'target, 'static> {
        unsafe {
            FOREIGN_TYPE_REGISTRY
                .get_unchecked()
                .find::<T>()
                .unwrap()
                .as_value()
        }
    }
}

unsafe impl<T: ParametricVariant> Typecheck for T {
    #[inline]
    fn typecheck(ty: DataType) -> bool {
        T::valid_layout(ty.as_value())
    }
}

unsafe impl<T: ParametricVariant + Clone> Unbox for T {
    type Output = T;
}

#[repr(transparent)]
struct ForeignValue<T: ForeignType> {
    #[allow(dead_code)]
    pub data: MaybeUninit<T>,
}

#[inline]
unsafe extern "C" fn drop_opaque<T: ParametricVariant>(data: *mut c_void) {
    let p = data as *mut MaybeUninit<T>;
    NonNull::new_unchecked(p).as_mut().assume_init_drop()
}

unsafe impl<T: ParametricVariant> ConstructType for T {
    type Static = T;

    fn construct_type_uncached<'target, Tgt>(target: Tgt) -> ValueData<'target, 'static, Tgt>
    where
        Tgt: Target<'target>,
    {
        unsafe {
            FOREIGN_TYPE_REGISTRY
                .get_unchecked()
                .find::<T>()
                .unwrap()
                .as_value()
                .root(target)
        }
    }

    fn base_type<'target, Tgt>(_target: &Tgt) -> Option<Value<'target, 'static>>
    where
        Tgt: Target<'target>,
    {
        unsafe {
            Some(
                FOREIGN_TYPE_REGISTRY
                    .get_unchecked()
                    .find::<T>()?
                    .as_value(),
            )
        }
    }

    fn construct_type_with_env_uncached<'target, Tgt>(
        target: Tgt,
        _env: &super::construct_type::TypeVarEnv,
    ) -> ValueData<'target, 'static, Tgt>
    where
        Tgt: Target<'target>,
    {
        unsafe {
            FOREIGN_TYPE_REGISTRY
                .get_unchecked()
                .find::<T>()
                .unwrap()
                .as_value()
                .root(target)
        }
    }
}
