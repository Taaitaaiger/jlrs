use std::{fmt::Debug, marker::PhantomData, mem::ManuallyDrop};

use crate::{
    convert::unbox::Unbox,
    data::types::{construct_type::ConstructType, typecheck::Typecheck},
    memory::target::frame::GcFrame,
    prelude::{JlrsResult, Managed}, error::{AccessError, CANNOT_DISPLAY_TYPE},
};

use super::valid_layout::{ValidField, ValidLayout};

/// Associates a type constructor with a layout.
///
/// This trait is automatically implemented for types that are both a valid layout and a type
/// constructor (e.g. `f64`). If a separate layout and type constructor are generated by
/// `JlrsCore.Reflect`, an implementation of this trait is also generated for the pair.
///
/// You should never need to implement this trait yourself.
pub trait AssociatedTypeConstructor<U>: ValidLayout
where
    U: ConstructType + AssociatedLayout<Layout = Self>,
{
}

pub unsafe trait AssociatedLayout {
    type Layout: ValidLayout;
}

impl<T: ValidLayout + ConstructType> AssociatedTypeConstructor<T> for T {}

unsafe impl<T: ValidLayout + ConstructType> AssociatedLayout for T {
    type Layout = T;
}

#[repr(transparent)]
pub struct TypedLayout<T, U>
where
    T: ValidLayout,
    U: ConstructType,
{
    data: T,
    _ctor: PhantomData<U>,
}

impl<T, U> TypedLayout<T, U>
where
    T: 'static + ValidLayout,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
    pub fn from_layout(data: T) -> Self {
        TypedLayout {
            data,
            _ctor: PhantomData,
        }
    }
}

impl<T, U> TypedLayout<T, U>
where
    T: 'static + ValidLayout,
    U: ConstructType,
{
    pub fn try_from_layout(frame: &mut GcFrame, data: T) -> JlrsResult<Self> {
        frame.scope(|mut frame| {
            let ty = U::construct_type(frame.as_extended_target());

            if !T::valid_layout(ty) {
                let value_type = ty.display_string_or(CANNOT_DISPLAY_TYPE).into();
                Err(AccessError::InvalidLayout { value_type })?;
            }

            Ok(TypedLayout {
                data,
                _ctor: PhantomData,
            })
        })
    }
}

pub type TypedLayoutFor<U> = TypedLayout<<U as AssociatedLayout>::Layout, U>;

pub unsafe trait AssociateType<Typed>: Sized {
    fn associate_type(self) -> Typed {
        unsafe { std::mem::transmute_copy::<ManuallyDrop<Self>, Typed>(&ManuallyDrop::new(self)) }
    }
}

unsafe impl<T, U> AssociateType<TypedLayout<T, U>> for T
where
    T: ValidLayout + AssociatedTypeConstructor<U>,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
}

unsafe impl<T, U> AssociateType<TypedLayout<T, U>> for TypedLayout<T, U>
where
    T: ValidLayout + AssociatedTypeConstructor<U>,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
}

unsafe impl<T, U> ValidLayout for TypedLayout<T, U>
where
    T: ValidLayout + AssociatedTypeConstructor<U>,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
    fn valid_layout(ty: crate::prelude::Value) -> bool {
        T::valid_layout(ty)
    }
}

unsafe impl<T, U> ValidField for TypedLayout<T, U>
where
    T: ValidLayout + AssociatedTypeConstructor<U> + ValidField,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
    fn valid_field(ty: crate::prelude::Value) -> bool {
        T::valid_field(ty)
    }
}

unsafe impl<T, U> ConstructType for TypedLayout<T, U>
where
    T: ValidLayout + AssociatedTypeConstructor<U>,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
    type Static = U::Static;

    fn construct_type<'target, Tgt>(
        target: crate::memory::target::ExtendedTarget<'target, '_, '_, Tgt>,
    ) -> crate::data::managed::value::ValueData<'target, 'static, Tgt>
    where
        Tgt: crate::prelude::Target<'target>,
    {
        U::construct_type(target)
    }

    fn base_type<'target, Tgt>(target: &Tgt) -> Option<crate::prelude::Value<'target, 'static>>
    where
        Tgt: crate::prelude::Target<'target>,
    {
        U::base_type(target)
    }
}

impl<T, U> Clone for TypedLayout<T, U>
where
    T: ValidLayout + AssociatedTypeConstructor<U> + Clone,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
    fn clone(&self) -> Self {
        TypedLayout {
            data: self.data.clone(),
            _ctor: self._ctor,
        }
    }
}

impl<T, U> Debug for TypedLayout<T, U>
where
    T: ValidLayout + AssociatedTypeConstructor<U> + Debug,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.data.fmt(f)
    }
}

unsafe impl<T, U> Unbox for TypedLayout<T, U>
where
    T: ValidLayout + AssociatedTypeConstructor<U> + Unbox,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
    type Output = T::Output;
    unsafe fn unbox(value: crate::prelude::Value) -> Self::Output {
        T::unbox(value)
    }
}

unsafe impl<T, U> Typecheck for TypedLayout<T, U>
where
    T: ValidLayout + AssociatedTypeConstructor<U> + Typecheck,
    U: ConstructType + AssociatedLayout<Layout = T>,
{
    fn typecheck(t: crate::prelude::DataType) -> bool {
        T::typecheck(t)
    }
}
