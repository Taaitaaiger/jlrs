<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","error.rs"],"content":"//! Everything related to errors.\n\nuse crate::value::array::Dimensions;\nuse std::error::Error;\nuse std::fmt::{Display, Formatter, Result as FmtResult};\n\n/// Alias that is used for most `Result`s in this crate.\npub type JlrsResult\u003cT\u003e = Result\u003cT, Box\u003cJlrsError\u003e\u003e;\n\n/// All different errors.\n#[derive(Debug)]\npub enum JlrsError {\n    Other(Box\u003cdyn Error + Send + Sync\u003e),\n    Exception(String),\n    AlreadyInitialized,\n    ConstAlreadyExists(String),\n    NotAnArray,\n    Nothing,\n    NotADataType,\n    NotAMethod,\n    NotAMethodInstance,\n    NotACodeInstance,\n    NotAWeakRef,\n    NotATypeMapEntry,\n    NotATypeMapLevel,\n    NotAnExpr,\n    NotATask,\n    NotASymbol,\n    NotAString,\n    NotUnicode,\n    NotAnSVec,\n    NotAnSSAValue,\n    NotATypeName,\n    NotATypeVar,\n    NotAUnion,\n    NotAUnionAll,\n    FunctionNotFound(String),\n    IncludeNotFound(String),\n    IncludeError(String, String),\n    NoSuchField(String),\n    InvalidArrayType,\n    InvalidCharacter,\n    NotAModule(String),\n    NotAMethTable,\n    AllocError(AllocError),\n    WrongType,\n    NotInline,\n    NullFrame,\n    Inline,\n    NotAPointerField(usize),\n    ZeroDimension,\n    OutOfBounds(usize, usize),\n    InvalidIndex(Dimensions, Dimensions),\n}\n\npub fn exception\u003cT\u003e(exc: String) -\u003e JlrsResult\u003cT\u003e {\n    Err(JlrsError::Exception(exc))?\n}\n\npub fn other\u003cE: Error + Send + Sync + 'static\u003e(reason: E) -\u003e JlrsResult\u003c()\u003e {\n    Err(JlrsError::Other(Box::new(reason)))?\n}\n\nimpl JlrsError {\n    pub(crate) fn other\u003cE: Error + Send + Sync + 'static\u003e(reason: E) -\u003e Self {\n        JlrsError::Other(Box::new(reason))\n    }\n}\n\nimpl Display for JlrsError {\n    fn fmt(\u0026self, formatter: \u0026mut Formatter) -\u003e FmtResult {\n        match self {\n            JlrsError::Other(other) =\u003e write!(formatter, \"An error occurred: {}\", other),\n            JlrsError::AlreadyInitialized =\u003e {\n                write!(formatter, \"The runtime was already initialized\")\n            }\n            JlrsError::Exception(exc) =\u003e write!(formatter, \"An exception was thrown: {}\", exc),\n            JlrsError::NotAnArray =\u003e write!(formatter, \"This is not an array\"),\n            JlrsError::NotAString =\u003e write!(formatter, \"This is not a string\"),\n            JlrsError::NotUnicode =\u003e write!(formatter, \"This string contains invalid characters\"),\n            JlrsError::Nothing =\u003e write!(formatter, \"This value is Nothing\"),\n            JlrsError::ConstAlreadyExists(name) =\u003e {\n                write!(formatter, \"The constant {} already exists\", name)\n            }\n            JlrsError::FunctionNotFound(func) =\u003e {\n                write!(formatter, \"The function {} could not be found\", func)\n            }\n            JlrsError::NoSuchField(field) =\u003e {\n                write!(formatter, \"The field {} could not be found\", field)\n            }\n            JlrsError::IncludeNotFound(inc) =\u003e {\n                write!(formatter, \"The file {} could not be found\", inc)\n            }\n            JlrsError::IncludeError(inc, err_type) =\u003e write!(\n                formatter,\n                \"The file {} could not be included successfully. Exception type: {}\",\n                inc, err_type\n            ),\n            JlrsError::InvalidArrayType =\u003e write!(formatter, \"Invalid array type\"),\n            JlrsError::InvalidCharacter =\u003e write!(formatter, \"Invalid character\"),\n            JlrsError::NullFrame =\u003e write!(\n                formatter,\n                \"NullFrames don't support allocations or nesting another NullFrame\"\n            ),\n            JlrsError::NotAPointerField(idx) =\u003e {\n                write!(formatter, \"The field at index {} is stored inline\", idx)\n            }\n            JlrsError::NotInline =\u003e {\n                write!(formatter, \"The data of this array is not stored inline\")\n            }\n            JlrsError::NotAMethTable =\u003e write!(formatter, \"This is not a method table\"),\n            JlrsError::NotAnSVec =\u003e write!(formatter, \"This is not a simple vector\"),\n            JlrsError::NotAnSSAValue =\u003e write!(formatter, \"This is not an SSA value\"),\n            JlrsError::NotATypeName =\u003e write!(formatter, \"This is not a typename\"),\n            JlrsError::NotATypeVar =\u003e write!(formatter, \"This is not a type var\"),\n            JlrsError::NotAUnion =\u003e write!(formatter, \"This is not a union\"),\n            JlrsError::NotAUnionAll =\u003e write!(formatter, \"This is not a UnionAll\"),\n\n            JlrsError::NotAMethodInstance =\u003e write!(formatter, \"This is not a method instance\"),\n            JlrsError::NotACodeInstance =\u003e write!(formatter, \"This is not a code instance\"),\n            JlrsError::NotAWeakRef =\u003e write!(formatter, \"This is not a weak ref\"),\n            JlrsError::NotATypeMapEntry =\u003e write!(formatter, \"This is not a typemap entry\"),\n            JlrsError::NotATypeMapLevel =\u003e write!(formatter, \"This is not a typemap level\"),\n            JlrsError::NotAnExpr =\u003e write!(formatter, \"This is not an expr\"),\n            JlrsError::NotATask =\u003e write!(formatter, \"This is not a task\"),\n\n            JlrsError::Inline =\u003e write!(formatter, \"The data of this array is stored inline\"),\n            JlrsError::NotADataType =\u003e write!(formatter, \"This is not a datatype\"),\n            JlrsError::NotAMethod =\u003e write!(formatter, \"This is not a method\"),\n            JlrsError::NotASymbol =\u003e write!(formatter, \"This is not a symbol\"),\n            JlrsError::NotAModule(module) =\u003e write!(formatter, \"{} is not a module\", module),\n            JlrsError::AllocError(AllocError::FrameOverflow(n, cap)) =\u003e write!(\n                formatter,\n                \"The frame cannot handle more data. Tried to allocate: {}; capacity: {}\",\n                n, cap,\n            ),\n            JlrsError::AllocError(AllocError::StackOverflow(n, cap)) =\u003e write!(\n                formatter,\n                \"The stack cannot handle more data. Tried to allocate: {}; capacity: {}\",\n                n, cap,\n            ),\n            JlrsError::WrongType =\u003e {\n                write!(formatter, \"Requested type does not match the found type\")\n            }\n            JlrsError::ZeroDimension =\u003e {\n                write!(formatter, \"Cannot handle arrays with zero dimensions\")\n            }\n            JlrsError::OutOfBounds(idx, sz) =\u003e write!(\n                formatter,\n                \"Cannot access value at index {} because the number of values is {}\",\n                idx, sz\n            ),\n            JlrsError::InvalidIndex(idx, sz) =\u003e write!(\n                formatter,\n                \"Index {} is not valid for array with shape {}\",\n                idx, sz\n            ),\n        }\n    }\n}\n\nimpl Error for JlrsError {}\n\nimpl Into\u003cBox\u003cJlrsError\u003e\u003e for Box\u003cdyn Error + Send + Sync + 'static\u003e {\n    fn into(self) -\u003e Box\u003cJlrsError\u003e {\n        Box::new(JlrsError::Other(self))\n    }\n}\n\n/// Frames and data they protect have a memory cost. If the memory set aside for containing frames\n/// or the frame itself is exhausted, this error is returned.\n#[derive(Copy, Clone, Debug)]\npub enum AllocError {\n    //            desired, cap\n    StackOverflow(usize, usize),\n    FrameOverflow(usize, usize),\n}\n\nimpl Into\u003cJlrsError\u003e for AllocError {\n    fn into(self) -\u003e JlrsError {\n        JlrsError::AllocError(self)\n    }\n}\n\nimpl Into\u003cBox\u003cJlrsError\u003e\u003e for AllocError {\n    fn into(self) -\u003e Box\u003cJlrsError\u003e {\n        Box::new(self.into())\n    }\n}\n","traces":[{"line":60,"address":4283744,"length":1,"stats":{"Line":0},"fn_name":"other\u003cndarray::error::ShapeError\u003e"},{"line":61,"address":4283811,"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":187,"address":null,"length":0,"stats":{"Line":2},"fn_name":null}],"covered":4,"coverable":74},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","frame.rs"],"content":"//! Frames ensure Julia's garbage collector is properly managed.\n//!\n//! Julia data is freed by the GC when it's not in use. You will need to use frames to do things\n//! like calling Julia functions and creating new values, this ensures the values created with a\n//! specific frame are protected from garbage collection until that frame goes out of scope.\n//!\n//! Three different kinds of frames exist; [`StaticFrame`], [`DynamicFrame`], and [`NullFrame`].\n//! The first two of them can be nested and freely mixed. The main difference between the two is\n//! that a [`StaticFrame`] is created with a definite capacity, while a [`DynamicFrame`] will\n//! dynamically grow its capacity whenever a value is created or a function is called. A\n//! [`StaticFrame`] is more efficient, a [`DynamicFrame`] is easier to use. Creating a nested\n//! frame takes no space in the current frame.\n//!\n//! The third type, [`NullFrame`] can only be used if you call Rust from Julia. They don't\n//! allocate at all and can only be used to borrow array data.\n//!\n//! Frames have a lifetime, `'frame`. This lifetime ensures that a [`Value`] can only be used as\n//! long as the frame that protects it has not been dropped.\n//!\n//! Most functionality that frames implement is defined by the [`Frame`] trait.\n//!\n//! [`StaticFrame`]: struct.StaticFrame.html\n//! [`DynamicFrame`]: struct.DynamicFrame.html\n//! [`NullFrame`]: struct.NullFrame.html\n//! [`Julia::frame`]: ../struct.Julia.html#method.frame\n//! [`Julia::dynamic_frame`]: ../struct.Julia.html#method.dynamic_frame\n//! [`Value`]: ../value/struct.Value.html\n//! [`Frame`]: ../traits/trait.Frame.html\n\nuse crate::error::JlrsResult;\nuse crate::stack::{Dynamic, FrameIdx, StackView, Static};\nuse crate::CCall;\nuse std::marker::PhantomData;\n\n/// A `StaticFrame` is a frame that has a definite number of slots on the GC stack. With some\n/// exceptions, creating new `Value`s and calling them require one slot each. Rather than using\n/// new slots on the GC stack when a slot is needed, a `StaticFrame` uses the slots it acquired on\n/// creation. See the documentation in the [`value`] module for more information about the costs.\n/// You get access to a `StaticFrame` by calling [`Julia::frame`] or [`Frame::frame`], most of\n/// their functionality is defined in the [`Frame`] trait.\n///\n/// [`value`]: ../value/index.html\n/// [`Julia::frame`]: ../struct.Julia.html#method.frame\n/// [`Frame::frame`]: ../traits/trait.Frame.html#method.frame\n/// [`Frame`]: ../traits/trait.Frame.html\npub struct StaticFrame\u003c'frame\u003e {\n    pub(crate) idx: FrameIdx,\n    pub(crate) memory: StackView\u003c'frame, Static\u003e,\n    pub(crate) capacity: usize,\n    pub(crate) len: usize,\n}\n\nimpl\u003c'frame\u003e StaticFrame\u003c'frame\u003e {\n    pub(crate) unsafe fn with_capacity(\n        idx: FrameIdx,\n        capacity: usize,\n        memory: StackView\u003c'frame, Static\u003e,\n    ) -\u003e StaticFrame\u003c'frame\u003e {\n        StaticFrame {\n            idx,\n            memory,\n            capacity,\n            len: 0,\n        }\n    }\n\n    pub(crate) unsafe fn nested_frame\u003c'nested\u003e(\n        \u0026'nested mut self,\n        capacity: usize,\n    ) -\u003e JlrsResult\u003cStaticFrame\u003c'nested\u003e\u003e {\n        let idx = self.memory.new_frame(capacity)?;\n        Ok(StaticFrame {\n            idx,\n            memory: self.memory.nest_static(),\n            capacity,\n            len: 0,\n        })\n    }\n\n    /// Returns the total number of slots.\n    pub fn capacity(\u0026self) -\u003e usize {\n        self.capacity\n    }\n}\n\nimpl\u003c'frame\u003e Drop for StaticFrame\u003c'frame\u003e {\n    fn drop(\u0026mut self) {\n        unsafe {\n            self.memory.pop_frame(self.idx);\n        }\n    }\n}\n\n/// A `DynamicFrame` is a frame that has a dynamic number of slots on the GC stack. With some\n/// exceptions, creating new `Value`s and calling them require one slot each. A `DynamicFrame`\n/// acquires a new slot every time one is needed. See the documentation in the [`value`] module\n/// for more information about the costs. You get access to a `DynamicFrame` by calling\n/// [`Julia::dynamic_frame`] or [`Frame::dynamic_frame`], most of\n/// their functionality is defined in the [`Frame`] trait.\n///\n/// [`value`]: ../value/index.html\n/// [`Julia::dynamic_frame`]: ../struct.Julia.html#method.dynamic_frame\n/// [`Frame::dynamic_frame`]: ../traits/trait.Frame.html#method.dynamic_frame\n/// [`Frame`]: ../traits/trait.Frame.html\npub struct DynamicFrame\u003c'frame\u003e {\n    pub(crate) idx: FrameIdx,\n    pub(crate) memory: StackView\u003c'frame, Dynamic\u003e,\n    pub(crate) len: usize,\n}\n\nimpl\u003c'frame\u003e DynamicFrame\u003c'frame\u003e {\n    pub(crate) unsafe fn new(idx: FrameIdx, memory: StackView\u003c'frame, Dynamic\u003e) -\u003e Self {\n        DynamicFrame {\n            idx,\n            memory,\n            len: 0,\n        }\n    }\n\n    pub(crate) unsafe fn nested_frame\u003c'nested\u003e(\n        \u0026'nested mut self,\n    ) -\u003e JlrsResult\u003cDynamicFrame\u003c'nested\u003e\u003e {\n        let idx = self.memory.new_frame()?;\n        Ok(DynamicFrame {\n            idx,\n            memory: self.memory.nest_dynamic(),\n            len: 0,\n        })\n    }\n}\n\nimpl\u003c'frame\u003e Drop for DynamicFrame\u003c'frame\u003e {\n    fn drop(\u0026mut self) {\n        unsafe {\n            self.memory.pop_frame(self.idx);\n        }\n    }\n}\n\n/// An `Output` is a slot of a frame that has been reserved for later use. It can be used to\n/// extend the lifetime of the result of a function call to the `Output`'s lifetime. You can\n/// create an output by calling [`Frame::output`].\n///\n/// [`Frame::output`]: ../traits/trait.Frame.html#method.output\npub struct Output\u003c'frame\u003e {\n    pub(crate) offset: usize,\n    _marker: PhantomData\u003c\u0026'frame ()\u003e,\n}\n\nimpl\u003c'frame\u003e Output\u003c'frame\u003e {\n    pub(crate) unsafe fn new(offset: usize) -\u003e Self {\n        Output {\n            offset,\n            _marker: PhantomData,\n        }\n    }\n}\n\n/// A `NullFrame` can be used if you call Rust from Julia through `ccall` and want to borrow array\n/// data but not perform any allocations. It can't be nested or be used for functions that\n/// allocate (like creating new values or calling functions). Functions that depend on allocation\n/// will return `JlrsError::NullFrame` if you call them with a `NullFrame`.\npub struct NullFrame\u003c'frame\u003e(PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e NullFrame\u003c'frame\u003e {\n    pub(crate) unsafe fn new(_: \u0026'frame mut CCall) -\u003e Self {\n        NullFrame(PhantomData)\n    }\n}\n","traces":[{"line":54,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":67,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":71,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":72,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":73,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":75,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":89,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":112,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":120,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":127,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":135,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":151,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":166,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":167,"address":null,"length":0,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":24},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","global.rs"],"content":"//! Access token for global Julia data.\n\nuse std::marker::PhantomData;\n\n/// Some kinds of values don't need to be protected from garbage collection, including\n/// [`Symbol`]s, [`Module`]s, and functions and other globals defined in those modules. You will\n/// need this struct to access these values, you acquire it when you create a base frame through\n/// [`Julia::frame`] or [`Julia::dynamic_frame`].\n///\n/// [`Symbol`]: ../value/symbol/struct.Symbol.html\n/// [`Module`]: ../value/module/struct.Module.html\n/// [`Julia::frame`]: ../struct.Julia.html#method.frame\n/// [`Julia::dynamic_frame`]: ../struct.Julia.html#method.dynamic_frame\n#[derive(Copy, Clone)]\npub struct Global\u003c'base\u003e(PhantomData\u003c\u0026'base ()\u003e);\n\nimpl\u003c'base\u003e Global\u003c'base\u003e {\n    #[doc(hidden)]\n\n    pub unsafe fn new() -\u003e Self {\n        Global(PhantomData)\n    }\n}\n","traces":[{"line":20,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":21,"address":null,"length":0,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":2},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","lib.rs"],"content":"//! The main goal behind `jlrs` is to provide a simple and safe interface to the Julia C API.\n//! Currently this crate is only tested on Linux and Windows in combination with Julia 1.5.1 and\n//! is not compatible with earlier versions of Julia.\n//!\n//!\n//! # Features\n//!\n//! An incomplete list of features that are currently supported by `jlrs`:\n//!\n//!  - Access arbitrary Julia modules and their contents.\n//!  - Call arbitrary Julia functions.\n//!  - Include and use your own Julia code.\n//!  - Load a custom system image.\n//!  - Create values that Julia can use, and convert them back to Rust, from Rust.\n//!  - Access the type information and fields of values and check their properties.\n//!  - Create and use n-dimensional arrays.\n//!  - Support for mapping Julia structs to Rust structs, which can be generated with `JlrsReflect.jl`.\n//!  - Structs that can be mapped to Rust include those with type parameters and bits unions.\n//!  - Use all of these features when calling Rust from Julia through `ccall`.\n//!\n//!\n//! # Generating the bindings\n//!\n//! This crate depends on `jl-sys` which contains the raw bindings to the Julia C API, these are\n//! generated by `bindgen`. You can find the requirements for using `bindgen` in\n//! [their User Guide](https://rust-lang.github.io/rust-bindgen/requirements.html).\n//!\n//! #### Linux\n//!\n//! The recommended way to install Julia is to download the binaries from the official website,\n//! which is distributed in an archive containing a directory called `julia-x.y.z`. This directory\n//! contains several other directories, including a `bin` directory containing the `julia`\n//! executable.\n//!\n//! In order to ensure the `julia.h` header file can be found, either `/usr/include/julia/julia.h`\n//! must exist, or you have to set the `JULIA_DIR` environment variable to `/path/to/julia-x.y.z`.\n//! The environment variable can be used to override the default. Similarly, in order to load\n//! `libjulia.so` you must add `/path/to/julia-x.y.z/lib` to the `LD_LIBRARY_PATH` environment\n//! variable.\n//!\n//! #### Windows\n//!\n//! The recommended way to install Julia is to download the installer from the official website,\n//! which will install Julia in a folder called `Julia-x.y.z`. This folder contains several other\n//! folders, including a `bin` folder containing the `julia.exe` executable. You must set the\n//! `JULIA_DIR` environment variable to the `Julia-x.y.z` folder and add `Julia-x.y.z\\bin` to the\n//! `PATH` environment variable. For example, if Julia is installed at `D:\\Julia-x.y.z`,\n//! `JULIA_DIR` must be set to `D:\\Julia-x.y.z` and `D:\\Julia-x.y.z\\bin` must be added to `PATH`.\n//!\n//! Additionally, MinGW must be installed through Cygwin. To install this and all potentially\n//! required dependencies, follow steps 1-4 of\n//! [the instructions for compiling Julia on Windows using Cygwin and MinGW].\n//! You must set the `CYGWIN_DIR` environment variable to the installation folder of Cygwin; this\n//! folder contains some icons, `Cygwin.bat` and folders with names like `usr` and `bin`. For\n//! example, if Cygwin is installed at `D:\\cygwin64`, `CYGWIN_DIR` must be set to `D:\\cygwin64`.\n//!\n//! Julia is compatible with the GNU toolchain on Windows. If you use rustup, you can set the\n//! toolchain for a project that depends on `jl-sys` by calling the command\n//! `rustup override set stable-gnu` in the project root folder.\n//!\n//!\n//! # Using this crate\n//!\n//! The first thing you should do is `use` the [`prelude`]-module with an asterisk, this will\n//! bring all the structs and traits you're likely to need into scope. If you're calling Julia\n//! from Rust, you must initialize Julia before you can use it. You can do this by calling\n//! [`Julia::init`]. Note that this method can only be called once, if you drop [`Julia`] you won't\n//! be able to create a new one and have to restart the entire program. If you want to use a\n//! custom system image, you must call [`Julia::init_with_image`] instead of [`Julia::init`].\n//! If you're calling Rust from Julia everything has already been initialized, you can use `CCall`\n//! instead.\n//!\n//! ## Calling Julia from Rust\n//!\n//! You can call [`Julia::include`] to include your own Julia code and either [`Julia::frame`] or\n//! [`Julia::dynamic_frame`] to interact with Julia. If you want to have improved support for\n//! backtraces `jlrs.jl` must be included. You can find this file in the root of this crate's github\n//! repository. This is necessary because this functionality depends on some Julia code defined in\n//! that file.\n//!\n//! The other two methods, [`Julia::frame`] and [`Julia::dynamic_frame`], take a closure that\n//! provides you with a [`Global`], and either a [`StaticFrame`] or [`DynamicFrame`] respectively.\n//! [`Global`] is a token that lets you access Julia modules their contents, and other global\n//! values, while the frames are used to deal with local Julia data.\n//!\n//! Local data must be handled properly: Julia is a programming language with a garbage collector\n//! that is unaware of any references to data outside of Julia. In order to make it aware of this\n//! usage a stack must be maintained. You choose this stack's size when calling [`Julia::init`].\n//! The elements of this stack are called stack frames; they contain a pointer to the previous\n//! frame, the number of protected values, and that number of pointers to values. The two frame\n//! types offered by `jlrs` take care of all the technical details, a [`DynamicFrame`] will grow\n//! to the required size while a [`StaticFrame`] has a definite number of slots. These frames can\n//! be nested (ie stacked) arbitrarily.\n//!\n//! In order to call a Julia function, you'll need two things: a function to call, and arguments\n//! to call it with. You can acquire the function through the module that defines it with\n//! [`Module::function`]; [`Module::base`] and [`Module::core`] provide access to Julia's `Base`\n//! and `Core` module respectively, while everything you include through [`Julia::include`] is\n//! made available relative to the `Main` module which you can access by calling [`Module::main`].\n//!\n//! Julia data is represented by a [`Value`]. Basic data types like numbers, booleans, and strings\n//! can be created through [`Value::new`] and several methods exist to create an n-dimensional\n//! array. Each value will be protected by a frame, and the two share a lifetime in order to\n//! enforce that a value can only be used as long as its protecting frame hasn't been dropped.\n//! Julia functions, their arguments and their results are all `Value`s too. All `Value`s can be\n//! called as functions, whether this will succeed depends on the value actually being a function.\n//! You can copy data from Julia to Rust by calling [`Value::cast`].\n//!\n//! As a simple example, let's create two values and add them:\n//!\n//! ```no_run\n//! # use jlrs::prelude::*;\n//! # fn main() {\n//! let mut julia = unsafe { Julia::init(16).unwrap() };\n//! julia.dynamic_frame(|global, frame| {\n//!     // Create the two arguments\n//!     let i = Value::new(frame, 2u64)?;\n//!     let j = Value::new(frame, 1u32)?;\n//!\n//!     // We can find the addition-function in the base module\n//!     let func = Module::base(global).function(\"+\")?;\n//!\n//!     // Call the function and unbox the result\n//!     let output = func.call2(frame, i, j)?.unwrap();\n//!     output.cast::\u003cu64\u003e()\n//! }).unwrap();\n//! # }\n//! ```\n//!\n//! You can also do this with a static frame:\n//!\n//! ```no_run\n//! # use jlrs::prelude::*;\n//! # fn main() {\n//! let mut julia = unsafe { Julia::init(16).unwrap() };\n//! // Three slots; two for the inputs and one for the output.\n//! julia.frame(3, |global, frame| {\n//!     // Create the two arguments, each value requires one slot\n//!     let i = Value::new(frame, 2u64)?;\n//!     let j = Value::new(frame, 1u32)?;\n//!\n//!     // We can find the addition-function in the base module\n//!     let func = Module::base(global).function(\"+\")?;\n//!\n//!     // Call the function and unbox the result.  \n//!     let output = func.call2(frame, i, j)?.unwrap();\n//!     output.cast::\u003cu64\u003e()\n//! }).unwrap();\n//! # }\n//! ```\n//!\n//! This is only a small example, other things can be done with [`Value`] as well: their fields\n//! can be accessed if the [`Value`] is some tuple or struct. They can contain more complex data;\n//! if a function returns an array or a module it will still be returned as a [`Value`]. There\n//! complex types are compatible with [`Value::cast`]. Additionally, you can create [`Output`]s in\n//! a frame in order to protect a value from with a specific frame; this value will share that\n//! frame's lifetime.\n//!\n//! ## Calling Rust from Julia\n//!\n//! Julia's `ccall` interface can be used to call `extern \"C\"` functions defined in Rust. There\n//! are two major ways to use `ccall`, with a pointer to the function or a\n//! `(:function, \"library\")` pair.\n//!\n//! A function can be cast to a void pointer and converted to a `Value`:\n//!\n//! ```no_run\n//! unsafe extern \"C\" fn call_me(arg: bool) -\u003e isize {\n//!     if arg {\n//!         1\n//!     } else {\n//!         -1\n//!     }\n//! }\n//!\n//! # use jlrs::prelude::*;\n//! # fn main() {\n//! let mut julia = unsafe { Julia::init(16).unwrap() };\n//! julia.frame(2, |global, frame| {\n//!     // Cast the function to a void point\n//!     let call_me_val = Value::new(frame, call_me as *mut std::ffi::c_void)?;\n//!\n//!     // `myfunc` will call the function pointer\n//!     let func = Module::main(global).function(\"myfunc\")?;\n//!\n//!     // Call the function and unbox the result.  \n//!     let _output = func.call1(frame, call_me_val)?.unwrap();\n//!     Ok(())\n//! }).unwrap();\n//! # }\n//! ```\n//!\n//! This pointer can be called from Julia:\n//!\n//! ```julia\n//! function myfunc(callme::Ptr)::Int\n//!     ccall(callme, Int, (Bool,), true)\n//! end\n//! ```\n//!\n//! You can also use functions defined in `dylib` and `cdylib` libraries. If you want to use\n//! functions defined in these libraries, those functions must be both `extern \"C\"` functions and\n//! annotated with `#[no_mangle]` to prevent name mangling. If the compiled library is not\n//! directly visible to Julia, you can open it with `Libdl.dlopen` and acquire function pointers\n//! with `Libdl.dlsym`. These pointers can be called the same way as the pointer in the previous\n//! example.\n//!\n//! If the library is visible to Julia you can access it with the library name. If `call_me` is\n//! defined in a crate called `foo`, the following should work:\n//!\n//! ```julia\n//! ccall((:call_me, \"libfoo\"), Int, (Bool,), false)\n//! ```\n//!\n//! One important aspect of calling Rust from other languages in general is that panicking across\n//! an FFI boundary is undefined behaviour. If you're not sure your code will never panic, wrap it\n//! with `std::panic::catch_unwind`.\n//!\n//! Many features provided by `jlrs` like accessing modules, calling functions, and borrowing\n//! array data require a [`Global`] or a frame. You can access these by creating a [`CCall`]\n//! first.\n//!\n//!\n//! # Custom types\n//!\n//! In order to map a struct in Rust to one in Julia you can derive [`JuliaStruct`]. This will\n//! implement [`Cast`], [`JuliaType`], [`ValidLayout`], and [`JuliaTypecheck`] for that type. If\n//! the struct in Julia has no type parameters and is a bits type you can also derive\n//! [`IntoJulia`], which lets you use the type in combination with [`Value::new`].\n//!\n//! You should not implement these structs manually. The `JlrsReflect.jl` package can generate\n//! generate the correct Rust struct for types that don't include any unions or tuples with type\n//! parameters. The reason for this restriction is that the layout of tuple and union fields can\n//! be very different depending on these parameters in a way that can't be nicely expressed in\n//! Rust.\n//!\n//! These custom types can also be used when you call Rust from Julia through `ccall`.\n//!\n//!\n//! # Lifetimes\n//!\n//! While reading the documentation for this crate, you will see that a lot of lifetimes are used.\n//! Most of these lifetimes have a specific meaning:\n//!\n//! - `'base` is the lifetime of a frame created through [`Julia::frame`] or\n//! [`Julia::dynamic_frame`]. This lifetime prevents you from using global Julia data outside of a\n//! frame.\n//!\n//! - `'frame` is the lifetime of an arbitrary frame; in the base frame it will be the same as\n//! `'base`. This lifetime prevents you from using Julia data after the frame that protects it\n//! from garbage collection goes out of scope.\n//!\n//! - `'data` or `'borrow` is the lifetime of data that is borrowed. This lifetime prevents you\n//! from mutably aliasing data and trying to use it after the borrowed data is dropped.\n//!\n//! - `'output` is the lifetime of the frame that created the output. This lifetime ensures that\n//! when Julia data is protected by an older frame this data can be used until that frame goes out\n//! of scope.\n//!\n//! [`prelude`]: prelude/index.html\n//! [`Julia`]: struct.Julia.html\n//! [`CCall`]: struct.CCall.html\n//! [`Julia::init`]: struct.Julia.html#method.init\n//! [`Julia::init_with_image`]: struct.Julia.html#method.init_with_image\n//! [`Julia::include`]: struct.Julia.html#method.include\n//! [`Julia::frame`]: struct.Julia.html#method.frame\n//! [`Julia::dynamic_frame`]: struct.Julia.html#method.dynamic_frame\n//! [`Global`]: global/struct.Global.html\n//! [`Output`]: frame/struct.Output.html\n//! [`StaticFrame`]: frame/struct.StaticFrame.html\n//! [`DynamicFrame`]: frame/struct.DynamicFrame.html\n//! [`Frame`]: traits/trait.Frame.html\n//! [`JuliaStruct`]: traits/trait.JuliaStruct.html\n//! [`Cast`]: traits/trait.Cast.html\n//! [`JuliaType`]: traits/trait.JuliaType.html\n//! [`JuliaTypecheck`]: traits/trait.JuliaTypecheck.html\n//! [`ValidLayout`]: traits/trait.ValidLayout.html\n//! [`IntoJulia`]: traits/trait.IntoJulia.html\n//! [`Module::function`]: value/module/struct.Module.html#method.function\n//! [`Module::base`]: value/module/struct.Module.html#method.base\n//! [`Module::core`]: value/module/struct.Module.html#method.core\n//! [`Module::main`]: value/module/struct.Module.html#method.main\n//! [`Value`]: value/struct.Value.html\n//! [`Value::new`]: value/struct.Value.html#method.new\n//! [`Value::cast`]: value/struct.Value.html#method.cast\n//! [the instructions for compiling Julia on Windows using Cygwin and MinGW]: https://github.com/JuliaLang/julia/blob/v1.4.1/doc/build/windows.md#cygwin-to-mingw-cross-compiling\n\npub mod error;\npub mod frame;\npub mod global;\n#[doc(hidden)]\npub mod jl_sys_export;\npub mod prelude;\nmod stack;\npub mod traits;\n#[doc(hidden)]\npub mod util;\npub mod value;\n\nuse error::{JlrsError, JlrsResult};\nuse frame::{DynamicFrame, NullFrame, StaticFrame};\nuse global::Global;\nuse jl_sys::{jl_atexit_hook, jl_init, jl_init_with_image__threading, jl_is_initialized};\nuse stack::{Dynamic, RawStack, StackView, Static};\nuse std::io::{Error as IOError, ErrorKind};\nuse std::path::Path;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse value::module::Module;\nuse value::Value;\n\nstatic INIT: AtomicBool = AtomicBool::new(false);\n\n/// This struct can be created only once during the lifetime of your program. You must create it\n/// with [`Julia::init`] or [`Julia::init_with_image`] before you can do anything related to\n/// Julia. While this struct exists, Julia is active; dropping it causes the shutdown code to be\n/// called.\n///\n/// [`Julia::init`]: struct.Julia.html#method.init\n/// [`Julia::init_with_image`]: struct.Julia.html#method.init_with_image\npub struct Julia {\n    stack: RawStack,\n}\n\nimpl Julia {\n    /// Initializes Julia, this function can only be called once. If you call it a second time it\n    /// will return an error. If this struct is dropped, you will need to restart your program to\n    /// be able to call Julia code again.\n    ///\n    /// You have to choose a stack size when calling this function. This will be the total number\n    /// of slots that will be available for the GC stack. One of these slots will always be in\n    /// use. Each frame needs two slots of overhead, plus one for every value created with that\n    /// frame. A [`StaticFrame`] preallocates its slots, while a [`DynamicFrame`] grows to the\n    /// required size. If calling a method requires one or more slots, this amount is explicitly\n    /// documented.\n    ///\n    /// This function is unsafe because this crate provides you with a way to execute arbitrary\n    /// Julia code which can't be checked for correctness.\n    ///\n    /// [`StaticFrame`]: frame/struct.StaticFrame.html\n    /// [`DynamicFrame`]: frame/struct.DynamicFrame.html\n    pub unsafe fn init(stack_size: usize) -\u003e JlrsResult\u003cSelf\u003e {\n        if jl_is_initialized() != 0 || INIT.swap(true, Ordering::SeqCst) {\n            return Err(JlrsError::AlreadyInitialized.into());\n        }\n\n        jl_init();\n\n        Ok(Julia {\n            stack: RawStack::new(stack_size),\n        })\n    }\n\n    /// This function is similar to [`Julia::init`] except that it loads a custom system image. A\n    /// custom image can be generated with the [`PackageCompiler`] package for Julia. The main\n    /// advantage of using a custom image over the default one is that it allows you to avoid much\n    /// of the compilation overhead often associated with Julia.\n    ///\n    /// Two additional arguments are required to call this function compared to [`Julia::init`];\n    /// `julia_bindir` and `image_relative_path`. The first must be the absolute path to a\n    /// directory that contains a compatible Julia binary (eg `${JULIA_DIR}/bin`), the second must\n    /// be either an absolute or a relative path to a system image.\n    ///\n    /// This function will return an error if either of the two paths does not exist or if Julia\n    /// has already been initialized.\n    ///\n    /// [`Julia::init`]: struct.Julia.html#init\n    /// [`PackageCompiler`]: https://julialang.github.io/PackageCompiler.jl/dev/\n    pub unsafe fn init_with_image\u003cP: AsRef\u003cPath\u003e\u003e(\n        stack_size: usize,\n        julia_bindir: P,\n        image_path: P,\n    ) -\u003e JlrsResult\u003cSelf\u003e {\n        if INIT.swap(true, Ordering::SeqCst) {\n            Err(JlrsError::AlreadyInitialized)?;\n        }\n\n        let julia_bindir_str = julia_bindir.as_ref().to_string_lossy().to_string();\n        let image_path_str = image_path.as_ref().to_string_lossy().to_string();\n\n        if !julia_bindir.as_ref().exists() {\n            let io_err = IOError::new(ErrorKind::NotFound, julia_bindir_str);\n            return Err(JlrsError::other(io_err))?;\n        }\n\n        if !image_path.as_ref().exists() {\n            let io_err = IOError::new(ErrorKind::NotFound, image_path_str);\n            return Err(JlrsError::other(io_err))?;\n        }\n\n        let bindir = std::ffi::CString::new(julia_bindir_str).unwrap();\n        let im_rel_path = std::ffi::CString::new(image_path_str).unwrap();\n\n        jl_init_with_image__threading(bindir.as_ptr(), im_rel_path.as_ptr());\n\n        Ok(Julia {\n            stack: RawStack::new(stack_size),\n        })\n    }\n\n    /// Change the stack size to `stack_size`.\n    pub fn set_stack_size(\u0026mut self, stack_size: usize) {\n        unsafe { self.stack = RawStack::new(stack_size) }\n    }\n\n    /// Returns the current stack size.\n    pub fn stack_size(\u0026self) -\u003e usize {\n        self.stack.size()\n    }\n\n    /// Calls `include` in the `Main` module in Julia, which executes the file's contents in that\n    /// module. This has the same effect as calling `include` in the Julia REPL.\n    ///\n    /// Example:\n    ///\n    /// ```no_run\n    /// # use jlrs::prelude::*;\n    /// # fn main() {\n    /// # let mut julia = unsafe { Julia::init(16).unwrap() };\n    /// julia.include(\"MyJuliaCode.jl\").unwrap();\n    /// # }\n    /// ```\n    pub fn include\u003cP: AsRef\u003cPath\u003e\u003e(\u0026mut self, path: P) -\u003e JlrsResult\u003c()\u003e {\n        if path.as_ref().exists() {\n            return self.frame(3, |global, frame| {\n                let path_jl_str = Value::new(frame, path.as_ref().to_string_lossy())?;\n                let include_func = Module::main(global).function(\"include\")?;\n                let res = include_func.call1(frame, path_jl_str)?;\n\n                return match res {\n                    Ok(_) =\u003e Ok(()),\n                    Err(e) =\u003e Err(JlrsError::IncludeError(\n                        path.as_ref().to_string_lossy().into(),\n                        e.type_name().into(),\n                    )\n                    .into()),\n                };\n            });\n        }\n\n        Err(JlrsError::IncludeNotFound(path.as_ref().to_string_lossy().into()).into())\n    }\n\n    /// Create a [`StaticFrame`] that can hold `capacity` values, and call the given closure.\n    /// Returns the result of this closure, or an error if the new frame can't be created because\n    /// there's not enough space on the GC stack. The number of required slots on the stack is\n    /// `capacity + 2`.\n    ///\n    /// Every output and value you create inside the closure using the [`StaticFrame`], either\n    /// directly or through calling a [`Value`], will reduce the available capacity of the\n    /// [`StaticFrame`] by 1.\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use jlrs::prelude::*;\n    /// # use jlrs::util::JULIA;\n    /// # fn main() {\n    /// # JULIA.with(|j| {\n    /// # let mut julia = j.borrow_mut();\n    ///   julia.frame(1, |_global, frame| {\n    ///       let i = Value::new(frame, 1u64)?;\n    ///       Ok(())\n    ///   }).unwrap();\n    /// # });\n    /// # }\n    /// ```\n    ///\n    /// [`StaticFrame`]: ../frame/struct.StaticFrame.html\n    /// [`Value`]: ../value/struct.Value.html\n    pub fn frame\u003c'base, 'julia: 'base, T, F\u003e(\n        \u0026'julia mut self,\n        capacity: usize,\n        func: F,\n    ) -\u003e JlrsResult\u003cT\u003e\n    where\n        F: FnOnce(Global\u003c'base\u003e, \u0026mut StaticFrame\u003c'base\u003e) -\u003e JlrsResult\u003cT\u003e,\n    {\n        unsafe {\n            let d = self.stack.as_mut();\n            let global = Global::new();\n            let mut view = StackView::\u003cStatic\u003e::new(d);\n            let frame_idx = view.new_frame(capacity)?;\n            let mut frame = StaticFrame::with_capacity(frame_idx, capacity, view);\n            func(global, \u0026mut frame)\n        }\n    }\n\n    /// Create a [`DynamicFrame`] and call the given closure. Returns the result of this closure,\n    /// or an error if the new frame can't be created because the stack is too small. The number\n    /// of required slots on the stack is 2.\n    ///\n    /// Every output and value you create inside the closure using the [`DynamicFrame`], either\n    /// directly or through calling a [`Value`], will occupy a single slot on the GC stack.\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// # use jlrs::prelude::*;\n    /// # use jlrs::util::JULIA;\n    /// # fn main() {\n    /// # JULIA.with(|j| {\n    /// # let mut julia = j.borrow_mut();\n    /// julia.dynamic_frame(|_global, frame| {\n    ///     let j = Value::new(frame, 1u64)?;\n    ///     Ok(())\n    /// }).unwrap();\n    /// # });\n    /// # }\n    /// ```\n    ///\n    /// [`DynamicFrame`]: ../frame/struct.DynamicFrame.html\n    /// [`Value`]: ../value/struct.Value.html\n    pub fn dynamic_frame\u003c'base, 'julia: 'base, T, F\u003e(\u0026'julia mut self, func: F) -\u003e JlrsResult\u003cT\u003e\n    where\n        F: FnOnce(Global\u003c'base\u003e, \u0026mut DynamicFrame\u003c'base\u003e) -\u003e JlrsResult\u003cT\u003e,\n    {\n        unsafe {\n            let d = self.stack.as_mut();\n            let global = Global::new();\n            let mut view = StackView::\u003cDynamic\u003e::new(d);\n            let frame_idx = view.new_frame()?;\n            let mut frame = DynamicFrame::new(frame_idx, view);\n            func(global, \u0026mut frame)\n        }\n    }\n}\n\nimpl Drop for Julia {\n    fn drop(\u0026mut self) {\n        unsafe {\n            jl_atexit_hook(0);\n        }\n    }\n}\n\n/// When you call Rust from Julia through `ccall`, Julia has already been initialized and trying to\n/// initialize it again would cause a crash. In order to still be able to call Julia from Rust\n/// and to borrow arrays (if you pass them as `Array` rather than `Ptr{Array}`), you'll need to\n/// create a frame first. You can use this struct to do so. It must never be used outside\n/// functions called through `ccall`.\n///\n/// If you only need to use a frame to borrow array data, you can use `CCall::null_frame`. Unlike\n/// `Julia`, `CCall` postpones the allocation of the stack that is used for managing the GC until\n/// a static or dynamic frame is created. In the case of a null frame, this stack isn't allocated\n/// at all. Unlike the other frame types null frames can't be nested.\npub struct CCall {\n    stack: Option\u003cRawStack\u003e,\n    stack_size: usize,\n}\n\nimpl CCall {\n    /// Create a new `CCall` that provides a stack with `stack_size` slots. This functions the\n    /// same way as `Julia::init` does. This function must never be called outside a function\n    /// called through `ccall` from Julia and must only be called once during that call. The stack\n    /// is not allocated untl a static or dynamic frame is created.\n    pub unsafe fn new(stack_size: usize) -\u003e Self {\n        CCall {\n            stack: None,\n            stack_size,\n        }\n    }\n\n    /// Create a new `CCall` that provides a stack with no slots. This means only creating a null\n    /// frame is supported.\n    pub unsafe fn null() -\u003e Self {\n        CCall::new(0)\n    }\n\n    /// Change the stack size to `stack_size`.\n    pub fn set_stack_size(\u0026mut self, stack_size: usize) {\n        self.stack_size = stack_size;\n        if self.stack.is_some() {\n            unsafe { self.stack = Some(RawStack::new(stack_size)) }\n        }\n    }\n\n    /// Returns the current stack size.\n    pub fn stack_size(\u0026self) -\u003e usize {\n        self.stack_size\n    }\n\n    /// Create a [`StaticFrame`] that can hold `capacity` values, and call the given closure.\n    /// Returns the result of this closure, or an error if the new frame can't be created because\n    /// there's not enough space on the GC stack. The number of required slots on the stack is\n    /// `capacity + 2`.\n    ///\n    /// Every output and value you create inside the closure using the [`StaticFrame`], either\n    /// directly or through calling a [`Value`], will reduce the available capacity of the\n    /// [`StaticFrame`] by 1.\n    ///\n    /// [`StaticFrame`]: ../frame/struct.StaticFrame.html\n    /// [`Value`]: ../value/struct.Value.html\n    pub fn frame\u003c'base, 'julia: 'base, T, F\u003e(\n        \u0026'julia mut self,\n        capacity: usize,\n        func: F,\n    ) -\u003e JlrsResult\u003cT\u003e\n    where\n        F: FnOnce(Global\u003c'base\u003e, \u0026mut StaticFrame\u003c'base\u003e) -\u003e JlrsResult\u003cT\u003e,\n    {\n        unsafe {\n            self.ensure_init_stack()\n                .map(|s| {\n                    let d = s.as_mut();\n                    let global = Global::new();\n                    let mut view = StackView::\u003cStatic\u003e::new(d);\n                    let frame_idx = view.new_frame(capacity)?;\n                    let mut frame = StaticFrame::with_capacity(frame_idx, capacity, view);\n                    func(global, \u0026mut frame)\n                })\n                .unwrap_or_else(|| std::hint::unreachable_unchecked()) // The stack is guaranteed to be initialized\n        }\n    }\n\n    /// Create a [`DynamicFrame`] and call the given closure. Returns the result of this closure,\n    /// or an error if the new frame can't be created because the stack is too small. The number\n    /// of required slots on the stack is 2.\n    ///\n    /// Every output and value you create inside the closure using the [`DynamicFrame`], either\n    /// directly or through calling a [`Value`], will occupy a single slot on the GC stack.\n    ///\n    /// [`DynamicFrame`]: ../frame/struct.DynamicFrame.html\n    /// [`Value`]: ../value/struct.Value.html\n    pub fn dynamic_frame\u003c'base, 'julia: 'base, T, F\u003e(\u0026'julia mut self, func: F) -\u003e JlrsResult\u003cT\u003e\n    where\n        F: FnOnce(Global\u003c'base\u003e, \u0026mut DynamicFrame\u003c'base\u003e) -\u003e JlrsResult\u003cT\u003e,\n    {\n        unsafe {\n            self.ensure_init_stack()\n                .map(|s| {\n                    let d = s.as_mut();\n                    let global = Global::new();\n                    let mut view = StackView::\u003cDynamic\u003e::new(d);\n                    let frame_idx = view.new_frame()?;\n                    let mut frame = DynamicFrame::new(frame_idx, view);\n                    func(global, \u0026mut frame)\n                })\n                .unwrap_or_else(|| std::hint::unreachable_unchecked()) // The stack is guaranteed to be initialized\n        }\n    }\n\n    /// Create a [`NullFrame`] and call the given closure. A [`NullFrame`] cannot be nested and\n    /// can only be used to (mutably) borrow array data. Unlike the other frame-creating methods,\n    /// no `Global` is provided to the closure.\n    ///\n    /// [`NullFrame`]: ../frame/struct.NullFrame.html\n    /// [`Global`]: ../global/struct.Global.html\n    pub fn null_frame\u003c'base, 'julia: 'base, T, F\u003e(\u0026'julia mut self, func: F) -\u003e JlrsResult\u003cT\u003e\n    where\n        F: FnOnce(\u0026mut NullFrame\u003c'base\u003e) -\u003e JlrsResult\u003cT\u003e,\n    {\n        unsafe {\n            let mut frame = NullFrame::new(self);\n            func(\u0026mut frame)\n        }\n    }\n\n    #[inline(always)]\n    fn ensure_init_stack(\u0026mut self) -\u003e Option\u003c\u0026mut RawStack\u003e {\n        if self.stack.is_none() {\n            unsafe {\n                self.stack = Some(RawStack::new(self.stack_size));\n            }\n        }\n\n        self.stack.as_mut()\n    }\n}\n","traces":[{"line":341,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":342,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":343,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":346,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":348,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":349,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":368,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":402,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":406,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":422,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":423,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":424,"address":null,"length":0,"stats":{"Line":44},"fn_name":null},{"line":425,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":426,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":427,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":429,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":431,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":432,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":433,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":470,"address":null,"length":0,"stats":{"Line":237},"fn_name":null},{"line":479,"address":null,"length":0,"stats":{"Line":237},"fn_name":null},{"line":480,"address":null,"length":0,"stats":{"Line":237},"fn_name":null},{"line":481,"address":null,"length":0,"stats":{"Line":237},"fn_name":null},{"line":482,"address":null,"length":0,"stats":{"Line":237},"fn_name":null},{"line":483,"address":null,"length":0,"stats":{"Line":237},"fn_name":null},{"line":484,"address":null,"length":0,"stats":{"Line":237},"fn_name":null},{"line":513,"address":4221120,"length":1,"stats":{"Line":87},"fn_name":"dynamic_frame\u003c(),closure-0\u003e"},{"line":518,"address":null,"length":0,"stats":{"Line":87},"fn_name":null},{"line":519,"address":null,"length":0,"stats":{"Line":87},"fn_name":null},{"line":520,"address":null,"length":0,"stats":{"Line":87},"fn_name":null},{"line":521,"address":null,"length":0,"stats":{"Line":87},"fn_name":null},{"line":522,"address":null,"length":0,"stats":{"Line":87},"fn_name":null},{"line":523,"address":null,"length":0,"stats":{"Line":87},"fn_name":null},{"line":529,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":556,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":565,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":602,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":4229056,"length":1,"stats":{"Line":1},"fn_name":"null_frame\u003cbool,closure-0\u003e"},{"line":653,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":654,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":659,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":662,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":null,"length":0,"stats":{"Line":0},"fn_name":null}],"covered":40,"coverable":72},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","stack.rs"],"content":"// In order to prevent the GC from freeing things that are in use, the Julia C API offers a few\n// macros that should be used. These macros allocate some space on the stack with alloca and use\n// it to construct a struct of type jl_gcframe_t. The first two fields contain the number of\n// protected values (times two) and a pointer to the previous frame, then pointers to the values\n// that should not be freed.\n//\n// Rust doesn't really like dynamically sized types, and as far as I'm aware something like alloca\n// is unavailable. As a workaround jlrs creates a boxed array to contain these frames. A new frame\n// is pushed when a frame is created, and is popped when the frame is dropped.\n//\n// Compared to the possibilities of the macros, jlrs is a bit more flexible. For example, the\n// DynamicFrame dynamically grows its associated GC frame which is not possible in the C API and\n// Outputs allow you to protect the result of a function call until the output's frame is dropped.\n// My driving assumption is that when the GC runs, it can't make any assumptions about the\n// contents of the GC stack based on earlier runs. Dynamically growing the frame does not make\n// sense in C because alloca is used but there's no technical reason preventing such a feature\n// from existing in Rust. Similarly, thanks to lifetimes we can enforce that a value can't live\n// longer than its frame while C can offer no such guarantees.\n\nuse crate::error::{AllocError, JlrsResult};\nuse crate::frame::Output;\nuse crate::value::{Value, Values};\nuse jl_sys::jl_get_ptls_states;\nuse std::ffi::c_void;\nuse std::marker::PhantomData;\nuse std::ptr::null_mut;\n\npub(crate) enum Static {}\npub(crate) enum Dynamic {}\n\n#[derive(Copy, Clone, Default)]\npub(crate) struct FrameIdx(usize);\n\npub(crate) struct RawStack(Box\u003c[*mut c_void]\u003e);\n\nimpl RawStack {\n    pub(crate) unsafe fn new(stack_size: usize) -\u003e Self {\n        debug_assert!(stack_size \u003e 0);\n        let mut raw = vec![null_mut(); stack_size];\n        raw[0] = 1 as _;\n        let boxed = raw.into_boxed_slice();\n        RawStack(boxed)\n    }\n\n    pub(crate) fn as_mut\u003c'original: 'scope, 'scope\u003e(\n        \u0026'original mut self,\n    ) -\u003e \u0026'scope mut [*mut c_void] {\n        \u0026mut self.0\n    }\n\n    pub(crate) fn size(\u0026self) -\u003e usize {\n        self.0.len()\n    }\n}\n\npub(crate) struct StackView\u003c'stack, V\u003e {\n    stack: \u0026'stack mut [*mut c_void],\n    _marker: PhantomData\u003cV\u003e,\n}\n\nimpl\u003c'stack, V\u003e StackView\u003c'stack, V\u003e {\n    pub(crate) fn size(\u0026self) -\u003e usize {\n        self.stack[0] as _\n    }\n\n    pub(crate) fn print_memory(\u0026self) {\n        println!(\"{:?}\", \u0026self.stack);\n    }\n\n    pub(crate) unsafe fn pop_frame(\u0026mut self, idx: FrameIdx) {\n        let rtls = \u0026mut *jl_get_ptls_states();\n        rtls.pgcstack = (\u0026*rtls.pgcstack).prev;\n        self.stack[0] = (idx.0 - 2) as _;\n    }\n\n    pub(crate) unsafe fn nest_static\u003c'nested\u003e(\u0026'nested mut self) -\u003e StackView\u003c'nested, Static\u003e {\n        StackView {\n            stack: self.stack,\n            _marker: PhantomData,\n        }\n    }\n\n    pub(crate) unsafe fn nest_dynamic\u003c'nested\u003e(\u0026'nested mut self) -\u003e StackView\u003c'nested, Dynamic\u003e {\n        StackView {\n            stack: self.stack,\n            _marker: PhantomData,\n        }\n    }\n\n    pub(crate) unsafe fn as_values\u003c'output\u003e(\n        \u0026mut self,\n        idx: FrameIdx,\n        offset: usize,\n        n: usize,\n    ) -\u003e Values\u003c'output\u003e {\n        let ptr = self.stack[idx.0 + offset..].as_mut_ptr();\n        Values::wrap(ptr.cast(), n)\n    }\n}\n\nimpl\u003c'stack\u003e StackView\u003c'stack, Dynamic\u003e {\n    pub(crate) unsafe fn new(stack: \u0026'stack mut [*mut c_void]) -\u003e Self {\n        StackView {\n            stack,\n            _marker: PhantomData,\n        }\n    }\n\n    pub(crate) unsafe fn new_frame(\u0026mut self) -\u003e JlrsResult\u003cFrameIdx\u003e {\n        if self.size() + 2 \u003e= self.stack.len() {\n            return Err(Box::new(\n                AllocError::StackOverflow(2, self.stack.len()).into(),\n            ));\n        }\n\n        let rtls = \u0026mut *jl_get_ptls_states();\n        self.stack[self.size()] = 0 as _;\n        self.stack[self.size() + 1] = rtls.pgcstack.cast();\n\n        let sz = self.size();\n        rtls.pgcstack = self.stack[sz + 1..].as_mut_ptr().cast();\n        let idx = FrameIdx(self.size() + 2);\n        self.stack[0] = (self.size() + 2) as _;\n\n        Ok(idx)\n    }\n\n    pub(crate) unsafe fn new_output\u003c'output\u003e(\n        \u0026mut self,\n        idx: FrameIdx,\n    ) -\u003e JlrsResult\u003cOutput\u003c'output\u003e\u003e {\n        if self.size() \u003e= self.stack.len() {\n            return Err(Box::new(\n                AllocError::StackOverflow(1, self.stack.len()).into(),\n            ));\n        }\n\n        let sz = self.size();\n        self.stack[sz] = null_mut();\n        self.stack[idx.0 - 2] = (self.stack[idx.0 - 2] as usize + 2) as _;\n        self.stack[0] = (self.size() + 1) as _;\n        Ok(Output::new(sz))\n    }\n\n    pub(crate) unsafe fn protect\u003c'output\u003e(\n        \u0026mut self,\n        idx: FrameIdx,\n        value: *mut c_void,\n    ) -\u003e Result\u003cValue\u003c'output, 'static\u003e, AllocError\u003e {\n        if self.size() == self.stack.len() {\n            return Err(AllocError::StackOverflow(1, self.stack.len()));\n        }\n\n        self.stack[self.size()] = value.cast::\u003c_\u003e();\n        self.stack[idx.0 - 2] = (self.stack[idx.0 - 2] as usize + 2) as _;\n        self.stack[0] = (self.size() + 1) as _;\n        Ok(Value::wrap(value.cast::\u003c_\u003e()))\n    }\n\n    pub(crate) unsafe fn protect_output\u003c'output\u003e(\n        \u0026mut self,\n        output: Output,\n        value: *mut c_void,\n    ) -\u003e Value\u003c'output, 'static\u003e {\n        self.stack[output.offset] = value.cast::\u003c_\u003e();\n        Value::wrap(value.cast::\u003c_\u003e())\n    }\n}\n\nimpl\u003c'stack\u003e StackView\u003c'stack, Static\u003e {\n    pub(crate) unsafe fn new(stack: \u0026'stack mut [*mut c_void]) -\u003e Self {\n        StackView {\n            stack,\n            _marker: PhantomData,\n        }\n    }\n\n    pub(crate) unsafe fn new_frame(\u0026mut self, capacity: usize) -\u003e JlrsResult\u003cFrameIdx\u003e {\n        if self.size() + capacity + 2 \u003e= self.stack.len() {\n            return Err(Box::new(\n                AllocError::StackOverflow(capacity + 2, self.stack.len()).into(),\n            ));\n        }\n\n        let rtls = \u0026mut *jl_get_ptls_states();\n        self.stack[self.size()] = (capacity \u003c\u003c 1) as _;\n        self.stack[self.size() + 1] = rtls.pgcstack.cast();\n\n        for i in 0..capacity {\n            self.stack[self.size() + 2 + i] = null_mut();\n        }\n\n        let sz = self.size();\n        rtls.pgcstack = self.stack[sz..].as_mut_ptr().cast();\n        let idx = FrameIdx(self.size() + 2);\n        self.stack[0] = (self.size() + capacity + 2) as _;\n\n        Ok(idx)\n    }\n\n    pub(crate) unsafe fn new_output\u003c'output\u003e(\n        \u0026mut self,\n        idx: FrameIdx,\n        offset: usize,\n    ) -\u003e Output\u003c'output\u003e {\n        Output::new(idx.0 + offset)\n    }\n\n    pub(crate) unsafe fn protect\u003c'output\u003e(\n        \u0026mut self,\n        idx: FrameIdx,\n        offset: usize,\n        value: *mut c_void,\n    ) -\u003e Value\u003c'output, 'static\u003e {\n        self.stack[idx.0 + offset] = value;\n        Value::wrap(value.cast())\n    }\n}\n","traces":[{"line":37,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":38,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":39,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":40,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":41,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":42,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":45,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":48,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":51,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":null,"length":0,"stats":{"Line":32},"fn_name":null},{"line":63,"address":null,"length":0,"stats":{"Line":32},"fn_name":null},{"line":66,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":null,"length":0,"stats":{"Line":32},"fn_name":null},{"line":71,"address":null,"length":0,"stats":{"Line":32},"fn_name":null},{"line":72,"address":null,"length":0,"stats":{"Line":32},"fn_name":null},{"line":73,"address":null,"length":0,"stats":{"Line":32},"fn_name":null},{"line":76,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":78,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":83,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":85,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":90,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":96,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":102,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":109,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":110,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":111,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":117,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":118,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":120,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":121,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":122,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":123,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":125,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":128,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":150,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":151,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":155,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":156,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":157,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":160,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":178,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":179,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":180,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":186,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":187,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":189,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":190,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":193,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":194,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":195,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":196,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":198,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":201,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":206,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":209,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":215,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":216,"address":null,"length":0,"stats":{"Line":22},"fn_name":null}],"covered":68,"coverable":77},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","traits.rs"],"content":"//! All traits used by this crate.\n//!\n//! Most of these traits are intended for internal use only and you should never manually\n//! implement them for your own types nor call any of their trait methods directly.\n//!\n//! The one major exception is the [`Frame`] trait. This trait is implemented by the two frame\n//! types that are provided, [`StaticFrame`] and [`DynamicFrame`] which are used to ensure the\n//! garbage collector doesn't drop the data that's used from Rust. It provides the common\n//! functionality these frame types offer.\n//!\n//! Two of the traits in this module are available as custom derive traits, [`JuliaStruct`] and\n//! [`IntoJulia`], which can be used to map a struct between Julia and Rust. Deriving the first\n//! will implement [`JuliaType`], [`JuliaTypecheck`], [`ValidLayout`], and [`Cast`], which will let you\n//! safely access the raw contents of a value; [`IntoJulia`] can be derived for bits types and lets\n//! you create new instances of that type using [`Value::new`]. While it's possible to manually\n//! implement and annotate these mapping structs, you should use `JlrsReflect.jl` which can\n//! generate these structs for you. If you do want to do this manually, see the documentation of\n//! [`JuliaStruct`] for instructions.\n//!\n//! [`Frame`]: trait.Frame.html\n//! [`StaticFrame`]: ../frame/struct.StaticFrame.html\n//! [`DynamicFrame`]: ../frame/struct.DynamicFrame.html\n//! [`Value::new`]: ../value/struct.Value.html#method.new\n//! [`Value::cast`]: ../value/struct.Value.html#method.cast\n//! [`JuliaStruct`]: trait.JuliaStruct.html\n//! [`JuliaType`]: trait.JuliaType.html\n//! [`Cast`]: trait.Cast.html\n//! [`ValidLayout`]: trait.ValidLayout.html\n//! [`IntoJulia`]: trait.IntoJulia.html\n//! [`JuliaTypecheck`]: trait.JuliaTypecheck.html\n//! [`Value::is`]: ../value/struct.Value.html#method.is\n//! [`DataType::is`]: ../value/datatype/struct.DataType.html#method.is\n\nuse crate::error::{AllocError, JlrsError, JlrsResult};\nuse crate::frame::{DynamicFrame, NullFrame, Output, StaticFrame};\nuse crate::value::datatype::DataType;\nuse crate::value::string::JuliaString;\nuse crate::value::symbol::Symbol;\nuse crate::value::Value;\nuse jl_sys::{\n    jl_bool_type, jl_box_bool, jl_box_char, jl_box_float32, jl_box_float64, jl_box_int16,\n    jl_box_int32, jl_box_int64, jl_box_int8, jl_box_uint16, jl_box_uint32, jl_box_uint64,\n    jl_box_uint8, jl_box_voidpointer, jl_char_type, jl_datatype_t, jl_float32_type,\n    jl_float64_type, jl_int16_type, jl_int32_type, jl_int64_type, jl_int8_type, jl_pchar_to_string,\n    jl_string_data, jl_string_len, jl_uint16_type, jl_uint32_type, jl_uint64_type, jl_uint8_type,\n    jl_unbox_float32, jl_unbox_float64, jl_unbox_int16, jl_unbox_int32, jl_unbox_int64,\n    jl_unbox_int8, jl_unbox_uint16, jl_unbox_uint32, jl_unbox_uint64, jl_unbox_uint8,\n    jl_unbox_voidpointer, jl_value_t, jl_voidpointer_type,\n};\nuse std::borrow::Cow;\nuse std::ffi::c_void;\n\nmacro_rules! p {\n    ($trait:ident, $type:ty, $($bounds:tt)+) =\u003e {\n        unsafe impl\u003c$($bounds)+\u003e $trait for $type {}\n    };\n    ($trait:ident, $type:ty) =\u003e {\n        unsafe impl $trait for $type {}\n    };\n}\n\n/// Trait implemented by types that can be converted to a temporary [`Symbol`].\n///\n/// [`Symbol`]: ../value/symbol/struct.Symbol.html\npub unsafe trait TemporarySymbol: private::TemporarySymbol {}\n\n/// Trait implemented as part of `JuliaStruct` that is used to verify this type has the same\n/// layout as the Julia value.\npub unsafe trait ValidLayout {\n    #[doc(hidden)]\n    // NB: the type is passed as a value to account for DataTypes, UnionAlls and Unions.\n    unsafe fn valid_layout(ty: Value) -\u003e bool;\n}\n\n/// Trait implemented by the aligning structs, which ensure bits unions are properly aligned.\n/// Used in combination with `BitsUnion` and `Flag` to ensure bits unions are inserted correctly.\npub unsafe trait Align {\n    /// The alignment in bytes\n    const ALIGNMENT: usize;\n}\n\n/// Trait implemented by structs that can contain a bits union.\n/// Used in combination with `Align` and `Flag` to ensure bits unions are inserted correctly.\npub unsafe trait BitsUnion {}\n\n/// Trait implemented by structs that can contain the flag of a bits union.\n/// Used in combination with `Align` and `BitsUnion` to ensure bits unions are inserted correctly.\npub unsafe trait Flag {}\n\nunsafe impl Flag for u8 {}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! impl_valid_layout {\n    ($type:ty, $($lt:lifetime),+) =\u003e {\n        unsafe impl\u003c$($lt),+\u003e $crate::traits::ValidLayout for $type {\n            unsafe fn valid_layout(v: $crate::value::Value) -\u003e bool {\n                if let Ok(dt) =  v.cast::\u003c$crate::value::datatype::DataType\u003e() {\n                    dt.is::\u003c$type\u003e()\n                } else {\n                    false\n                }\n            }\n        }\n    };\n    ($t:ty) =\u003e {\n        unsafe impl $crate::traits::ValidLayout for $t {\n            unsafe fn valid_layout(v: $crate::value::Value) -\u003e bool {\n                if let Ok(dt) =  v.cast::\u003c$crate::value::datatype::DataType\u003e() {\n                    dt.is::\u003c$t\u003e()\n                } else {\n                    false\n                }\n            }\n        }\n    }\n}\n\n/// Trait implemented by types that can be converted to a Julia value in combination with\n/// [`Value::new`]. This trait can be derived for custom bits types that implement\n/// `JuliaStruct`.\n///\n/// [`Value::new`]: ../value/struct.Value.html#method.new\npub unsafe trait IntoJulia {\n    #[doc(hidden)]\n    unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t;\n}\n\n/// Trait implemented by types that have an associated type in Julia.\npub unsafe trait JuliaType {\n    #[doc(hidden)]\n    unsafe fn julia_type() -\u003e *mut jl_datatype_t;\n}\n\n/// This trait can be derived in order to provide a mapping between a type in Julia and one in\n/// Rust. When this trait is derived, the following traits are implemented:\n///\n/// - [`JuliaType`]\n/// - [`JuliaTypecheck`]\n/// - [`ValidLayout`]\n/// - [`Cast`]\n///\n/// With these traits implemented you can use [`Value::cast`] with this custom type.\n///\n/// Rather than manually implement the appropriate structs, you should use `JlrsReflect.jl` to\n/// generate them for you.  If you do choose to implement this trait manually, the following rules\n/// apply.\n///\n/// First, the struct must be annotated with `#[repr(C)]` to ensure the compiler won't change the\n/// layout. Second, the struct must be annotated with `#[jlrs(julia_type = \"Path.To.Type\")]` where\n/// the path provides the full name of the type, eg the path for a struct named`Bar` in the module\n/// `Foo` which is a submodule of `Main` is `Main.Foo.Bar`. When this type is used, it must be\n/// available at that location. This path must not contain any type parameters.\n///\n/// Struct have fields and these fields have types. The type can belong to one of the following\n/// classes:\n///  - DataType\n///  - UnionAll\n///  - Union\n///  - TypeVar\n///\n/// If the field type is a DataType the field will either be allocated inline or stored as a\n/// `Value`. If it's allocated inline, a valid binding for that field must be used. In some cases,\n/// for example a field that contains a `Module`, that type can be used as a specialized type.\n/// Many of the types defined in the submodules of `value` can be used this way.\n///\n/// Special care must be taken if the field type is a tuple type. Unlike other types, tuples are\n/// covariant in the parameters. This means that a tuple like `Tuple{Int32, Int64}` is a subtype\n/// of `Tuple{Int32, Real}`. As a result, a tuple type can only be instantiated if all of its\n/// fields are concrete types. If the field type is a concrete tuple type, it is stored inline and\n/// can be represented by the appropriate type from the `tuple` module, otherwise it will not be\n/// stored inline and a `Value` must be used instead.\n///\n/// `UnionAll`s are straightforward, they're never allocated inline and must always be mapped to a\n/// `Value`.\n///\n/// Similar to tuples, unions can have two representation depending on the type parameters. If all\n/// types are pointer-free, the bits union optimization will apply. Otherwise it is stored as a\n/// `Value`.\n///\n/// The bits union optimization is not straightforward to map to Rust. In fact, three fields are\n/// required. Unlike normal structs the size of a bits union field doesn't have to be an integer\n/// multiple of its alignment; it will have the alignment of the variant with the largest alignment\n/// and is as large as the largest possible variant. Additionally, there will be another `u8` that\n/// is used as a flag to indicate the active variant.\n///\n/// The first field is the correct zero-sized `Align#`-type defined in the `union` module. The\n/// second a `BitsUnion` from that same module, its type parameter must be an array of\n/// `MaybeUninit\u003cu8\u003e`s with the appropriate numbber of elements. Finally, a `u8` must be used as\n/// a flag. In order for the derive macro to handle these fields correctly, they must be annotated\n/// with `#[jlrs(bits_union_align)]`, `#[jlrs(bits_union)]`, and `#[jlrs(bits_union_flag)]`\n/// respectively.\n///\n/// Finally, a `TypeVar` field will be mapped to a type parameter in Rust. A parameter that\n/// doesn't affect the layout must be elided. The type parameter must implement both `ValidLayout`\n/// and `Copy`.\n///\n/// [`JuliaType`]: trait.JuliaType.html\n/// [`JuliaTypecheck`]: trait.JuliaTypecheck.html\n/// [`ValidLayout`]: trait.ValidLayout.html\n/// [`Cast`]: trait.Cast.html\n/// [`Value::cast`]: ../value/struct.Value.html#method.cast\npub unsafe trait JuliaStruct: Copy {}\n\n/// This trait is used in combination with [`Value::is`] and [`DataType::is`]; types that\n/// implement this trait can be used to check many properties of a Julia `DataType`.\n///\n/// This trait is implemented for a few types that implement [`JuliaType ], eg `String`,\n/// [`Array`], and `u8`. In these cases, if the check returns `true` the value can be successfully\n/// cast to that type with [`Value::cast`].\n///\n/// [`DataType::is`]: ../value/datatype/struct.DataType.html#method.is\n/// [`Value::is`]: ../value/struct.Value.html#method.is\n/// [`JuliaType`]: trait.JuliaType.html\n/// [`Array`]: ../value/array/struct.Array.html\n/// [`Value::cast`]: ../value/struct.Value.html#method.cast\npub unsafe trait JuliaTypecheck {\n    #[doc(hidden)]\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool;\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! impl_julia_typecheck {\n    ($type:ty, $jl_type:expr, $($lt:lifetime),+) =\u003e {\n        unsafe impl\u003c$($lt),+\u003e crate::traits::JuliaTypecheck for $type {\n            unsafe fn julia_typecheck(t: $crate::value::datatype::DataType) -\u003e bool {\n                t.ptr() == $jl_type\n            }\n        }\n    };\n    ($type:ty, $jl_type:expr) =\u003e {\n        unsafe impl crate::traits::JuliaTypecheck for $type {\n            unsafe fn julia_typecheck(t: $crate::value::datatype::DataType) -\u003e bool {\n                t.ptr() == $jl_type\n            }\n        }\n    };\n    ($type:ty) =\u003e {\n        unsafe impl crate::traits::JuliaTypecheck for $type {\n            unsafe fn julia_typecheck(t: crate::value::datatype::DataType) -\u003e bool {\n                t.ptr() == \u003c$type as $crate::traits::JuliaType\u003e::julia_type()\n            }\n        }\n    };\n}\n\nimpl_julia_typecheck!(i8);\nimpl_julia_typecheck!(i16);\nimpl_julia_typecheck!(i32);\nimpl_julia_typecheck!(i64);\nimpl_julia_typecheck!(isize);\nimpl_julia_typecheck!(u8);\nimpl_julia_typecheck!(u16);\nimpl_julia_typecheck!(u32);\nimpl_julia_typecheck!(u64);\nimpl_julia_typecheck!(usize);\nimpl_julia_typecheck!(f32);\nimpl_julia_typecheck!(f64);\nimpl_julia_typecheck!(bool);\nimpl_julia_typecheck!(char);\nimpl_julia_typecheck!(*mut c_void);\n\n/// This trait is implemented by types that a [`Value`] can be converted into by calling\n/// [`Value::cast`]. This includes types like `String`, [`Array`], and `u8`.\n///\n/// [`Value`]: ../value/struct.Value.html\n/// [`Value::cast`]: ../value/struct.Value.html#method.cast\n/// [`Array`]: ../value/array/struct.Array.html\npub unsafe trait Cast\u003c'frame, 'data\u003e {\n    type Output;\n    #[doc(hidden)]\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e;\n\n    #[doc(hidden)]\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output;\n}\n\n/// Functionality shared by [`StaticFrame`] and [`DynamicFrame`]. These structs let you protect\n/// data from garbage collection. The lifetime of a frame is assigned to the values and outputs\n/// that are created using that frame. After a frame is dropped, these items are no longer\n/// protected and cannot be used.\n///\n/// If you need the result of a function call to be valid outside the frame where it is called,\n/// you can call `Frame::output` to create an [`Output`] and use [`Value::with_output`] to use the\n/// output to protect the value rather than the current frame. The result will share the output's\n/// lifetime so it can be used until the output's frame goes out of scope.\n///\n/// [`StaticFrame`]: ../frame/struct.StaticFrame.html\n/// [`DynamicFrame`]: ../frame/struct.DynamicFrame.html\n/// [`Module`]: ../module/struct.Module.html\n/// [`Julia::frame`]: ../struct.Julia.html#method.frame\n/// [`Julia::dynamic_frame`]: ../struct.Julia.html#method.dynamic_frame\n/// [`Output`]: ../frame/struct.Output.html\n/// [`Value::with_output`]: ../value/struct.Value.html#method.with_output\npub trait Frame\u003c'frame\u003e: private::Frame\u003c'frame\u003e {\n    /// Create a `StaticFrame` that can hold `capacity` values, and call the given closure.\n    /// Returns the result of this closure, or an error if the new frame can't be created\n    /// because there's not enough space on the GC stack. The number of required slots on the\n    /// stack is `capacity + 2`.\n    ///\n    /// Returns an error if there is not enough space on the stack.\n    fn frame\u003c'nested, T, F: FnOnce(\u0026mut StaticFrame\u003c'nested\u003e) -\u003e JlrsResult\u003cT\u003e\u003e(\n        \u0026'nested mut self,\n        capacity: usize,\n        func: F,\n    ) -\u003e JlrsResult\u003cT\u003e;\n\n    /// Create a `DynamicFrame` and call the given closure.  Returns the result of this closure,\n    /// or an error if the new frame can't be created because the stack is too small. The number\n    /// of required slots on the stack is `2`.\n    ///\n    /// Returns an error if there is not enough space on the stack.\n    fn dynamic_frame\u003c'nested, T, F: FnOnce(\u0026mut DynamicFrame\u003c'nested\u003e) -\u003e JlrsResult\u003cT\u003e\u003e(\n        \u0026'nested mut self,\n        func: F,\n    ) -\u003e JlrsResult\u003cT\u003e;\n\n    /// Returns a new `Output`, this takes one slot on the GC stack. A function that uses this\n    /// output will not use a slot on the GC stack, but the one associated with this output. This\n    /// extends the lifetime of that value to be valid until the frame that created the output\n    /// goes out of scope.\n    ///\n    /// Returns an error if there is not enough space on the stack.\n    fn output(\u0026mut self) -\u003e JlrsResult\u003cOutput\u003c'frame\u003e\u003e;\n\n    /// Returns the number of values belonging to this frame.\n    fn size(\u0026self) -\u003e usize;\n\n    #[doc(hidden)]\n    // Exists for debugging purposes, prints the contents of the GC stack.\n    fn print_memory(\u0026self);\n}\n\np!(TemporarySymbol, String);\np!(TemporarySymbol, \u0026dyn AsRef\u003cstr\u003e);\np!(TemporarySymbol, \u0026'a str, 'a);\np!(TemporarySymbol, Cow\u003c'a, str\u003e, 'a);\np!(TemporarySymbol, Symbol\u003c's\u003e, 's);\np!(TemporarySymbol, JuliaString\u003c'frame\u003e, 'frame);\n\nimpl_valid_layout!(bool);\nimpl_valid_layout!(char);\nimpl_valid_layout!(i8);\nimpl_valid_layout!(i16);\nimpl_valid_layout!(i32);\nimpl_valid_layout!(i64);\nimpl_valid_layout!(isize);\nimpl_valid_layout!(u8);\nimpl_valid_layout!(u16);\nimpl_valid_layout!(u32);\nimpl_valid_layout!(u64);\nimpl_valid_layout!(usize);\nimpl_valid_layout!(f32);\nimpl_valid_layout!(f64);\n\nmacro_rules! impl_into_julia {\n    ($type:ty, $boxer:ident) =\u003e {\n        unsafe impl IntoJulia for $type {\n            unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n                $boxer(*self)\n            }\n        }\n    };\n    ($type:ty, $as:ty, $boxer:ident) =\u003e {\n        unsafe impl IntoJulia for $type {\n            unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n                $boxer(*self as $as)\n            }\n        }\n    };\n}\n\nimpl_into_julia!(bool, i8, jl_box_bool);\nimpl_into_julia!(char, u32, jl_box_char);\nimpl_into_julia!(u8, jl_box_uint8);\nimpl_into_julia!(u16, jl_box_uint16);\nimpl_into_julia!(u32, jl_box_uint32);\nimpl_into_julia!(u64, jl_box_uint64);\nimpl_into_julia!(i8, jl_box_int8);\nimpl_into_julia!(i16, jl_box_int16);\nimpl_into_julia!(i32, jl_box_int32);\nimpl_into_julia!(i64, jl_box_int64);\nimpl_into_julia!(f32, jl_box_float32);\nimpl_into_julia!(f64, jl_box_float64);\nimpl_into_julia!(*mut c_void, jl_box_voidpointer);\n\n#[cfg(not(target_pointer_width = \"64\"))]\nunsafe impl IntoJulia for usize {\n    unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n        jl_box_uint32(*self as u32)\n    }\n}\n\n#[cfg(target_pointer_width = \"64\")]\nunsafe impl IntoJulia for usize {\n    unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n        jl_box_uint64(*self as u64)\n    }\n}\n\n#[cfg(not(target_pointer_width = \"64\"))]\nunsafe impl IntoJulia for isize {\n    unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n        jl_box_int32(*self as i32)\n    }\n}\n\n#[cfg(target_pointer_width = \"64\")]\nunsafe impl IntoJulia for isize {\n    unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n        jl_box_int64(*self as i64)\n    }\n}\n\nunsafe impl\u003c'a\u003e IntoJulia for \u0026'a str {\n    unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n        let ptr = self.as_ptr().cast();\n        let len = self.len();\n        jl_pchar_to_string(ptr, len)\n    }\n}\n\nunsafe impl\u003c'a\u003e IntoJulia for Cow\u003c'a, str\u003e {\n    unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n        let ptr = self.as_ptr().cast();\n        let len = self.len();\n        jl_pchar_to_string(ptr, len)\n    }\n}\n\nunsafe impl IntoJulia for String {\n    unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n        let ptr = self.as_ptr().cast();\n        let len = self.len();\n        jl_pchar_to_string(ptr, len)\n    }\n}\n\nunsafe impl IntoJulia for \u0026dyn AsRef\u003cstr\u003e {\n    unsafe fn into_julia(\u0026self) -\u003e *mut jl_value_t {\n        let ptr = self.as_ref().as_ptr().cast();\n        let len = self.as_ref().len();\n        jl_pchar_to_string(ptr, len)\n    }\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! impl_julia_type {\n    ($type:ty, $jl_type:expr) =\u003e {\n        unsafe impl crate::traits::JuliaType for $type {\n            unsafe fn julia_type() -\u003e *mut ::jl_sys::jl_datatype_t {\n                $jl_type\n            }\n        }\n    };\n    ($type:ty, $jl_type:expr, $($bounds:tt)+) =\u003e {\n        unsafe impl\u003c$($bounds)+\u003e crate::traits::JuliaType for $type {\n            unsafe fn julia_type() -\u003e *mut ::jl_sys::jl_datatype_t {\n                $jl_type\n            }\n        }\n    };\n}\n\nimpl_julia_type!(u8, jl_uint8_type);\nimpl_julia_type!(u16, jl_uint16_type);\nimpl_julia_type!(u32, jl_uint32_type);\nimpl_julia_type!(u64, jl_uint64_type);\nimpl_julia_type!(i8, jl_int8_type);\nimpl_julia_type!(i16, jl_int16_type);\nimpl_julia_type!(i32, jl_int32_type);\nimpl_julia_type!(i64, jl_int64_type);\nimpl_julia_type!(f32, jl_float32_type);\nimpl_julia_type!(f64, jl_float64_type);\nimpl_julia_type!(bool, jl_bool_type);\nimpl_julia_type!(char, jl_char_type);\nimpl_julia_type!(*mut c_void, jl_voidpointer_type);\n\n#[cfg(not(target_pointer_width = \"64\"))]\nunsafe impl JuliaType for usize {\n    unsafe fn julia_type() -\u003e *mut jl_datatype_t {\n        jl_uint32_type\n    }\n}\n\n#[cfg(target_pointer_width = \"64\")]\nunsafe impl JuliaType for usize {\n    unsafe fn julia_type() -\u003e *mut jl_datatype_t {\n        jl_uint64_type\n    }\n}\n\n#[cfg(not(target_pointer_width = \"64\"))]\nunsafe impl JuliaType for isize {\n    unsafe fn julia_type() -\u003e *mut jl_datatype_t {\n        jl_int32_type\n    }\n}\n\n#[cfg(target_pointer_width = \"64\")]\nunsafe impl JuliaType for isize {\n    unsafe fn julia_type() -\u003e *mut jl_datatype_t {\n        jl_int64_type\n    }\n}\n\nmacro_rules! impl_primitive_cast {\n    ($type:ty, $unboxer:ident) =\u003e {\n        unsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for $type {\n            type Output = Self;\n\n            fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n                if value.is::\u003c$type\u003e() {\n                    return unsafe { Ok(Self::cast_unchecked(value)) };\n                }\n\n                Err(JlrsError::WrongType)?\n            }\n\n            unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n                $unboxer(value.ptr().cast()) as _\n            }\n        }\n    };\n}\n\nimpl_primitive_cast!(u8, jl_unbox_uint8);\nimpl_primitive_cast!(u16, jl_unbox_uint16);\nimpl_primitive_cast!(u32, jl_unbox_uint32);\nimpl_primitive_cast!(u64, jl_unbox_uint64);\nimpl_primitive_cast!(i8, jl_unbox_int8);\nimpl_primitive_cast!(i16, jl_unbox_int16);\nimpl_primitive_cast!(i32, jl_unbox_int32);\nimpl_primitive_cast!(i64, jl_unbox_int64);\nimpl_primitive_cast!(f32, jl_unbox_float32);\nimpl_primitive_cast!(f64, jl_unbox_float64);\nimpl_primitive_cast!(*mut c_void, jl_unbox_voidpointer);\n\n#[cfg(not(target_pointer_width = \"64\"))]\nimpl_primitive_cast!(usize, jl_unbox_uint32);\n\n#[cfg(not(target_pointer_width = \"64\"))]\nimpl_primitive_cast!(isize, jl_unbox_int32);\n\n#[cfg(target_pointer_width = \"64\")]\nimpl_primitive_cast!(usize, jl_unbox_uint64);\n\n#[cfg(target_pointer_width = \"64\")]\nimpl_primitive_cast!(isize, jl_unbox_int64);\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for bool {\n    type Output = Self;\n\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cbool\u003e() {\n            unsafe { return Ok(Self::cast_unchecked(value)) }\n        }\n\n        Err(JlrsError::WrongType)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        jl_unbox_int8(value.ptr()) != 0\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for char {\n    type Output = Self;\n\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cchar\u003e() {\n            unsafe {\n                return std::char::from_u32(jl_unbox_uint32(value.ptr()))\n                    .ok_or(JlrsError::InvalidCharacter.into());\n            }\n        }\n\n        Err(JlrsError::WrongType)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        std::char::from_u32_unchecked(jl_unbox_uint32(value.ptr()))\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for String {\n    type Output = Self;\n\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cString\u003e() {\n            unsafe {\n                let len = jl_string_len(value.ptr());\n\n                if len == 0 {\n                    return Ok(String::new());\n                }\n\n                // Is neither null nor dangling, we've just checked\n                let raw = jl_string_data(value.ptr());\n                let raw_slice = std::slice::from_raw_parts(raw, len);\n                return Ok(String::from_utf8(raw_slice.into()).map_err(JlrsError::other)?);\n            }\n        }\n\n        Err(JlrsError::WrongType)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        let len = jl_string_len(value.ptr());\n\n        if len == 0 {\n            return String::new();\n        }\n\n        // Is neither null nor dangling, we've just checked\n        let raw = jl_string_data(value.ptr());\n        let raw_slice = std::slice::from_raw_parts(raw, len);\n        let owned_slice = Vec::from(raw_slice);\n        String::from_utf8_unchecked(owned_slice)\n    }\n}\n\nimpl\u003c'frame\u003e Frame\u003c'frame\u003e for StaticFrame\u003c'frame\u003e {\n    fn frame\u003c'nested, T, F: FnOnce(\u0026mut StaticFrame\u003c'nested\u003e) -\u003e JlrsResult\u003cT\u003e\u003e(\n        \u0026'nested mut self,\n        capacity: usize,\n        func: F,\n    ) -\u003e JlrsResult\u003cT\u003e {\n        let mut frame = unsafe { self.nested_frame(capacity).unwrap() };\n        func(\u0026mut frame)\n    }\n\n    fn dynamic_frame\u003c'nested, T, F: FnOnce(\u0026mut DynamicFrame\u003c'nested\u003e) -\u003e JlrsResult\u003cT\u003e\u003e(\n        \u0026'nested mut self,\n        func: F,\n    ) -\u003e JlrsResult\u003cT\u003e {\n        unsafe {\n            let mut view = self.memory.nest_dynamic();\n            let idx = view.new_frame()?;\n            let mut frame = DynamicFrame {\n                idx,\n                len: 0,\n                memory: view,\n            };\n\n            func(\u0026mut frame)\n        }\n    }\n\n    fn output(\u0026mut self) -\u003e JlrsResult\u003cOutput\u003c'frame\u003e\u003e {\n        if self.capacity == self.len {\n            return Err(AllocError::FrameOverflow(1, self.len).into());\n        }\n\n        let out = unsafe {\n            let out = self.memory.new_output(self.idx, self.len);\n            self.len += 1;\n            out\n        };\n\n        Ok(out)\n    }\n\n    fn size(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    fn print_memory(\u0026self) {\n        self.memory.print_memory()\n    }\n}\n\nimpl\u003c'frame\u003e Frame\u003c'frame\u003e for DynamicFrame\u003c'frame\u003e {\n    fn dynamic_frame\u003c'nested, T, F: FnOnce(\u0026mut DynamicFrame\u003c'nested\u003e) -\u003e JlrsResult\u003cT\u003e\u003e(\n        \u0026'nested mut self,\n        func: F,\n    ) -\u003e JlrsResult\u003cT\u003e {\n        let mut frame = unsafe { self.nested_frame().unwrap() };\n        func(\u0026mut frame)\n    }\n\n    fn frame\u003c'nested, T, F: FnOnce(\u0026mut StaticFrame\u003c'nested\u003e) -\u003e JlrsResult\u003cT\u003e\u003e(\n        \u0026'nested mut self,\n        capacity: usize,\n        func: F,\n    ) -\u003e JlrsResult\u003cT\u003e {\n        unsafe {\n            let mut view = self.memory.nest_static();\n            let idx = view.new_frame(capacity)?;\n            let mut frame = StaticFrame {\n                idx,\n                capacity,\n                len: 0,\n                memory: view,\n            };\n\n            func(\u0026mut frame)\n        }\n    }\n\n    fn output(\u0026mut self) -\u003e JlrsResult\u003cOutput\u003c'frame\u003e\u003e {\n        unsafe {\n            let out = self.memory.new_output(self.idx)?;\n            self.len += 1;\n            Ok(out)\n        }\n    }\n\n    fn size(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    fn print_memory(\u0026self) {\n        self.memory.print_memory()\n    }\n}\n\nimpl\u003c'frame\u003e Frame\u003c'frame\u003e for NullFrame\u003c'frame\u003e {\n    fn frame\u003c'nested, T, F: FnOnce(\u0026mut StaticFrame\u003c'nested\u003e) -\u003e JlrsResult\u003cT\u003e\u003e(\n        \u0026'nested mut self,\n        _: usize,\n        _: F,\n    ) -\u003e JlrsResult\u003cT\u003e {\n        Err(JlrsError::NullFrame)?\n    }\n\n    fn dynamic_frame\u003c'nested, T, F: FnOnce(\u0026mut DynamicFrame\u003c'nested\u003e) -\u003e JlrsResult\u003cT\u003e\u003e(\n        \u0026'nested mut self,\n        _: F,\n    ) -\u003e JlrsResult\u003cT\u003e {\n        Err(JlrsError::NullFrame)?\n    }\n\n    fn output(\u0026mut self) -\u003e JlrsResult\u003cOutput\u003c'frame\u003e\u003e {\n        Err(JlrsError::NullFrame)?\n    }\n\n    fn size(\u0026self) -\u003e usize {\n        0\n    }\n\n    fn print_memory(\u0026self) {}\n}\n\npub(crate) mod private {\n    use crate::error::AllocError;\n    use crate::frame::{DynamicFrame, NullFrame, Output, StaticFrame};\n    use crate::stack::FrameIdx;\n    use crate::value::string::JuliaString;\n    use crate::value::symbol::Symbol;\n    use crate::value::{Value, Values};\n    use jl_sys::jl_value_t;\n    use jl_sys::{jl_symbol, jl_symbol_n};\n    use std::borrow::Cow;\n\n    // If a trait A is used in a trait bound, the trait methods from traits that A extends become\n    // available without explicitly using those base traits. By taking this struct, which can only\n    // be created inside this crate, as an argument, these methods can only be called from this\n    // crate.\n    pub struct Internal;\n\n    // safety: never return the symbol to the user without assigning the 'base lifetime.\n    pub trait TemporarySymbol {\n        unsafe fn temporary_symbol\u003c'symbol\u003e(\u0026self, _: Internal) -\u003e Symbol\u003c'symbol\u003e;\n    }\n\n    pub trait Frame\u003c'frame\u003e {\n        // protect the value from being garbage collected while this frame is active.\n        // safety: the value must be a valid Julia value\n        unsafe fn protect(\n            \u0026mut self,\n            value: *mut jl_value_t,\n            _: Internal,\n        ) -\u003e Result\u003cValue\u003c'frame, 'static\u003e, AllocError\u003e;\n\n        // Create and protect multiple values from being garbage collected while this frame is active.\n        fn create_many\u003cP: super::IntoJulia\u003e(\n            \u0026mut self,\n            values: \u0026[P],\n            _: Internal,\n        ) -\u003e Result\u003cValues\u003c'frame\u003e, AllocError\u003e;\n\n        // Create and protect multiple values from being garbage collected while this frame is active.\n        fn create_many_dyn(\n            \u0026mut self,\n            values: \u0026[\u0026dyn super::IntoJulia],\n            _: Internal,\n        ) -\u003e Result\u003cValues\u003c'frame\u003e, AllocError\u003e;\n\n        // Protect a value from being garbage collected while the output's frame is active.\n        fn assign_output\u003c'output\u003e(\n            \u0026mut self,\n            output: Output\u003c'output\u003e,\n            value: *mut jl_value_t,\n            _: Internal,\n        ) -\u003e Value\u003c'output, 'static\u003e;\n    }\n\n    impl\u003c'a\u003e TemporarySymbol for \u0026'a str {\n        unsafe fn temporary_symbol\u003c'symbol\u003e(\u0026self, _: Internal) -\u003e Symbol\u003c'symbol\u003e {\n            let symbol_ptr = self.as_ptr();\n            let symbol = jl_symbol_n(symbol_ptr.cast(), self.len());\n            Symbol::wrap(symbol)\n        }\n    }\n\n    impl\u003c'a\u003e TemporarySymbol for Cow\u003c'a, str\u003e {\n        unsafe fn temporary_symbol\u003c'symbol\u003e(\u0026self, _: Internal) -\u003e Symbol\u003c'symbol\u003e {\n            let symbol_ptr = self.as_ptr().cast();\n            let symbol = jl_symbol_n(symbol_ptr, self.len());\n            Symbol::wrap(symbol)\n        }\n    }\n\n    impl TemporarySymbol for String {\n        unsafe fn temporary_symbol\u003c'symbol\u003e(\u0026self, _: Internal) -\u003e Symbol\u003c'symbol\u003e {\n            let symbol_ptr = self.as_ptr().cast();\n            let symbol = jl_symbol_n(symbol_ptr, self.len());\n            Symbol::wrap(symbol)\n        }\n    }\n\n    impl TemporarySymbol for \u0026dyn AsRef\u003cstr\u003e {\n        unsafe fn temporary_symbol\u003c'symbol\u003e(\u0026self, _: Internal) -\u003e Symbol\u003c'symbol\u003e {\n            let symbol_ptr = self.as_ref().as_ptr().cast();\n            let symbol = jl_symbol_n(symbol_ptr, self.as_ref().len());\n            Symbol::wrap(symbol)\n        }\n    }\n\n    impl\u003c'frame\u003e TemporarySymbol for JuliaString\u003c'frame\u003e {\n        unsafe fn temporary_symbol\u003c'symbol\u003e(\u0026self, _: Internal) -\u003e Symbol\u003c'symbol\u003e {\n            let symbol_ptr = self.as_c_str();\n            let symbol = jl_symbol(symbol_ptr.as_ptr());\n            Symbol::wrap(symbol)\n        }\n    }\n\n    impl\u003c's\u003e TemporarySymbol for Symbol\u003c's\u003e {\n        unsafe fn temporary_symbol\u003c'symbol\u003e(\u0026self, _: Internal) -\u003e Symbol\u003c'symbol\u003e {\n            Symbol::wrap(self.ptr())\n        }\n    }\n\n    impl\u003c'frame\u003e Frame\u003c'frame\u003e for StaticFrame\u003c'frame\u003e {\n        unsafe fn protect(\n            \u0026mut self,\n            value: *mut jl_value_t,\n            _: Internal,\n        ) -\u003e Result\u003cValue\u003c'frame, 'static\u003e, AllocError\u003e {\n            if self.capacity == self.len {\n                return Err(AllocError::FrameOverflow(1, self.len));\n            }\n\n            let out = {\n                let out = self.memory.protect(self.idx, self.len, value.cast());\n                self.len += 1;\n                out\n            };\n\n            Ok(out)\n        }\n\n        fn create_many\u003cP: super::IntoJulia\u003e(\n            \u0026mut self,\n            values: \u0026[P],\n            _: Internal,\n        ) -\u003e Result\u003cValues\u003c'frame\u003e, AllocError\u003e {\n            unsafe {\n                if self.capacity \u003c self.len + values.len() {\n                    return Err(AllocError::FrameOverflow(values.len(), self.capacity()));\n                }\n\n                let offset = self.len;\n                for value in values {\n                    self.memory\n                        .protect(self.idx, self.len, value.into_julia().cast());\n                    self.len += 1;\n                }\n\n                Ok(self.memory.as_values(self.idx, offset, values.len()))\n            }\n        }\n\n        fn create_many_dyn(\n            \u0026mut self,\n            values: \u0026[\u0026dyn super::IntoJulia],\n            _: Internal,\n        ) -\u003e Result\u003cValues\u003c'frame\u003e, AllocError\u003e {\n            unsafe {\n                if self.capacity \u003c self.len + values.len() {\n                    return Err(AllocError::FrameOverflow(values.len(), self.capacity()));\n                }\n\n                let offset = self.len;\n                for value in values {\n                    self.memory\n                        .protect(self.idx, self.len, value.into_julia().cast());\n                    self.len += 1;\n                }\n\n                Ok(self.memory.as_values(self.idx, offset, values.len()))\n            }\n        }\n\n        fn assign_output\u003c'output\u003e(\n            \u0026mut self,\n            output: Output\u003c'output\u003e,\n            value: *mut jl_value_t,\n            _: Internal,\n        ) -\u003e Value\u003c'output, 'static\u003e {\n            unsafe {\n                self.memory\n                    .protect(FrameIdx::default(), output.offset, value.cast())\n            }\n        }\n    }\n\n    impl\u003c'frame\u003e Frame\u003c'frame\u003e for DynamicFrame\u003c'frame\u003e {\n        unsafe fn protect(\n            \u0026mut self,\n            value: *mut jl_value_t,\n            _: Internal,\n        ) -\u003e Result\u003cValue\u003c'frame, 'static\u003e, AllocError\u003e {\n            let out = self.memory.protect(self.idx, value.cast())?;\n            self.len += 1;\n            Ok(out)\n        }\n\n        fn create_many\u003cP: super::IntoJulia\u003e(\n            \u0026mut self,\n            values: \u0026[P],\n            _: Internal,\n        ) -\u003e Result\u003cValues\u003c'frame\u003e, AllocError\u003e {\n            unsafe {\n                let offset = self.len;\n                // TODO: check capacity\n\n                for value in values {\n                    match self.memory.protect(self.idx, value.into_julia().cast()) {\n                        Ok(_) =\u003e (),\n                        Err(AllocError::StackOverflow(_, n)) =\u003e {\n                            return Err(AllocError::StackOverflow(values.len(), n))\n                        }\n                        _ =\u003e unreachable!(),\n                    }\n                    self.len += 1;\n                }\n\n                Ok(self.memory.as_values(self.idx, offset, values.len()))\n            }\n        }\n\n        fn create_many_dyn(\n            \u0026mut self,\n            values: \u0026[\u0026dyn super::IntoJulia],\n            _: Internal,\n        ) -\u003e Result\u003cValues\u003c'frame\u003e, AllocError\u003e {\n            unsafe {\n                let offset = self.len;\n                // TODO: check capacity in advance\n\n                for value in values {\n                    self.memory.protect(self.idx, value.into_julia().cast())?;\n                    self.len += 1;\n                }\n\n                Ok(self.memory.as_values(self.idx, offset, values.len()))\n            }\n        }\n\n        fn assign_output\u003c'output\u003e(\n            \u0026mut self,\n            output: Output\u003c'output\u003e,\n            value: *mut jl_value_t,\n            _: Internal,\n        ) -\u003e Value\u003c'output, 'static\u003e {\n            unsafe { self.memory.protect_output(output, value.cast()) }\n        }\n    }\n\n    impl\u003c'frame\u003e Frame\u003c'frame\u003e for NullFrame\u003c'frame\u003e {\n        unsafe fn protect(\n            \u0026mut self,\n            _: *mut jl_value_t,\n            _: Internal,\n        ) -\u003e Result\u003cValue\u003c'frame, 'static\u003e, AllocError\u003e {\n            Err(AllocError::FrameOverflow(1, 0))\n        }\n\n        fn create_many\u003cP: super::IntoJulia\u003e(\n            \u0026mut self,\n            values: \u0026[P],\n            _: Internal,\n        ) -\u003e Result\u003cValues\u003c'frame\u003e, AllocError\u003e {\n            Err(AllocError::FrameOverflow(values.len(), 0))\n        }\n\n        fn create_many_dyn(\n            \u0026mut self,\n            values: \u0026[\u0026dyn super::IntoJulia],\n            _: Internal,\n        ) -\u003e Result\u003cValues\u003c'frame\u003e, AllocError\u003e {\n            Err(AllocError::FrameOverflow(values.len(), 0))\n        }\n\n        fn assign_output\u003c'output\u003e(\n            \u0026mut self,\n            _: Output\u003c'output\u003e,\n            _: *mut jl_value_t,\n            _: Internal,\n        ) -\u003e Value\u003c'output, 'static\u003e {\n            unreachable!()\n        }\n    }\n}\n","traces":[{"line":97,"address":4216560,"length":1,"stats":{"Line":3},"fn_name":"valid_layout"},{"line":98,"address":4216569,"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":4216623,"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":4216606,"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":4364304,"length":1,"stats":{"Line":80},"fn_name":"valid_layout"},{"line":109,"address":4364313,"length":1,"stats":{"Line":80},"fn_name":null},{"line":110,"address":4364367,"length":1,"stats":{"Line":80},"fn_name":null},{"line":112,"address":4364350,"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":4216496,"length":1,"stats":{"Line":34},"fn_name":"julia_typecheck"},{"line":228,"address":4216505,"length":1,"stats":{"Line":34},"fn_name":null},{"line":234,"address":4227584,"length":1,"stats":{"Line":10},"fn_name":"julia_typecheck"},{"line":235,"address":4227593,"length":1,"stats":{"Line":10},"fn_name":null},{"line":241,"address":4302224,"length":1,"stats":{"Line":118},"fn_name":"julia_typecheck"},{"line":242,"address":4302233,"length":1,"stats":{"Line":118},"fn_name":null},{"line":360,"address":4302288,"length":1,"stats":{"Line":32},"fn_name":"into_julia"},{"line":361,"address":4302297,"length":1,"stats":{"Line":32},"fn_name":null},{"line":367,"address":4366320,"length":1,"stats":{"Line":4},"fn_name":"into_julia"},{"line":368,"address":4366329,"length":1,"stats":{"Line":4},"fn_name":null},{"line":390,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":398,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":404,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":412,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":417,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":419,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":420,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":426,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":427,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":428,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":433,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":434,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":436,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":441,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":4302336,"length":1,"stats":{"Line":112},"fn_name":"julia_type"},{"line":460,"address":4216544,"length":1,"stats":{"Line":0},"fn_name":"julia_type"},{"line":467,"address":4366855,"length":1,"stats":{"Line":9},"fn_name":null},{"line":468,"address":4366871,"length":1,"stats":{"Line":9},"fn_name":null},{"line":469,"address":4366887,"length":1,"stats":{"Line":11},"fn_name":null},{"line":470,"address":4366903,"length":1,"stats":{"Line":11},"fn_name":null},{"line":471,"address":4366919,"length":1,"stats":{"Line":8},"fn_name":null},{"line":472,"address":4366935,"length":1,"stats":{"Line":8},"fn_name":null},{"line":473,"address":4366951,"length":1,"stats":{"Line":9},"fn_name":null},{"line":474,"address":4366967,"length":1,"stats":{"Line":9},"fn_name":null},{"line":475,"address":4366983,"length":1,"stats":{"Line":12},"fn_name":null},{"line":476,"address":4366999,"length":1,"stats":{"Line":13},"fn_name":null},{"line":477,"address":4367015,"length":1,"stats":{"Line":7},"fn_name":null},{"line":478,"address":4367031,"length":1,"stats":{"Line":5},"fn_name":null},{"line":479,"address":4302343,"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":491,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":497,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":505,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":514,"address":4302352,"length":1,"stats":{"Line":38},"fn_name":"cast"},{"line":515,"address":4302372,"length":1,"stats":{"Line":38},"fn_name":null},{"line":516,"address":4302484,"length":1,"stats":{"Line":38},"fn_name":null},{"line":519,"address":4302391,"length":1,"stats":{"Line":10},"fn_name":null},{"line":522,"address":4302880,"length":1,"stats":{"Line":38},"fn_name":"cast_unchecked"},{"line":523,"address":4302889,"length":1,"stats":{"Line":38},"fn_name":null},{"line":556,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":557,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":558,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":561,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":564,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":565,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":572,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":573,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":575,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":576,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":580,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":583,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":592,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":594,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":596,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":597,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":601,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":602,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":603,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":607,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":null,"length":0,"stats":{"Line":63},"fn_name":null},{"line":631,"address":null,"length":0,"stats":{"Line":63},"fn_name":null},{"line":632,"address":null,"length":0,"stats":{"Line":63},"fn_name":null},{"line":635,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":640,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":641,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":642,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":643,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":648,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":652,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":653,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":654,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":659,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":660,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":663,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":666,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":680,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":681,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":684,"address":null,"length":0,"stats":{"Line":16},"fn_name":null},{"line":690,"address":null,"length":0,"stats":{"Line":16},"fn_name":null},{"line":691,"address":null,"length":0,"stats":{"Line":16},"fn_name":null},{"line":692,"address":null,"length":0,"stats":{"Line":16},"fn_name":null},{"line":693,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":null,"length":0,"stats":{"Line":16},"fn_name":null},{"line":699,"address":null,"length":0,"stats":{"Line":16},"fn_name":null},{"line":703,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":705,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":706,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":707,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":711,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":712,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":716,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":726,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":736,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":740,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":744,"address":4290096,"length":1,"stats":{"Line":0},"fn_name":"print_memory"},{"line":802,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":803,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":804,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":805,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":810,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":811,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":812,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":813,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":818,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":819,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":820,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":821,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":826,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":827,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":828,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":829,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":834,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":835,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":843,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":848,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":853,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":854,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":857,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":858,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":859,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":860,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":863,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":866,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":872,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":873,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":876,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":877,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":878,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":879,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":880,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":883,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":887,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":893,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":894,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":897,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":898,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":899,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":900,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":901,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":904,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":908,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":915,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":916,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":922,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":927,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":928,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":929,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":932,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":938,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":941,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":942,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":943,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":944,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":945,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":949,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":952,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":956,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":962,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":965,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":966,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":967,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":970,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":974,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":980,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":985,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":998,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":null,"length":0,"stats":{"Line":0},"fn_name":null}],"covered":167,"coverable":231},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","util.rs"],"content":"// This module exists for testing purposes, the thread-local instance ensures Julia is only\n// initialized once.\n\nuse crate::prelude::*;\nuse std::cell::RefCell;\n\nthread_local! {\n    #[doc(hidden)]\n    pub static JULIA: RefCell\u003cJulia\u003e = {\n        use std::env;\n        let dir = env::var(\"JLRS_ROOT\").expect(\"You must set the JLRS_ROOT environement variable to the root of the repository (the directory that contains jlrs, jlrs_derive, etc) in order to run the tests.\");\n        let r = RefCell::new(unsafe { Julia::init(32).unwrap() });\n        r.borrow_mut().include(format!(\"{}/jlrs.jl\", dir)).unwrap();\n        r.borrow_mut().include(format!(\"{}/jlrs/tests/julia/JlrsTests.jl\", dir)).unwrap();\n        r\n    };\n}\n","traces":[{"line":11,"address":4284721,"length":1,"stats":{"Line":20},"fn_name":null},{"line":12,"address":4284853,"length":1,"stats":{"Line":20},"fn_name":null},{"line":13,"address":4284949,"length":1,"stats":{"Line":20},"fn_name":null},{"line":14,"address":4285310,"length":1,"stats":{"Line":20},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","array.rs"],"content":"//! Support for n-dimensional arrays and their dimensions.\n//!\n//! You will find several structs in this module that can be used to work with Julia arrays from\n//! Rust. An [`Array`] is the Julia array itself, and provides methods to (mutably) access the\n//! data and copy it to Rust. Accessing array data from Rust when the type of the elements is a\n//! union of bits types is not supported, use `Base.getindex` instead.\n//!\n//! The structs that represent copied or borrowed data can be accessed using an n-dimensional\n//! index written as a tuple. For example, if `a` is a three-dimensional array, a single element\n//! can be accessed with `a[(row, col, z)]`.\n//!\n//! [`Array`]: struct.Array.html\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::{Cast, Frame, JuliaTypecheck, ValidLayout};\nuse crate::value::datatype::DataType;\nuse crate::value::Value;\nuse jl_sys::{\n    jl_array_data, jl_array_dim, jl_array_dims, jl_array_eltype, jl_array_ndims, jl_array_nrows,\n    jl_array_ptr_set, jl_array_t, jl_is_array_type, jl_tparam0, jl_typeof,\n};\nuse std::fmt::{Debug, Display, Formatter, Result as FmtResult};\nuse std::marker::PhantomData;\nuse std::ops::{Index, IndexMut};\n\n/// An n-dimensional Julia array. This struct implements [`JuliaTypecheck`] and [`Cast`]. It can\n/// be used in combination with [`DataType::is`] and [`Value::is`]; if the check returns `true`\n/// the [`Value`] can be cast to `Array`:\n///\n/// ```\n/// # use jlrs::prelude::*;\n/// # use jlrs::util::JULIA;\n/// # fn main() {\n/// # JULIA.with(|j| {\n/// # let mut julia = j.borrow_mut();\n/// julia.frame(1, |_global, frame| {\n///     let arr = Value::new_array::\u003cf64, _, _\u003e(frame, (3, 3))?;\n///     assert!(arr.is::\u003cArray\u003e());\n///     assert!(arr.cast::\u003cArray\u003e().is_ok());\n///     Ok(())\n/// }).unwrap();\n/// # });\n/// # }\n/// ```\n///\n/// Each element in the backing storage is either stored as a [`Value`] or inline. You can check\n/// how the data is stored by calling [`Array::is_value_array`] or [`Array::is_inline_array`].\n/// Note that this is not necessarily consistent across different versions of Julia; the array\n/// might be value array in Julia 1.0, but an inline array in Julia 1.5. If you want to ensure the\n/// data is not stored inline, you should use a mutable struct as the element type. If the data is\n/// stored inline, you will need to provide a type with the appropriate layout, the easiest way to\n/// create these for types that are not available in jlrs is to use `JlrsReflect.jl`.\n///\n/// Arrays that contain integers or floats are an example of inline arrays. Their data is stored\n/// as an array that contains numbers of the appropriate type, for example an array of `Float32`s\n/// in Julia is backed by an an array of `f32`s. The data of these arrays can be accessed with\n/// [`Array::inline_data`] and [`Array::inline_data_mut`], and copied from Julia to Rust with\n/// [`Array::copy_inline_data`]. In order to call these methods the type of the elements must be\n/// provided, arrays that contain numbers can be accessed by providing the appropriate Rust type\n/// (eg `f32` for `Float32` and `u64` for `UInt64`).\n///\n/// If the data isn't inlined each element is stored as a [`Value`]. This data can be accessed\n/// using [`Array::value_data`] and [`Array::value_data_mut`] but this is unsafe.\n///\n/// [`JuliaTypecheck`]: ../../traits/trait.JuliaTypecheck.html\n/// [`Cast`]: ../../traits/trait.Cast.html\n/// [`DataType::is`]: ../datatype/struct.DataType.html#method.is\n/// [`Value::is`]: ../struct.Value.html#method.is\n/// [`Value`]: ../struct.Value.html\n/// [`Value::cast`]: ../struct.Value.html#method.cast\n/// [`Array::is_value_array`]: struct.Array.html#method.is_value_array\n/// [`Array::is_inline_array`]: struct.Array.html#method.is_inline_array\n/// [`Array::inline_data`]: struct.Array.html#method.inline_data\n/// [`Array::inline_data_mut`]: struct.Array.html#method.inline_data_mut\n/// [`Array::copy_inline_data`]: struct.Array.html#method.copy_inline_data\n/// [`JuliaTuple`]: ../../traits/trait.JuliaTuple.html\n/// [`JuliaStruct`]: ../../traits/trait.JuliaStruct.html\n/// [`Array::value_data`]: struct.Array.html#method.value_data\n/// [`Array::value_data_mut`]: struct.Array.html#method.value_data_mut\n#[derive(Copy, Clone, Debug)]\n#[repr(transparent)]\npub struct Array\u003c'frame, 'data\u003e(\n    *mut jl_array_t,\n    PhantomData\u003c\u0026'frame ()\u003e,\n    PhantomData\u003c\u0026'data ()\u003e,\n);\n\nimpl\u003c'frame, 'data\u003e Array\u003c'frame, 'data\u003e {\n    pub(crate) unsafe fn wrap(array: *mut jl_array_t) -\u003e Self {\n        Array(array, PhantomData, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_array_t {\n        self.0\n    }\n\n    /// Convert this untyped array into a `TypedArray`.\n    pub fn into_typed_array\u003cT\u003e(self) -\u003e JlrsResult\u003cTypedArray\u003c'frame, 'data, T\u003e\u003e\n    where\n        T: Copy + ValidLayout,\n    {\n        if self.contains::\u003cT\u003e() {\n            unsafe { Ok(TypedArray::wrap(self.ptr())) }\n        } else {\n            Err(JlrsError::WrongType)?\n        }\n    }\n\n    /// Returns the array's dimensions.\n    pub fn dimensions(self) -\u003e Dimensions {\n        unsafe { Dimensions::from_array(self.ptr().cast()) }\n    }\n\n    /// Returns the type of this array's elements.\n    pub fn element_type(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(jl_array_eltype(self.ptr().cast()).cast()) }\n    }\n\n    /// Returns `true` if the type of the elements of this array is `T`.\n    pub fn contains\u003cT: ValidLayout\u003e(self) -\u003e bool {\n        unsafe { T::valid_layout(Value::wrap(jl_array_eltype(self.ptr().cast()).cast())) }\n    }\n\n    /// Returns `true` if the type of the elements of this array is `T` and these elements are\n    /// stored inline.\n    pub fn contains_inline\u003cT: ValidLayout\u003e(self) -\u003e bool {\n        self.contains::\u003cT\u003e() \u0026\u0026 self.is_inline_array()\n    }\n\n    /// Returns true if the elements of the array are stored inline.\n    pub fn is_inline_array(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).flags.ptrarray() == 0 }\n    }\n\n    /// Returns true if the elements of the array are stored inline and at least one of the field\n    /// of the inlined type is a pointer.\n    pub fn has_inlined_pointers(self) -\u003e bool {\n        unsafe {\n            let flags = (\u0026*self.ptr()).flags;\n            self.is_inline_array() \u0026\u0026 flags.hasptr() != 0\n        }\n    }\n\n    /// Returns true if the elements of the array are stored as [`Value`]s.\n    pub fn is_value_array(self) -\u003e bool {\n        !self.is_inline_array()\n    }\n\n    /// Copy the data of an inline array to Rust. Returns `JlrsError::NotInline` if the data is\n    /// not stored inline or `JlrsError::WrongType` if the type of the elements is incorrect.\n    pub fn copy_inline_data\u003cT\u003e(self) -\u003e JlrsResult\u003cCopiedArray\u003cT\u003e\u003e\n    where\n        T: ValidLayout,\n    {\n        if !self.contains::\u003cT\u003e() {\n            Err(JlrsError::WrongType)?;\n        }\n\n        if !self.is_inline_array() {\n            Err(JlrsError::NotInline)?;\n        }\n\n        unsafe {\n            let jl_data = jl_array_data(self.ptr().cast()).cast();\n            let dimensions = Dimensions::from_array(self.ptr().cast());\n\n            let sz = dimensions.size();\n            let mut data = Vec::with_capacity(sz);\n            let ptr = data.as_mut_ptr();\n            std::ptr::copy_nonoverlapping(jl_data, ptr, sz);\n            data.set_len(sz);\n\n            Ok(CopiedArray::new(data, dimensions))\n        }\n    }\n\n    /// Immutably borrow inline array data, you can borrow data from multiple arrays at the same\n    /// time. Returns `JlrsError::NotInline` if the data is not stored inline or\n    /// `JlrsError::WrongType` if the type of the elements is incorrect.\n    pub fn inline_data\u003c'borrow, 'fr, T, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cArrayData\u003c'borrow, 'fr, T, F\u003e\u003e\n    where\n        T: ValidLayout,\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.contains::\u003cT\u003e() {\n            Err(JlrsError::WrongType)?;\n        }\n\n        if !self.is_inline_array() {\n            Err(JlrsError::NotInline)?;\n        }\n\n        unsafe {\n            let jl_data = jl_array_data(self.ptr().cast()).cast();\n            let dimensions = Dimensions::from_array(self.ptr().cast());\n            let data = std::slice::from_raw_parts(jl_data, dimensions.size());\n            Ok(ArrayData::new(data, dimensions, frame))\n        }\n    }\n\n    /// Mutably borrow inline array data, you can mutably borrow a single array at the same time.\n    /// Returns `JlrsError::NotInline` if the data is not stored inline or `JlrsError::WrongType`\n    /// if the type of the elements is incorrect.\n    pub fn inline_data_mut\u003c'borrow, 'fr, T, F\u003e(\n        self,\n        frame: \u0026'borrow mut F,\n    ) -\u003e JlrsResult\u003cInlineArrayDataMut\u003c'borrow, 'fr, T, F\u003e\u003e\n    where\n        T: ValidLayout,\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.contains::\u003cT\u003e() {\n            Err(JlrsError::WrongType)?;\n        }\n\n        if !self.is_inline_array() {\n            Err(JlrsError::NotInline)?;\n        }\n\n        unsafe {\n            let jl_data = jl_array_data(self.ptr().cast()).cast();\n            let dimensions = Dimensions::from_array(self.ptr().cast());\n            let data = std::slice::from_raw_parts_mut(jl_data, dimensions.size());\n            Ok(InlineArrayDataMut::new(data, dimensions, frame))\n        }\n    }\n\n    /// Mutably borrow inline array data without the restriction that only a single array can be\n    /// mutably borrowed. It's your responsibility to ensure you don't create multiple mutable\n    /// references to the same array data.\n    ///\n    /// Returns `JlrsError::NotInline` if the data is not stored inline or `JlrsError::WrongType`\n    /// if the type of the elements is incorrect.\n    pub unsafe fn unrestricted_inline_data_mut\u003c'borrow, 'fr, T, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cUnrestrictedInlineArrayDataMut\u003c'borrow, 'fr, T, F\u003e\u003e\n    where\n        T: ValidLayout,\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.contains::\u003cT\u003e() {\n            Err(JlrsError::WrongType)?;\n        }\n\n        if !self.is_inline_array() {\n            Err(JlrsError::NotInline)?;\n        }\n\n        let jl_data = jl_array_data(self.ptr().cast()).cast();\n        let dimensions = Dimensions::from_array(self.ptr().cast());\n        let data = std::slice::from_raw_parts_mut(jl_data, dimensions.size());\n        Ok(UnrestrictedInlineArrayDataMut::new(data, dimensions, frame))\n    }\n\n    /// Immutably borrow the data of this value array, you can borrow data from multiple arrays at\n    /// the same time. The values themselves can be mutable, but you can't replace an element with\n    /// another value. Returns `JlrsError::Inline` if the data is stored inline.\n    ///\n    /// Safety: no slot on the GC stack is required to access and use the values in this array,\n    /// the GC is aware of the array's data. If the element is changed either from Rust or Julia,\n    /// the original value is no longer protected from garbage collection. If you need to keep\n    /// using this value you must protect it by calling [`Value::extend`].\n    ///\n    /// [`Value::extend`]: ../struct.Value.html#method.extend\n    pub unsafe fn value_data\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cArrayData\u003c'borrow, 'fr, Value\u003c'frame, 'data\u003e, F\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.is_value_array() {\n            Err(JlrsError::Inline)?;\n        }\n\n        let jl_data = jl_array_data(self.ptr().cast()).cast();\n        let dimensions = Dimensions::from_array(self.ptr().cast());\n        let data = std::slice::from_raw_parts(jl_data, dimensions.size());\n        Ok(ArrayData::new(data, dimensions, frame))\n    }\n\n    /// Mutably borrow the data of this value array, you can mutably borrow a single array at the\n    /// same time. Returns `JlrsError::Inline` if the data is stored inline.\n    ///\n    /// Safety: no slot on the GC stack is required to access and use the values in this array,\n    /// the GC is aware of the array's data. If the element is changed either from Rust or Julia,\n    /// the original value is no longer protected from garbage collection. If you need to keep\n    /// using this value you must protect it by calling [`Value::extend`].\n    ///\n    /// [`Value::extend`]: ../struct.Value.html#method.extend\n    pub unsafe fn value_data_mut\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026'borrow mut F,\n    ) -\u003e JlrsResult\u003cValueArrayDataMut\u003c'borrow, 'frame, 'data, 'fr, F\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.is_value_array() {\n            Err(JlrsError::Inline)?;\n        }\n\n        let jl_data = jl_array_data(self.ptr().cast()).cast();\n        let dimensions = Dimensions::from_array(self.ptr().cast());\n        let data = std::slice::from_raw_parts_mut(jl_data, dimensions.size());\n        Ok(ValueArrayDataMut::new(self, data, dimensions, frame))\n    }\n\n    /// Mutably borrow the data of this value array without the restriction that only a single\n    /// array can be mutably borrowed. It's your responsibility to ensure you don't create\n    /// multiple mutable references to the same array data. Returns `JlrsError::Inline` if the\n    /// data is stored inline.\n    ///\n    /// Safety: no slot on the GC stack is required to access and use the values in this array,\n    /// the GC is aware of the array's data. If the element is changed either from Rust or Julia,\n    /// the original value is no longer protected from garbage collection. If you need to keep\n    /// using this value you must protect it by calling [`Value::extend`].\n    ///\n    /// [`Value::extend`]: ../struct.Value.html#method.extend\n    pub unsafe fn unrestricted_value_data_mut\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cUnrestrictedValueArrayDataMut\u003c'borrow, 'frame, 'data, 'fr, F\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.is_value_array() {\n            Err(JlrsError::Inline)?;\n        }\n\n        let jl_data = jl_array_data(self.ptr().cast()).cast();\n        let dimensions = Dimensions::from_array(self.ptr().cast());\n        let data = std::slice::from_raw_parts_mut(jl_data, dimensions.size());\n        Ok(UnrestrictedValueArrayDataMut::new(\n            self, data, dimensions, frame,\n        ))\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e JuliaTypecheck for Array\u003c'frame, 'data\u003e {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        jl_is_array_type(t.ptr().cast())\n    }\n}\n\nimpl\u003c'frame, 'data\u003e Into\u003cValue\u003c'frame, 'data\u003e\u003e for Array\u003c'frame, 'data\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'data\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for Array\u003c'frame, 'data\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAnArray)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e ValidLayout for Array\u003c'frame, 'data\u003e {\n    unsafe fn valid_layout(v: Value) -\u003e bool {\n        if let Ok(dt) = v.cast::\u003cDataType\u003e() {\n            dt.is::\u003cArray\u003e()\n        } else if let Ok(ua) = v.cast::\u003csuper::union_all::UnionAll\u003e() {\n            ua.base_type().is::\u003cArray\u003e()\n        } else {\n            false\n        }\n    }\n}\n\n/// Exactly the same as [`Array`], except it has an explicit element type `T`.\n///\n/// [`Array`]: struct.Array.html\n#[derive(Copy, Clone, Debug)]\n#[repr(transparent)]\npub struct TypedArray\u003c'frame, 'data, T\u003e(\n    *mut jl_array_t,\n    PhantomData\u003c\u0026'frame ()\u003e,\n    PhantomData\u003c\u0026'data ()\u003e,\n    PhantomData\u003cT\u003e,\n)\nwhere\n    T: Copy + ValidLayout;\n\nimpl\u003c'frame, 'data, T: Copy + ValidLayout\u003e TypedArray\u003c'frame, 'data, T\u003e {\n    pub(crate) unsafe fn wrap(array: *mut jl_array_t) -\u003e Self {\n        assert!(T::valid_layout(Value::wrap(\n            jl_array_eltype(array.cast()).cast()\n        )));\n        TypedArray(array, PhantomData, PhantomData, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_array_t {\n        self.0\n    }\n\n    /// Returns the array's dimensions.\n    pub fn dimensions(self) -\u003e Dimensions {\n        unsafe { Dimensions::from_array(self.ptr().cast()) }\n    }\n\n    /// Returns the type of this array's elements.\n    pub fn element_type(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(jl_array_eltype(self.ptr().cast()).cast()) }\n    }\n\n    /// Returns true if the elements of the array are stored inline.\n    pub fn is_inline_array(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).flags.ptrarray() == 0 }\n    }\n\n    /// Returns true if the elements of the array are stored inline and at least one of the field\n    /// of the inlined type is a pointer.\n    pub fn has_inlined_pointers(self) -\u003e bool {\n        unsafe {\n            let flags = (\u0026*self.ptr()).flags;\n            self.is_inline_array() \u0026\u0026 flags.hasptr() != 0\n        }\n    }\n\n    /// Returns true if the elements of the array are stored as [`Value`]s.\n    pub fn is_value_array(self) -\u003e bool {\n        !self.is_inline_array()\n    }\n\n    /// Copy the data of an inline array to Rust. Returns `JlrsError::NotInline` if the data is\n    /// not stored inline or `JlrsError::WrongType` if the type of the elements is incorrect.\n    pub fn copy_inline_data(self) -\u003e JlrsResult\u003cCopiedArray\u003cT\u003e\u003e {\n        if !self.is_inline_array() {\n            Err(JlrsError::NotInline)?;\n        }\n\n        unsafe {\n            let jl_data = jl_array_data(self.ptr().cast()).cast();\n            let dimensions = Dimensions::from_array(self.ptr().cast());\n\n            let sz = dimensions.size();\n            let mut data = Vec::with_capacity(sz);\n            let ptr = data.as_mut_ptr();\n            std::ptr::copy_nonoverlapping(jl_data, ptr, sz);\n            data.set_len(sz);\n\n            Ok(CopiedArray::new(data, dimensions))\n        }\n    }\n\n    /// Immutably borrow inline array data, you can borrow data from multiple arrays at the same\n    /// time. Returns `JlrsError::NotInline` if the data is not stored inline or\n    /// `JlrsError::WrongType` if the type of the elements is incorrect.\n    pub fn inline_data\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cArrayData\u003c'borrow, 'fr, T, F\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.is_inline_array() {\n            Err(JlrsError::NotInline)?;\n        }\n\n        unsafe {\n            let jl_data = jl_array_data(self.ptr().cast()).cast();\n            let dimensions = Dimensions::from_array(self.ptr().cast());\n            let data = std::slice::from_raw_parts(jl_data, dimensions.size());\n            Ok(ArrayData::new(data, dimensions, frame))\n        }\n    }\n\n    /// Mutably borrow inline array data, you can mutably borrow a single array at the same time.\n    /// Returns `JlrsError::NotInline` if the data is not stored inline or `JlrsError::WrongType`\n    /// if the type of the elements is incorrect.\n    pub fn inline_data_mut\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026'borrow mut F,\n    ) -\u003e JlrsResult\u003cInlineArrayDataMut\u003c'borrow, 'fr, T, F\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.is_inline_array() {\n            Err(JlrsError::NotInline)?;\n        }\n\n        unsafe {\n            let jl_data = jl_array_data(self.ptr().cast()).cast();\n            let dimensions = Dimensions::from_array(self.ptr().cast());\n            let data = std::slice::from_raw_parts_mut(jl_data, dimensions.size());\n            Ok(InlineArrayDataMut::new(data, dimensions, frame))\n        }\n    }\n\n    /// Mutably borrow inline array data without the restriction that only a single array can be\n    /// mutably borrowed. It's your responsibility to ensure you don't create multiple mutable\n    /// references to the same array data.\n    ///\n    /// Returns `JlrsError::NotInline` if the data is not stored inline or `JlrsError::WrongType`\n    /// if the type of the elements is incorrect.\n    pub unsafe fn unrestricted_inline_data_mut\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cUnrestrictedInlineArrayDataMut\u003c'borrow, 'fr, T, F\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.is_inline_array() {\n            Err(JlrsError::NotInline)?;\n        }\n\n        let jl_data = jl_array_data(self.ptr().cast()).cast();\n        let dimensions = Dimensions::from_array(self.ptr().cast());\n        let data = std::slice::from_raw_parts_mut(jl_data, dimensions.size());\n        Ok(UnrestrictedInlineArrayDataMut::new(data, dimensions, frame))\n    }\n\n    /// Immutably borrow the data of this value array, you can borrow data from multiple arrays at\n    /// the same time. The values themselves can be mutable, but you can't replace an element with\n    /// another value. Returns `JlrsError::Inline` if the data is stored inline.\n    ///\n    /// Safety: no slot on the GC stack is required to access and use the values in this array,\n    /// the GC is aware of the array's data. If the element is changed either from Rust or Julia,\n    /// the original value is no longer protected from garbage collection. If you need to keep\n    /// using this value you must protect it by calling [`Value::extend`].\n    ///\n    /// [`Value::extend`]: ../struct.Value.html#method.extend\n    pub unsafe fn value_data\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cArrayData\u003c'borrow, 'fr, Value\u003c'frame, 'data\u003e, F\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.is_value_array() {\n            Err(JlrsError::Inline)?;\n        }\n\n        let jl_data = jl_array_data(self.ptr().cast()).cast();\n        let dimensions = Dimensions::from_array(self.ptr().cast());\n        let data = std::slice::from_raw_parts(jl_data, dimensions.size());\n        Ok(ArrayData::new(data, dimensions, frame))\n    }\n\n    /// Mutably borrow the data of this value array, you can mutably borrow a single array at the\n    /// same time. Returns `JlrsError::Inline` if the data is stored inline.\n    ///\n    /// Safety: no slot on the GC stack is required to access and use the values in this array,\n    /// the GC is aware of the array's data. If the element is changed either from Rust or Julia,\n    /// the original value is no longer protected from garbage collection. If you need to keep\n    /// using this value you must protect it by calling [`Value::extend`].\n    ///\n    /// [`Value::extend`]: ../struct.Value.html#method.extend\n    pub unsafe fn value_data_mut\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026'borrow mut F,\n    ) -\u003e JlrsResult\u003cValueArrayDataMut\u003c'borrow, 'frame, 'data, 'fr, F\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.is_value_array() {\n            Err(JlrsError::Inline)?;\n        }\n\n        let jl_data = jl_array_data(self.ptr().cast()).cast();\n        let dimensions = Dimensions::from_array(self.ptr().cast());\n        let data = std::slice::from_raw_parts_mut(jl_data, dimensions.size());\n        Ok(ValueArrayDataMut::new(self.into(), data, dimensions, frame))\n    }\n\n    /// Mutably borrow the data of this value array without the restriction that only a single\n    /// array can be mutably borrowed. It's your responsibility to ensure you don't create\n    /// multiple mutable references to the same array data. Returns `JlrsError::Inline` if the\n    /// data is stored inline.\n    ///\n    /// Safety: no slot on the GC stack is required to access and use the values in this array,\n    /// the GC is aware of the array's data. If the element is changed either from Rust or Julia,\n    /// the original value is no longer protected from garbage collection. If you need to keep\n    /// using this value you must protect it by calling [`Value::extend`].\n    ///\n    /// [`Value::extend`]: ../struct.Value.html#method.extend\n    pub unsafe fn unrestricted_value_data_mut\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cUnrestrictedValueArrayDataMut\u003c'borrow, 'frame, 'data, 'fr, F\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        if !self.is_value_array() {\n            Err(JlrsError::Inline)?;\n        }\n\n        let jl_data = jl_array_data(self.ptr().cast()).cast();\n        let dimensions = Dimensions::from_array(self.ptr().cast());\n        let data = std::slice::from_raw_parts_mut(jl_data, dimensions.size());\n        Ok(UnrestrictedValueArrayDataMut::new(\n            Array::wrap(self.ptr()),\n            data,\n            dimensions,\n            frame,\n        ))\n    }\n}\n\nunsafe impl\u003c'frame, 'data, T: Copy + ValidLayout\u003e JuliaTypecheck for TypedArray\u003c'frame, 'data, T\u003e {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        jl_is_array_type(t.ptr().cast()) \u0026\u0026 T::valid_layout(Value::wrap(jl_tparam0(t.ptr()).cast()))\n    }\n}\n\nimpl\u003c'frame, 'data, T: Copy + ValidLayout\u003e Into\u003cValue\u003c'frame, 'data\u003e\u003e\n    for TypedArray\u003c'frame, 'data, T\u003e\n{\n    fn into(self) -\u003e Value\u003c'frame, 'data\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nimpl\u003c'frame, 'data, T: Copy + ValidLayout\u003e Into\u003cArray\u003c'frame, 'data\u003e\u003e\n    for TypedArray\u003c'frame, 'data, T\u003e\n{\n    fn into(self) -\u003e Array\u003c'frame, 'data\u003e {\n        unsafe { Array::wrap(self.ptr()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data, T: Copy + ValidLayout\u003e Cast\u003c'frame, 'data\u003e\n    for TypedArray\u003c'frame, 'data, T\u003e\n{\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAnArray)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nunsafe impl\u003c'frame, 'data, T: Copy + ValidLayout\u003e ValidLayout for TypedArray\u003c'frame, 'data, T\u003e {\n    unsafe fn valid_layout(v: Value) -\u003e bool {\n        if let Ok(dt) = v.cast::\u003cDataType\u003e() {\n            dt.is::\u003cTypedArray\u003cT\u003e\u003e()\n        } else if let Ok(ua) = v.cast::\u003csuper::union_all::UnionAll\u003e() {\n            ua.base_type().is::\u003cTypedArray\u003cT\u003e\u003e()\n        } else {\n            false\n        }\n    }\n}\n\n/// An n-dimensional array whose contents have been copied from Julia to Rust. You can create this\n/// struct by calling [`Array::copy_inline_data`]. The data has a column-major order and can be\n/// indexed with anything that implements `Into\u003cDimensions\u003e`; see [`Dimensions`] for more\n/// information.\n///\n/// [`Array::copy_inline_data`]: struct.Array.html#method.copy_inline_data\n/// [`Dimensions`]: struct.Dimensions.html\n#[derive(Debug)]\npub struct CopiedArray\u003cT\u003e {\n    data: Vec\u003cT\u003e,\n    dimensions: Dimensions,\n}\n\nimpl\u003cT\u003e CopiedArray\u003cT\u003e {\n    pub(crate) fn new(data: Vec\u003cT\u003e, dimensions: Dimensions) -\u003e Self {\n        CopiedArray { data, dimensions }\n    }\n\n    /// Turn the array into a tuple containing its data in column-major order and its dimensions.\n    pub fn splat(self) -\u003e (Vec\u003cT\u003e, Dimensions) {\n        (self.data, self.dimensions)\n    }\n\n    /// Returns a reference to the element at the given n-dimensional index if the index is valid,\n    /// `None` otherwise.\n    pub fn get\u003cD: Into\u003cDimensions\u003e\u003e(\u0026self, idx: D) -\u003e Option\u003c\u0026T\u003e {\n        Some(\u0026self.data[self.dimensions.index_of(idx).ok()?])\n    }\n\n    /// Returns a mutable reference to the element at the given n-dimensional index if the index\n    /// is valid, `None` otherwise.\n    pub fn get_mut\u003cD: Into\u003cDimensions\u003e\u003e(\u0026mut self, idx: D) -\u003e Option\u003c\u0026mut T\u003e {\n        Some(\u0026mut self.data[self.dimensions.index_of(idx).ok()?])\n    }\n\n    /// Returns the array's data as a slice, the data is in column-major order.\n    pub fn as_slice(\u0026self) -\u003e \u0026[T] {\n        \u0026self.data\n    }\n\n    /// Returns the array's data as a mutable slice, the data is in column-major order.\n    pub fn as_mut_slice(\u0026mut self) -\u003e \u0026mut [T] {\n        \u0026mut self.data\n    }\n\n    /// Returns a reference to the array's dimensions.\n    pub fn dimensions(\u0026self) -\u003e \u0026Dimensions {\n        \u0026self.dimensions\n    }\n}\n\nimpl\u003cT, D: Into\u003cDimensions\u003e\u003e Index\u003cD\u003e for CopiedArray\u003cT\u003e {\n    type Output = T;\n    fn index(\u0026self, idx: D) -\u003e \u0026T {\n        \u0026self.data[self.dimensions.index_of(idx).unwrap()]\n    }\n}\n\nimpl\u003cT, D: Into\u003cDimensions\u003e\u003e IndexMut\u003cD\u003e for CopiedArray\u003cT\u003e {\n    fn index_mut(\u0026mut self, idx: D) -\u003e \u0026mut T {\n        \u0026mut self.data[self.dimensions.index_of(idx).unwrap()]\n    }\n}\n\n/// Immutably borrowed array data from Julia. The data has a column-major order and can be indexed\n/// with anything that implements `Into\u003cDimensions\u003e`; see [`Dimensions`] for more information.\n///\n/// [`Dimensions`]: struct.Dimensions.html\npub struct ArrayData\u003c'borrow, 'frame, T, F: Frame\u003c'frame\u003e\u003e {\n    data: \u0026'borrow [T],\n    dimensions: Dimensions,\n    _notsendsync: PhantomData\u003c*const ()\u003e,\n    _borrow: PhantomData\u003c\u0026'borrow F\u003e,\n    _frame: PhantomData\u003c\u0026'frame ()\u003e,\n}\n\nimpl\u003c'borrow, 'frame, T, F\u003e ArrayData\u003c'borrow, 'frame, T, F\u003e\nwhere\n    F: Frame\u003c'frame\u003e,\n{\n    pub(crate) unsafe fn new(data: \u0026'borrow [T], dimensions: Dimensions, _: \u0026'borrow F) -\u003e Self {\n        ArrayData {\n            data,\n            dimensions,\n            _notsendsync: PhantomData,\n            _borrow: PhantomData,\n            _frame: PhantomData,\n        }\n    }\n\n    /// Get a reference to the value at `index`, or `None` if the index is out of bounds.\n    pub fn get\u003cD: Into\u003cDimensions\u003e\u003e(\u0026self, index: D) -\u003e Option\u003c\u0026T\u003e {\n        Some(\u0026self.data[self.dimensions.index_of(index).ok()?])\n    }\n\n    /// Returns the array's data as a slice, the data is in column-major order.\n    pub fn as_slice(\u0026self) -\u003e \u0026[T] {\n        self.data\n    }\n\n    /// Returns the array's data as a slice, the data is in column-major order.\n    pub fn into_slice(self) -\u003e \u0026'borrow [T] {\n        self.data\n    }\n\n    /// Returns a reference to the array's dimensions.\n    pub fn dimensions(\u0026self) -\u003e \u0026Dimensions {\n        \u0026self.dimensions\n    }\n}\n\nimpl\u003c'borrow, 'frame, T, D, F\u003e Index\u003cD\u003e for ArrayData\u003c'borrow, 'frame, T, F\u003e\nwhere\n    D: Into\u003cDimensions\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    type Output = T;\n    fn index(\u0026self, index: D) -\u003e \u0026Self::Output {\n        \u0026self.data[self.dimensions.index_of(index).unwrap()]\n    }\n}\n\n/// Mutably borrowed inline array data from Julia. The data has a column-major order and can be\n/// indexed with anything that implements `Into\u003cDimensions\u003e`; see [`Dimensions`] for more\n/// information.\n///\n/// [`Dimensions`]: struct.Dimensions.html\npub struct InlineArrayDataMut\u003c'borrow, 'frame, T, F: Frame\u003c'frame\u003e\u003e {\n    data: \u0026'borrow mut [T],\n    dimensions: Dimensions,\n    _notsendsync: PhantomData\u003c*const ()\u003e,\n    _borrow: PhantomData\u003c\u0026'borrow F\u003e,\n    _frame: PhantomData\u003c\u0026'frame ()\u003e,\n}\n\nimpl\u003c'borrow, 'frame, T, F\u003e InlineArrayDataMut\u003c'borrow, 'frame, T, F\u003e\nwhere\n    F: Frame\u003c'frame\u003e,\n{\n    pub(crate) unsafe fn new(\n        data: \u0026'borrow mut [T],\n        dimensions: Dimensions,\n        _: \u0026'borrow mut F,\n    ) -\u003e Self {\n        InlineArrayDataMut {\n            data,\n            dimensions,\n            _notsendsync: PhantomData,\n            _frame: PhantomData,\n            _borrow: PhantomData,\n        }\n    }\n\n    /// Get a reference to the value at `index`, or `None` if the index is out of bounds.\n    pub fn get\u003cD: Into\u003cDimensions\u003e\u003e(\u0026self, index: D) -\u003e Option\u003c\u0026T\u003e {\n        Some(\u0026self.data[self.dimensions.index_of(index).ok()?])\n    }\n\n    /// Get a mutable reference to the value at `index`, or `None` if the index is out of bounds.\n    pub fn get_mut\u003cD: Into\u003cDimensions\u003e\u003e(\u0026mut self, index: D) -\u003e Option\u003c\u0026mut T\u003e {\n        Some(\u0026mut self.data[self.dimensions.index_of(index).ok()?])\n    }\n\n    /// Returns the array's data as a slice, the data is in column-major order.\n    pub fn as_slice(\u0026self) -\u003e \u0026[T] {\n        self.data\n    }\n\n    /// Returns the array's data as a slice, the data is in column-major order.\n    pub fn into_slice(self) -\u003e \u0026'borrow [T] {\n        self.data\n    }\n\n    /// Returns the array's data as a mutable slice, the data is in column-major order.\n    pub fn as_mut_slice(\u0026mut self) -\u003e \u0026mut [T] {\n        self.data\n    }\n\n    /// Returns the array's data as a mutable slice, the data is in column-major order.\n    pub fn into_mut_slice(self) -\u003e \u0026'borrow mut [T] {\n        self.data\n    }\n\n    /// Returns a reference to the array's dimensions.\n    pub fn dimensions(\u0026self) -\u003e \u0026Dimensions {\n        \u0026self.dimensions\n    }\n}\n\n/// Mutably borrowed value array data from Julia. The data has a column-major order and can be\n/// indexed with anything that implements `Into\u003cDimensions\u003e`; see [`Dimensions`] for more\n/// information.\n///\n/// [`Dimensions`]: struct.Dimensions.html\nimpl\u003c'borrow, 'frame, T, D, F\u003e Index\u003cD\u003e for InlineArrayDataMut\u003c'borrow, 'frame, T, F\u003e\nwhere\n    D: Into\u003cDimensions\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    type Output = T;\n    fn index(\u0026self, index: D) -\u003e \u0026Self::Output {\n        \u0026self.data[self.dimensions.index_of(index).unwrap()]\n    }\n}\n\nimpl\u003c'borrow, 'frame, T, D, F\u003e IndexMut\u003cD\u003e for InlineArrayDataMut\u003c'borrow, 'frame, T, F\u003e\nwhere\n    D: Into\u003cDimensions\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    fn index_mut(\u0026mut self, index: D) -\u003e \u0026mut Self::Output {\n        \u0026mut self.data[self.dimensions.index_of(index).unwrap()]\n    }\n}\n\n/// Mutably borrowed inline array data from Julia. The data has a column-major order and can be\n/// indexed with anything that implements `Into\u003cDimensions\u003e`; see [`Dimensions`] for more\n/// information.\n///\n/// [`Dimensions`]: struct.Dimensions.html\npub struct UnrestrictedInlineArrayDataMut\u003c'borrow, 'frame, T, F: Frame\u003c'frame\u003e\u003e {\n    data: \u0026'borrow mut [T],\n    dimensions: Dimensions,\n    _notsendsync: PhantomData\u003c*const ()\u003e,\n    _borrow: PhantomData\u003c\u0026'borrow F\u003e,\n    _frame: PhantomData\u003c\u0026'frame ()\u003e,\n}\n\nimpl\u003c'borrow, 'frame, T, F\u003e UnrestrictedInlineArrayDataMut\u003c'borrow, 'frame, T, F\u003e\nwhere\n    F: Frame\u003c'frame\u003e,\n{\n    pub(crate) unsafe fn new(\n        data: \u0026'borrow mut [T],\n        dimensions: Dimensions,\n        _: \u0026'borrow F,\n    ) -\u003e Self {\n        UnrestrictedInlineArrayDataMut {\n            data,\n            dimensions,\n            _notsendsync: PhantomData,\n            _frame: PhantomData,\n            _borrow: PhantomData,\n        }\n    }\n\n    /// Get a reference to the value at `index`, or `None` if the index is out of bounds.\n    pub fn get\u003cD: Into\u003cDimensions\u003e\u003e(\u0026self, index: D) -\u003e Option\u003c\u0026T\u003e {\n        Some(\u0026self.data[self.dimensions.index_of(index).ok()?])\n    }\n\n    /// Get a mutable reference to the value at `index`, or `None` if the index is out of bounds.\n    pub fn get_mut\u003cD: Into\u003cDimensions\u003e\u003e(\u0026mut self, index: D) -\u003e Option\u003c\u0026mut T\u003e {\n        Some(\u0026mut self.data[self.dimensions.index_of(index).ok()?])\n    }\n\n    /// Returns the array's data as a slice, the data is in column-major order.\n    pub fn as_slice(\u0026self) -\u003e \u0026[T] {\n        \u0026self.data\n    }\n\n    /// Returns the array's data as a mutable slice, the data is in column-major order.\n    pub fn as_mut_slice(\u0026mut self) -\u003e \u0026mut [T] {\n        \u0026mut self.data\n    }\n\n    /// Returns a reference to the array's dimensions.\n    pub fn dimensions(\u0026self) -\u003e \u0026Dimensions {\n        \u0026self.dimensions\n    }\n}\n\n/// Mutably borrowed value array data from Julia. The data has a column-major order and can be\n/// indexed with anything that implements `Into\u003cDimensions\u003e`; see [`Dimensions`] for more\n/// information.\n///\n/// [`Dimensions`]: struct.Dimensions.html\nimpl\u003c'borrow, 'frame, T, D, F\u003e Index\u003cD\u003e for UnrestrictedInlineArrayDataMut\u003c'borrow, 'frame, T, F\u003e\nwhere\n    D: Into\u003cDimensions\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    type Output = T;\n    fn index(\u0026self, index: D) -\u003e \u0026Self::Output {\n        \u0026self.data[self.dimensions.index_of(index).unwrap()]\n    }\n}\n\nimpl\u003c'borrow, 'frame, T, D, F\u003e IndexMut\u003cD\u003e for UnrestrictedInlineArrayDataMut\u003c'borrow, 'frame, T, F\u003e\nwhere\n    D: Into\u003cDimensions\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    fn index_mut(\u0026mut self, index: D) -\u003e \u0026mut Self::Output {\n        \u0026mut self.data[self.dimensions.index_of(index).unwrap()]\n    }\n}\n\npub struct ValueArrayDataMut\u003c'borrow, 'value, 'data, 'frame, F: Frame\u003c'frame\u003e\u003e {\n    array: Array\u003c'value, 'data\u003e,\n    data: \u0026'borrow mut [Value\u003c'value, 'data\u003e],\n    dimensions: Dimensions,\n    _notsendsync: PhantomData\u003c*const ()\u003e,\n    _borrow: PhantomData\u003c\u0026'borrow mut F\u003e,\n    _frame: PhantomData\u003c\u0026'frame ()\u003e,\n}\n\nimpl\u003c'borrow, 'frame, 'data, 'fr, F\u003e ValueArrayDataMut\u003c'borrow, 'frame, 'data, 'fr, F\u003e\nwhere\n    F: Frame\u003c'fr\u003e,\n{\n    pub(crate) unsafe fn new(\n        array: Array\u003c'frame, 'data\u003e,\n        data: \u0026'borrow mut [Value\u003c'frame, 'data\u003e],\n        dimensions: Dimensions,\n        _: \u0026'borrow mut F,\n    ) -\u003e Self {\n        ValueArrayDataMut {\n            array,\n            data,\n            dimensions,\n            _notsendsync: PhantomData,\n            _borrow: PhantomData,\n            _frame: PhantomData,\n        }\n    }\n\n    /// Get a reference to the value at `index`, or `None` if the index is out of bounds.\n    pub fn get\u003cD: Into\u003cDimensions\u003e\u003e(\u0026self, index: D) -\u003e Option\u003c\u0026Value\u003c'frame, 'data\u003e\u003e {\n        Some(\u0026self.data[self.dimensions.index_of(index).ok()?])\n    }\n\n    pub unsafe fn set\u003c'va, 'da: 'data, D: Into\u003cDimensions\u003e\u003e(\n        \u0026mut self,\n        index: D,\n        value: Value\u003c'frame, 'da\u003e,\n    ) -\u003e JlrsResult\u003c()\u003e {\n        let ptr = self.array.ptr();\n        let eltype = jl_array_eltype(ptr.cast());\n\n        if eltype != jl_typeof(value.ptr().cast()).cast() {\n            Err(JlrsError::InvalidArrayType)?;\n        }\n\n        let idx =  self.dimensions.index_of(index)?;\n\n        jl_array_ptr_set(\n            ptr.cast(),\n            idx,\n            value.ptr().cast(),\n        );\n        Ok(())\n    }\n\n    /// Returns the array's data as a slice, the data is in column-major order.\n    pub fn as_slice(\u0026self) -\u003e \u0026[Value\u003c'frame, 'data\u003e] {\n        \u0026self.data\n    }\n\n    /// Returns a reference to the array's dimensions.\n    pub fn dimensions(\u0026self) -\u003e \u0026Dimensions {\n        \u0026self.dimensions\n    }\n}\n\nimpl\u003c'borrow, 'value, 'data, 'frame, D, F\u003e Index\u003cD\u003e\n    for ValueArrayDataMut\u003c'borrow, 'value, 'data, 'frame, F\u003e\nwhere\n    D: Into\u003cDimensions\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    type Output = Value\u003c'value, 'data\u003e;\n    fn index(\u0026self, index: D) -\u003e \u0026Self::Output {\n        \u0026self.data[self.dimensions.index_of(index).unwrap()]\n    }\n}\n\npub struct UnrestrictedValueArrayDataMut\u003c'borrow, 'value, 'data, 'frame, F: Frame\u003c'frame\u003e\u003e {\n    array: Array\u003c'value, 'data\u003e,\n    data: \u0026'borrow mut [Value\u003c'value, 'data\u003e],\n    dimensions: Dimensions,\n    _notsendsync: PhantomData\u003c*const ()\u003e,\n    _borrow: PhantomData\u003c\u0026'borrow F\u003e,\n    _frame: PhantomData\u003c\u0026'frame ()\u003e,\n}\n\nimpl\u003c'borrow, 'frame, 'data, 'fr, F\u003e UnrestrictedValueArrayDataMut\u003c'borrow, 'frame, 'data, 'fr, F\u003e\nwhere\n    F: Frame\u003c'fr\u003e,\n{\n    pub(crate) unsafe fn new(\n        array: Array\u003c'frame, 'data\u003e,\n        data: \u0026'borrow mut [Value\u003c'frame, 'data\u003e],\n        dimensions: Dimensions,\n        _: \u0026'borrow F,\n    ) -\u003e Self {\n        UnrestrictedValueArrayDataMut {\n            array,\n            data,\n            dimensions,\n            _notsendsync: PhantomData,\n            _borrow: PhantomData,\n            _frame: PhantomData,\n        }\n    }\n\n    /// Get a reference to the value at `index`, or `None` if the index is out of bounds.\n    pub fn get\u003cD: Into\u003cDimensions\u003e\u003e(\u0026self, index: D) -\u003e Option\u003c\u0026Value\u003c'frame, 'data\u003e\u003e {\n        Some(\u0026self.data[self.dimensions.index_of(index).ok()?])\n    }\n\n    pub unsafe fn set\u003c'va, 'da: 'data, D: Into\u003cDimensions\u003e\u003e(\n        \u0026mut self,\n        index: D,\n        value: Value\u003c'frame, 'da\u003e,\n    ) -\u003e JlrsResult\u003c()\u003e {\n        let ptr = self.array.ptr();\n        let eltype = jl_array_eltype(ptr.cast());\n\n        if eltype != jl_typeof(value.ptr().cast()).cast() {\n            Err(JlrsError::InvalidArrayType)?;\n        }\n\n        jl_array_ptr_set(\n            ptr.cast(),\n            self.dimensions.index_of(index)?,\n            value.ptr().cast(),\n        );\n        Ok(())\n    }\n\n    /// Returns the array's data as a slice, the data is in column-major order.\n    pub fn as_slice(\u0026self) -\u003e \u0026[Value\u003c'frame, 'data\u003e] {\n        \u0026self.data\n    }\n\n    /// Returns a reference to the array's dimensions.\n    pub fn dimensions(\u0026self) -\u003e \u0026Dimensions {\n        \u0026self.dimensions\n    }\n}\n\nimpl\u003c'borrow, 'value, 'data, 'frame, D, F\u003e Index\u003cD\u003e\n    for UnrestrictedValueArrayDataMut\u003c'borrow, 'value, 'data, 'frame, F\u003e\nwhere\n    D: Into\u003cDimensions\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    type Output = Value\u003c'value, 'data\u003e;\n    fn index(\u0026self, index: D) -\u003e \u0026Self::Output {\n        \u0026self.data[self.dimensions.index_of(index).unwrap()]\n    }\n}\n\n/// The dimensions of an n-dimensional array, they represent either the shape of an array or an\n/// index. Functions that need `Dimensions` as an input, which is currently limited to just\n/// indexing this data, are generic and accept any type that implements `Into\u003cDimensions\u003e`.\n///\n/// For a single dimension, you can use a `usize` value. For 0 up to and including 8 dimensions,\n/// you can use tuples of `usize`. In general, you can use slices of `usize`:\n///\n/// ```\n/// # use jlrs::value::array::Dimensions;\n/// # fn main() {\n/// let _0d: Dimensions = ().into();\n/// let _1d_value: Dimensions = 42.into();\n/// let _1d_tuple: Dimensions = (42,).into();\n/// let _2d: Dimensions = (42, 6).into();\n/// let _nd: Dimensions = [42, 6, 12, 3].as_ref().into();\n/// # }\n/// ```\n#[derive(Clone)]\npub enum Dimensions {\n    #[doc(hidden)]\n    Few([usize; 4]),\n    #[doc(hidden)]\n    Many(Box\u003c[usize]\u003e),\n}\n\nimpl Dimensions {\n    pub(crate) unsafe fn from_array(array: *mut jl_array_t) -\u003e Self {\n        let n_dims = jl_array_ndims(array);\n        match n_dims {\n            0 =\u003e Into::into(()),\n            1 =\u003e Into::into(jl_array_nrows(array) as usize),\n            2 =\u003e Into::into((jl_array_dim(array, 0), jl_array_dim(array, 1))),\n            3 =\u003e Into::into((\n                jl_array_dim(array, 0),\n                jl_array_dim(array, 1),\n                jl_array_dim(array, 2),\n            )),\n            ndims =\u003e Into::into(jl_array_dims(array, ndims as _)),\n        }\n    }\n\n    /// Returns the number of dimensions.\n    pub fn n_dimensions(\u0026self) -\u003e usize {\n        match self {\n            Dimensions::Few([n, _, _, _]) =\u003e *n,\n            Dimensions::Many(ref dims) =\u003e dims[0],\n        }\n    }\n\n    /// Returns the number of elements of the nth dimension. Indexing starts at 0.\n    pub fn n_elements(\u0026self, dimension: usize) -\u003e usize {\n        if self.n_dimensions() == 0 \u0026\u0026 dimension == 0 {\n            return 0;\n        }\n\n        assert!(dimension \u003c self.n_dimensions());\n\n        let dims = match self {\n            Dimensions::Few(ref dims) =\u003e dims,\n            Dimensions::Many(ref dims) =\u003e dims.as_ref(),\n        };\n\n        dims[dimension as usize + 1]\n    }\n\n    /// The product of the number of elements of each dimension.\n    pub fn size(\u0026self) -\u003e usize {\n        if self.n_dimensions() == 0 {\n            return 0;\n        }\n\n        let dims = match self {\n            Dimensions::Few(ref dims) =\u003e \u0026dims[1..dims[0] as usize + 1],\n            Dimensions::Many(ref dims) =\u003e \u0026dims[1..dims[0] as usize + 1],\n        };\n        dims.iter().product()\n    }\n\n    /// Calculates the linear index of `dim_index` corresponding to a multidimensional array of\n    /// shape `self`. Returns an error if the index is not valid for this shape.\n    pub fn index_of\u003cD: Into\u003cDimensions\u003e\u003e(\u0026self, dim_index: D) -\u003e JlrsResult\u003cusize\u003e {\n        let dim_index = dim_index.into();\n        self.check_bounds(\u0026dim_index)?;\n\n        let idx = match self.n_dimensions() {\n            0 =\u003e 0,\n            _ =\u003e {\n                let mut d_it = dim_index.as_slice().iter().rev();\n                let acc = d_it.next().unwrap();\n\n                d_it.zip(self.as_slice().iter().rev().skip(1))\n                    .fold(*acc, |acc, (dim, sz)| dim + sz * acc)\n            }\n        };\n\n        Ok(idx)\n    }\n\n    /// Returns the raw dimensions as a slice.\n    pub fn as_slice(\u0026self) -\u003e \u0026[usize] {\n        match self {\n            Dimensions::Few(ref v) =\u003e \u0026v[1..v[0] as usize + 1],\n            Dimensions::Many(ref v) =\u003e \u0026v[1..],\n        }\n    }\n\n    fn check_bounds(\u0026self, dim_index: \u0026Dimensions) -\u003e JlrsResult\u003c()\u003e {\n        if self.n_dimensions() != dim_index.n_dimensions() {\n            Err(JlrsError::InvalidIndex(dim_index.clone(), self.clone()))?;\n        }\n\n        for i in 0..self.n_dimensions() {\n            if self.n_elements(i) \u003c dim_index.n_elements(i) {\n                Err(JlrsError::InvalidIndex(dim_index.clone(), self.clone()))?;\n            }\n        }\n\n        Ok(())\n    }\n}\n\nimpl Debug for Dimensions {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e FmtResult {\n        let mut f = f.debug_tuple(\"\");\n\n        for d in self.as_slice() {\n            f.field(\u0026d);\n        }\n\n        f.finish()\n    }\n}\n\nimpl Display for Dimensions {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e FmtResult {\n        let mut f = f.debug_tuple(\"\");\n\n        for d in self.as_slice() {\n            f.field(\u0026d);\n        }\n\n        f.finish()\n    }\n}\n\nimpl Into\u003cDimensions\u003e for usize {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Few([1, self, 0, 0])\n    }\n}\n\nimpl Into\u003cDimensions\u003e for () {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Few([0, 0, 0, 0])\n    }\n}\n\nimpl Into\u003cDimensions\u003e for (usize,) {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Few([1, self.0, 0, 0])\n    }\n}\n\nimpl Into\u003cDimensions\u003e for (usize, usize) {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Few([2, self.0, self.1, 0])\n    }\n}\n\nimpl Into\u003cDimensions\u003e for (usize, usize, usize) {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Few([3, self.0, self.1, self.2])\n    }\n}\n\nimpl Into\u003cDimensions\u003e for (usize, usize, usize, usize) {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Many(Box::new([4, self.0, self.1, self.2, self.3]))\n    }\n}\n\nimpl Into\u003cDimensions\u003e for (usize, usize, usize, usize, usize) {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Many(Box::new([5, self.0, self.1, self.2, self.3, self.4]))\n    }\n}\n\nimpl Into\u003cDimensions\u003e for (usize, usize, usize, usize, usize, usize) {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Many(Box::new([\n            6, self.0, self.1, self.2, self.3, self.4, self.5,\n        ]))\n    }\n}\n\nimpl Into\u003cDimensions\u003e for (usize, usize, usize, usize, usize, usize, usize) {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Many(Box::new([\n            7, self.0, self.1, self.2, self.3, self.4, self.5, self.6,\n        ]))\n    }\n}\n\nimpl Into\u003cDimensions\u003e for (usize, usize, usize, usize, usize, usize, usize, usize) {\n    fn into(self) -\u003e Dimensions {\n        Dimensions::Many(Box::new([\n            8, self.0, self.1, self.2, self.3, self.4, self.5, self.6, self.7,\n        ]))\n    }\n}\n\nimpl Into\u003cDimensions\u003e for \u0026[usize] {\n    fn into(self) -\u003e Dimensions {\n        let nd = self.len();\n        let mut v: Vec\u003cusize\u003e = Vec::with_capacity(nd + 1);\n        v.push(nd);\n        v.extend_from_slice(self);\n        Dimensions::Many(v.into_boxed_slice())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Dimensions;\n    #[test]\n    fn convert_usize() {\n        let d: Dimensions = 4.into();\n        assert_eq!(d.n_dimensions(), 1);\n        assert_eq!(d.n_elements(0), 4);\n        assert_eq!(d.size(), 4);\n    }\n\n    #[test]\n    fn convert_tuple_0d() {\n        let d: Dimensions = ().into();\n        assert_eq!(d.n_dimensions(), 0);\n        assert_eq!(d.n_elements(0), 0);\n        assert_eq!(d.size(), 0);\n    }\n\n    #[test]\n    fn convert_tuple_1d() {\n        let d: Dimensions = (4,).into();\n        assert_eq!(d.n_dimensions(), 1);\n        assert_eq!(d.n_elements(0), 4);\n        assert_eq!(d.size(), 4);\n    }\n\n    #[test]\n    fn convert_tuple_2d() {\n        let d: Dimensions = (4, 3).into();\n        assert_eq!(d.n_dimensions(), 2);\n        assert_eq!(d.n_elements(0), 4);\n        assert_eq!(d.n_elements(1), 3);\n        assert_eq!(d.size(), 12);\n    }\n\n    #[test]\n    fn convert_tuple_3d() {\n        let d: Dimensions = (4, 3, 2).into();\n        assert_eq!(d.n_dimensions(), 3);\n        assert_eq!(d.n_elements(0), 4);\n        assert_eq!(d.n_elements(1), 3);\n        assert_eq!(d.n_elements(2), 2);\n        assert_eq!(d.size(), 24);\n    }\n\n    #[test]\n    fn convert_tuple_4d() {\n        let d: Dimensions = (4, 3, 2, 1).into();\n        assert_eq!(d.n_dimensions(), 4);\n        assert_eq!(d.n_elements(0), 4);\n        assert_eq!(d.n_elements(1), 3);\n        assert_eq!(d.n_elements(2), 2);\n        assert_eq!(d.n_elements(3), 1);\n        assert_eq!(d.size(), 24);\n    }\n\n    #[test]\n    fn convert_tuple_5d() {\n        let d: Dimensions = (4, 3, 2, 1, 2).into();\n        assert_eq!(d.n_dimensions(), 5);\n        assert_eq!(d.n_elements(0), 4);\n        assert_eq!(d.n_elements(1), 3);\n        assert_eq!(d.n_elements(2), 2);\n        assert_eq!(d.n_elements(3), 1);\n        assert_eq!(d.n_elements(4), 2);\n        assert_eq!(d.size(), 48);\n    }\n\n    #[test]\n    fn convert_tuple_6d() {\n        let d: Dimensions = (4, 3, 2, 1, 2, 3).into();\n        assert_eq!(d.n_dimensions(), 6);\n        assert_eq!(d.n_elements(0), 4);\n        assert_eq!(d.n_elements(1), 3);\n        assert_eq!(d.n_elements(2), 2);\n        assert_eq!(d.n_elements(3), 1);\n        assert_eq!(d.n_elements(4), 2);\n        assert_eq!(d.n_elements(5), 3);\n        assert_eq!(d.size(), 144);\n    }\n\n    #[test]\n    fn convert_tuple_7d() {\n        let d: Dimensions = (4, 3, 2, 1, 2, 3, 2).into();\n        assert_eq!(d.n_dimensions(), 7);\n        assert_eq!(d.n_elements(0), 4);\n        assert_eq!(d.n_elements(1), 3);\n        assert_eq!(d.n_elements(2), 2);\n        assert_eq!(d.n_elements(3), 1);\n        assert_eq!(d.n_elements(4), 2);\n        assert_eq!(d.n_elements(5), 3);\n        assert_eq!(d.n_elements(6), 2);\n        assert_eq!(d.size(), 288);\n    }\n\n    #[test]\n    fn convert_tuple_8d() {\n        let d: Dimensions = (4, 3, 2, 1, 2, 3, 2, 4).into();\n        assert_eq!(d.n_dimensions(), 8);\n        assert_eq!(d.n_elements(0), 4);\n        assert_eq!(d.n_elements(1), 3);\n        assert_eq!(d.n_elements(2), 2);\n        assert_eq!(d.n_elements(3), 1);\n        assert_eq!(d.n_elements(4), 2);\n        assert_eq!(d.n_elements(5), 3);\n        assert_eq!(d.n_elements(6), 2);\n        assert_eq!(d.n_elements(7), 4);\n        assert_eq!(d.size(), 1152);\n    }\n\n    #[test]\n    fn convert_tuple_nd() {\n        let v = [1, 2, 3];\n        let d: Dimensions = v.as_ref().into();\n        assert_eq!(d.n_dimensions(), 3);\n        assert_eq!(d.n_elements(0), 1);\n        assert_eq!(d.n_elements(1), 2);\n        assert_eq!(d.n_elements(2), 3);\n        assert_eq!(d.size(), 6);\n    }\n}\n","traces":[{"line":88,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":89,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":93,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":94,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":4230336,"length":1,"stats":{"Line":2},"fn_name":"into_typed_array\u003cf64\u003e"},{"line":102,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":null,"length":0,"stats":{"Line":52},"fn_name":null},{"line":121,"address":null,"length":0,"stats":{"Line":52},"fn_name":null},{"line":126,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":132,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":137,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":4217792,"length":1,"stats":{"Line":38},"fn_name":"copy_inline_data\u003cu64\u003e"},{"line":155,"address":null,"length":0,"stats":{"Line":38},"fn_name":null},{"line":156,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":160,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":165,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":167,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":168,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":169,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":170,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":171,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":173,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":180,"address":null,"length":0,"stats":{"Line":12},"fn_name":null},{"line":188,"address":null,"length":0,"stats":{"Line":12},"fn_name":null},{"line":189,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":193,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":198,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":199,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":200,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":207,"address":null,"length":0,"stats":{"Line":12},"fn_name":null},{"line":215,"address":null,"length":0,"stats":{"Line":12},"fn_name":null},{"line":216,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":219,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":220,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":225,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":226,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":227,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":237,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":255,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":276,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":281,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":323,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":338,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":345,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":350,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":358,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":359,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":362,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":365,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":366,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":371,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":372,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":374,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":375,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":377,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":398,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":399,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":401,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":405,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":406,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":411,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":415,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":421,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":426,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":428,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":434,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":435,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":440,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":469,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":470,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":475,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":476,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":477,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":484,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":491,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":492,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":497,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":498,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":499,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":509,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":516,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":517,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":521,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":522,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":523,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":536,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":543,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":544,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":548,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":549,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":550,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":562,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":569,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":570,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":574,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":575,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":576,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":590,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":597,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":598,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":601,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":602,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":603,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":604,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":605,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":606,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":608,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":615,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":622,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":623,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":630,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":631,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":639,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":640,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":641,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":644,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":648,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":653,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":null,"length":0,"stats":{"Line":37},"fn_name":null},{"line":683,"address":null,"length":0,"stats":{"Line":27},"fn_name":null},{"line":684,"address":null,"length":0,"stats":{"Line":27},"fn_name":null},{"line":689,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":690,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":695,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":696,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":700,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":701,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":705,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":706,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":710,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":711,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":717,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":718,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":723,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":724,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":744,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":755,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":756,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":761,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":765,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":766,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":770,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":771,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":781,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":782,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":803,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":818,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":829,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":839,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":843,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":844,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":848,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":849,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":864,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":865,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":874,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":875,"address":null,"length":0,"stats":{"Line":11},"fn_name":null},{"line":896,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":911,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":916,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":917,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":921,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":922,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":926,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":931,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":932,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":947,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":948,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":957,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":958,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":975,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":992,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":996,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1002,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1004,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1005,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1008,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1011,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1012,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1015,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1019,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1020,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1024,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1037,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1054,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1071,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1072,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1075,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1080,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1081,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1083,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1084,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1088,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1089,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1090,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1092,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1096,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1097,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1102,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1114,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1144,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":1145,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":1146,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1147,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":1148,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1149,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":1150,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":1151,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1152,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1153,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1155,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1160,"address":null,"length":0,"stats":{"Line":15},"fn_name":null},{"line":1161,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":null,"length":0,"stats":{"Line":15},"fn_name":null},{"line":1163,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":1168,"address":null,"length":0,"stats":{"Line":14},"fn_name":null},{"line":1169,"address":null,"length":0,"stats":{"Line":14},"fn_name":null},{"line":1170,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1173,"address":null,"length":0,"stats":{"Line":14},"fn_name":null},{"line":1175,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1176,"address":null,"length":0,"stats":{"Line":14},"fn_name":null},{"line":1177,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1180,"address":null,"length":0,"stats":{"Line":14},"fn_name":null},{"line":1184,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":1185,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":1186,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1189,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1190,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":1191,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1193,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":1198,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1199,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1200,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1202,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1203,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1204,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1205,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1206,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1208,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1209,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":1213,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":1217,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":1218,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1219,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":1220,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1224,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":1225,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":1226,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1229,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":1230,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":1231,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1235,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":1240,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1241,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1243,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1244,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1247,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1253,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1256,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1259,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":1264,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":1265,"address":null,"length":0,"stats":{"Line":9},"fn_name":null},{"line":1270,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1271,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1276,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1277,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1282,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":1283,"address":null,"length":0,"stats":{"Line":10},"fn_name":null},{"line":1288,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":1289,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":1294,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1295,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1300,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1301,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1306,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1307,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1308,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1314,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1315,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1316,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1322,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1323,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1324,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1330,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":1331,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":1332,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":1333,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":1334,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":1335,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":1343,"address":4248640,"length":1,"stats":{"Line":2},"fn_name":"convert_usize"},{"line":1344,"address":4248647,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1345,"address":4248690,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1346,"address":4248852,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1347,"address":4249353,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1351,"address":4250160,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_0d"},{"line":1352,"address":4250167,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1353,"address":4250205,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1354,"address":4250367,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1355,"address":4250868,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1359,"address":4251680,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_1d"},{"line":1360,"address":4251687,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1361,"address":4251730,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1362,"address":4251892,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1363,"address":4252393,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1367,"address":4253200,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_2d"},{"line":1368,"address":4253207,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1369,"address":4253285,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1370,"address":4253447,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1371,"address":4253953,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1372,"address":4254454,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1376,"address":4255264,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_3d"},{"line":1377,"address":4255271,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1378,"address":4255353,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1379,"address":4255515,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1380,"address":4256021,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1381,"address":4256527,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1382,"address":4257028,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1386,"address":4257840,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_4d"},{"line":1387,"address":4257847,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1388,"address":4257941,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1389,"address":4258103,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1390,"address":4258609,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1391,"address":4259115,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1392,"address":4259621,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1393,"address":4260122,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1397,"address":4260928,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_5d"},{"line":1398,"address":4260935,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1399,"address":4261041,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1400,"address":4261203,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1401,"address":4261709,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1402,"address":4262215,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1403,"address":4262721,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1404,"address":4263227,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1405,"address":4263728,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1409,"address":4264544,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_6d"},{"line":1410,"address":4264551,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1411,"address":4264669,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1412,"address":4264831,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1413,"address":4265337,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1414,"address":4265843,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1415,"address":4266349,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1416,"address":4266855,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1417,"address":4267361,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1418,"address":4267862,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1422,"address":4268672,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_7d"},{"line":1423,"address":4268679,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1424,"address":4268809,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1425,"address":4268971,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1426,"address":4269477,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1427,"address":4269983,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1428,"address":4270489,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1429,"address":4270995,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1430,"address":4271501,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1431,"address":4272007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1432,"address":4272508,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1436,"address":4273328,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_8d"},{"line":1437,"address":4273335,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1438,"address":4273477,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1439,"address":4273639,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1440,"address":4274145,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1441,"address":4274651,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1442,"address":4275157,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1443,"address":4275663,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1444,"address":4276169,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1445,"address":4276675,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1446,"address":4277181,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1447,"address":4277682,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1451,"address":4278496,"length":1,"stats":{"Line":2},"fn_name":"convert_tuple_nd"},{"line":1452,"address":4278503,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1453,"address":4278539,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1454,"address":4278622,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1455,"address":4278784,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1456,"address":4279290,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1457,"address":4279796,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1458,"address":4280297,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":369,"coverable":469},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","code_instance.rs"],"content":"//! Support for values with the `Core.CodeInstance` type.\n//!\n//! The documentation for this module has been slightly adapted from the comments for this struct\n//! in [`julia.h`]\n//!\n//! [`julia.h`]: https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/src/julia.h#L273\n\nuse super::method_instance::MethodInstance;\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_code_instance_t, jl_code_instance_type};\nuse std::marker::PhantomData;\n\n/// A `CodeInstance` represents an executable operation.\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct CodeInstance\u003c'frame\u003e(*mut jl_code_instance_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e CodeInstance\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(code_instance: *mut jl_code_instance_t) -\u003e Self {\n        CodeInstance(code_instance, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_code_instance_t {\n        self.0\n    }\n\n    /// Method this instance is specialized from.\n    pub fn def(self) -\u003e MethodInstance\u003c'frame\u003e {\n        unsafe { MethodInstance::wrap((\u0026*self.ptr()).def) }\n    }\n\n    /// Next cache entry.\n    pub fn next(self) -\u003e Option\u003cSelf\u003e {\n        unsafe {\n            let next = (\u0026*self.ptr()).next;\n            if next.is_null() {\n                None\n            } else {\n                Some(CodeInstance::wrap(next))\n            }\n        }\n    }\n\n    /// Returns the minimum of the world range for which this object is valid to use.\n    pub fn min_world(self) -\u003e usize {\n        unsafe { (\u0026*self.ptr()).min_world }\n    }\n\n    /// Returns the maximum of the world range for which this object is valid to use.\n    pub fn max_world(self) -\u003e usize {\n        unsafe { (\u0026*self.ptr()).max_world }\n    }\n\n    /// Return type for fptr.\n    pub fn rettype(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).rettype) }\n    }\n\n    /// Inferred constant return value, or null\n    pub fn rettype_const(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let rettype_const = (\u0026*self.ptr()).rettype_const;\n            if rettype_const.is_null() {\n                None\n            } else {\n                Some(Value::wrap(rettype_const))\n            }\n        }\n    }\n\n    /// Inferred `CodeInfo`, `Nothing`, or `None`.\n    pub fn inferred(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let inferred = (\u0026*self.ptr()).inferred;\n            if inferred.is_null() {\n                None\n            } else {\n                Some(Value::wrap(inferred))\n            }\n        }\n    }\n\n    /// If `specptr` is a specialized function signature for specTypes-\u003erettype\n    pub fn isspecsig(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).isspecsig != 0 }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for CodeInstance\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for CodeInstance\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotACodeInstance)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(CodeInstance\u003c'frame\u003e, jl_code_instance_type, 'frame);\nimpl_julia_type!(CodeInstance\u003c'frame\u003e, jl_code_instance_type, 'frame);\nimpl_valid_layout!(CodeInstance\u003c'frame\u003e, 'frame);\n","traces":[{"line":22,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":4287479,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":38},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","datatype.rs"],"content":"//! Datatypes and properties.\n//!\n//! Julia has an optional typing system. The type information of a [`Value`] is available at\n//! runtime. Additionally, a value can hold type information as its contents. For example,\n//!\n//! ```julia\n//! truth = true\n//! truthtype = typeof(truth)\n//! @assert(truthtype == Bool)\n//! @assert(truthtype isa DataType)\n//! ```\n//!\n//! In this module you'll find the [`DataType`] struct which provides access to the properties\n//! of its counterpart in Julia and lets you perform a large set of checks to find out its\n//! properties. Many of these checks are handled through implementations of the trait\n//! [`JuliaTypecheck`]. Some of these checks can be found in this module.\n//!\n//! [`Value`]: ../struct.Value.html\n//! [`DataType`]: struct.DataType.html\n//! [`JuliaTypecheck`]: ../../traits/trait.JuliaTypecheck.html\n\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::{Cast, JuliaTypecheck};\nuse crate::value::symbol::Symbol;\nuse crate::value::type_name::TypeName;\nuse crate::value::Value;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{\n    jl_any_type, jl_code_info_type, jl_datatype_align, jl_datatype_isinlinealloc,\n    jl_datatype_nbits, jl_datatype_nfields, jl_datatype_size, jl_datatype_t, jl_datatype_type,\n    jl_field_isptr, jl_field_names, jl_field_offset, jl_field_size, jl_get_fieldtypes,\n    jl_globalref_type, jl_gotonode_type, jl_intrinsic_type, jl_is_cpointer_type, jl_isbits,\n    jl_linenumbernode_type, jl_namedtuple_typename, jl_newvarnode_type, jl_phicnode_type,\n    jl_phinode_type, jl_pinode_type, jl_quotenode_type, jl_slotnumber_type, jl_string_type,\n    jl_svec_data, jl_svec_len, jl_typedslot_type, jl_typename_str, jl_upsilonnode_type,\n};\nuse std::ffi::CStr;\nuse std::fmt::{Debug, Formatter, Result as FmtResult};\nuse std::marker::PhantomData;\n/// Julia type information. You can acquire a [`Value`]'s datatype by by calling\n/// [`Value::datatype`]. This struct implements [`JuliaTypecheck`] and [`Cast`]. It can be used in\n/// combination with [`DataType::is`] and [`Value::is`]; if the check returns `true` the [`Value`]\n///  can be cast to `DataType`:\n///\n/// ```\n/// # use jlrs::prelude::*;\n/// # use jlrs::util::JULIA;\n/// # fn main() {\n/// # JULIA.with(|j| {\n/// # let mut julia = j.borrow_mut();\n/// julia.frame(2, |global, frame| {\n///     let val = Value::new(frame, 1u8)?;\n///     let typeof_func = Module::core(global).function(\"typeof\")?;\n///     let ty_val = typeof_func.call1(frame, val)?.unwrap();\n///     assert!(ty_val.is::\u003cDataType\u003e());\n///     assert!(ty_val.cast::\u003cDataType\u003e().is_ok());\n///     Ok(())\n/// }).unwrap();\n/// # });\n/// # }\n/// ```\n///\n/// [`JuliaTypecheck`]: ../../traits/trait.JuliaTypecheck.html\n/// [`Cast`]: ../../traits/trait.Cast.html\n/// [`DataType::is`]: ../datatype/struct.DataType.html#method.is\n/// [`Value::is`]: ../struct.Value.html#method.is\n/// [`Value`]: ../struct.Value.html\n/// [`Value::datatype`]: ../struct.Value.html#method.datatype\n/// [`Value::cast`]: ../struct.Value.html#method.cast\n/// [`JuliaTypecheck`]: ../../traits/trait.JuliaTypecheck.html\n/// [`DataType::is`]: struct.Datatype.html#method.is\n/// [`Value::is`]: struct.Datatype.html#method.is\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct DataType\u003c'frame\u003e(*mut jl_datatype_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e DataType\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(datatype: *mut jl_datatype_t) -\u003e Self {\n        DataType(datatype, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_datatype_t {\n        self.0\n    }\n\n    /// Performs the given typecheck.\n    pub fn is\u003cT: JuliaTypecheck\u003e(self) -\u003e bool {\n        unsafe { T::julia_typecheck(self) }\n    }\n\n    /// Returns the size of a value of this type in bytes.\n    pub fn size(self) -\u003e i32 {\n        unsafe { jl_datatype_size(self.0) }\n    }\n\n    /// Returns the alignment of a value of this type in bytes.\n    pub fn align(self) -\u003e u16 {\n        unsafe { jl_datatype_align(self.0) }\n    }\n\n    /// Returns the size of a value of this type in bits.\n    pub fn nbits(self) -\u003e i32 {\n        unsafe { jl_datatype_nbits(self.0) }\n    }\n\n    /// Returns the number of fields of a value of this type.\n    pub fn nfields(self) -\u003e u32 {\n        unsafe { jl_datatype_nfields(self.0) }\n    }\n\n    /// Returns true if a value of this type stores its data inline.\n    pub fn isinlinealloc(self) -\u003e bool {\n        unsafe { jl_datatype_isinlinealloc(self.0) != 0 }\n    }\n\n    /// Returns the name of this type.\n    pub fn name(self) -\u003e \u0026'frame str {\n        unsafe {\n            let name = jl_typename_str(self.ptr().cast());\n            CStr::from_ptr(name).to_str().unwrap()\n        }\n    }\n\n    /// Returns the `TypeName` of this type.\n    pub fn type_name(self) -\u003e TypeName\u003c'frame\u003e {\n        unsafe { TypeName::wrap((\u0026*self.ptr()).name) }\n    }\n\n    /// Returns the field names of this type as a slice of `Symbol`s. These symbols can be used\n    /// to access their fields with [`Value::get_field`].\n    ///\n    /// [`Value::get_field`]: struct.Value.html#method.get_field\n    pub fn field_names(self) -\u003e \u0026'frame [Symbol\u003c'frame\u003e] {\n        unsafe {\n            let field_names = jl_field_names(self.ptr().cast());\n            let len = jl_svec_len(field_names);\n            let items = jl_svec_data(field_names);\n            std::slice::from_raw_parts(items.cast(), len)\n        }\n    }\n\n    /// Returns the field types of this type.\n    pub fn field_types(self) -\u003e \u0026'frame [Value\u003c'frame, 'static\u003e] {\n        unsafe {\n            let field_types = jl_get_fieldtypes(self.ptr());\n            let len = jl_svec_len(field_types);\n            let items = jl_svec_data(field_types);\n            std::slice::from_raw_parts(items.cast(), len)\n        }\n    }\n\n    /// Returns the size of the field at position `idx` in this type.\n    pub fn field_size(self, idx: usize) -\u003e u32 {\n        unsafe { jl_field_size(self.ptr(), idx as _) }\n    }\n\n    /// Returns the offset where the field at position `idx` is stored.\n    pub fn field_offset(self, idx: usize) -\u003e u32 {\n        unsafe { jl_field_offset(self.ptr(), idx as _) }\n    }\n\n    /// Returns true if the field at position `idx` is a pointer.\n    pub fn is_pointer_field(self, idx: usize) -\u003e bool {\n        unsafe { jl_field_isptr(self.ptr(), idx as _) }\n    }\n\n    /// Returns true if this type is a bits-type.\n    pub fn isbits(self) -\u003e bool {\n        unsafe { jl_isbits(self.ptr().cast()) }\n    }\n\n    /// Returns the supertype of this type.\n    pub fn super_type(self) -\u003e Option\u003cSelf\u003e {\n        unsafe {\n            let sup = (\u0026*self.ptr()).super_;\n            if sup.is_null() {\n                None\n            } else {\n                Some(DataType::wrap(sup))\n            }\n        }\n    }\n\n    /// Returns the type parameters of this type.\n    pub fn parameters(self) -\u003e \u0026'frame [Value\u003c'frame, 'static\u003e] {\n        unsafe {\n            let params = (\u0026*self.ptr()).parameters;\n            std::slice::from_raw_parts(jl_svec_data(params).cast(), jl_svec_len(params))\n        }\n    }\n\n    /// Returns the instance if this type is a singleton.\n    pub fn instance(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let instance = (\u0026*self.ptr()).instance;\n            if instance.is_null() {\n                None\n            } else {\n                Some(Value::wrap(instance))\n            }\n        }\n    }\n\n    /// Returns the number of initialized fields.\n    pub fn n_initialized(self) -\u003e i32 {\n        unsafe { (\u0026*self.ptr()).ninitialized }\n    }\n\n    /// Returns the hash of this type.\n    pub fn hash(self) -\u003e u32 {\n        unsafe { (\u0026*self.ptr()).hash }\n    }\n\n    /// Returns true if this is an abstract type.\n    pub fn is_abstract(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).abstract_ != 0 }\n    }\n\n    /// Returns true if this is a mutable type.\n    pub fn mutable(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).mutabl != 0 }\n    }\n\n    /// Returns true if one or more of the type parameters has not been set.\n    pub fn has_free_type_vars(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).hasfreetypevars != 0 }\n    }\n\n    /// Returns true if this type can have instances\n    pub fn is_concrete_type(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).isconcretetype != 0 }\n    }\n\n    /// Returns true if this type is a dispatch, or leaf, tuple type.\n    pub fn is_dispatch_tuple(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).isdispatchtuple != 0 }\n    }\n\n    /// Returns true if one or more fields require zero-initialization.\n    pub fn zeroinit(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).zeroinit != 0 }\n    }\n\n    /// If false, no value will have this type.\n    pub fn has_concrete_subtype(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).has_concrete_subtype != 0 }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for DataType\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nimpl\u003c'frame, 'data\u003e Debug for DataType\u003c'frame\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e FmtResult {\n        f.debug_tuple(\"DataType\").field(\u0026self.name()).finish()\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for DataType\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotADataType)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        DataType::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_type!(DataType\u003c'frame\u003e, jl_datatype_type, 'frame);\nimpl_valid_layout!(DataType\u003c'frame\u003e, 'frame);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a tuple.\npub struct Any;\nimpl_julia_typecheck!(Any, jl_any_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a named tuple.\npub struct NamedTuple;\n\nunsafe impl JuliaTypecheck for NamedTuple {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        (\u0026*t.ptr()).name == jl_namedtuple_typename\n    }\n}\n\nimpl_julia_typecheck!(DataType\u003c'frame\u003e, jl_datatype_type, 'frame);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// the fields of a value of this type can be modified.\npub struct Mutable;\n\nunsafe impl JuliaTypecheck for Mutable {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        (\u0026*t.ptr()).mutabl != 0\n    }\n}\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// the datatype is a mutable datatype.\npub struct MutableDatatype;\n\nunsafe impl JuliaTypecheck for MutableDatatype {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        DataType::julia_typecheck(t) \u0026\u0026 (\u0026*t.ptr()).mutabl != 0\n    }\n}\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// the fields of a value of this type cannot be modified.\npub struct Immutable;\n\nunsafe impl JuliaTypecheck for Immutable {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        (\u0026*t.ptr()).mutabl == 0\n    }\n}\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// the datatype is an immutable datatype.\npub struct ImmutableDatatype;\n\nunsafe impl JuliaTypecheck for ImmutableDatatype {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        DataType::julia_typecheck(t) \u0026\u0026 (\u0026*t.ptr()).mutabl == 0\n    }\n}\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a slot.\npub struct Slot;\n\nunsafe impl JuliaTypecheck for Slot {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        t.ptr() == jl_slotnumber_type || t.ptr() == jl_typedslot_type\n    }\n}\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a global reference.\npub struct GlobalRef;\nimpl_julia_typecheck!(GlobalRef, jl_globalref_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a Goto node.\npub struct GotoNode;\nimpl_julia_typecheck!(GotoNode, jl_gotonode_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a Pi node.\npub struct PiNode;\nimpl_julia_typecheck!(PiNode, jl_pinode_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a Phi node.\npub struct PhiNode;\nimpl_julia_typecheck!(PhiNode, jl_phinode_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a PhiC node.\npub struct PhiCNode;\nimpl_julia_typecheck!(PhiCNode, jl_phicnode_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is an Upsilon node.\npub struct UpsilonNode;\nimpl_julia_typecheck!(UpsilonNode, jl_upsilonnode_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a Quote node.\npub struct QuoteNode;\nimpl_julia_typecheck!(QuoteNode, jl_quotenode_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is an NewVar node.\npub struct NewVarNode;\nimpl_julia_typecheck!(NewVarNode, jl_newvarnode_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a Line node.\npub struct LineNode;\nimpl_julia_typecheck!(LineNode, jl_linenumbernode_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is code info.\npub struct CodeInfo;\nimpl_julia_typecheck!(CodeInfo, jl_code_info_type);\n\nimpl_julia_typecheck!(String, jl_string_type);\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a pointer.\npub struct Pointer;\nunsafe impl JuliaTypecheck for Pointer {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        jl_is_cpointer_type(t.ptr().cast())\n    }\n}\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is an intrinsic.\npub struct Intrinsic;\nimpl_julia_typecheck!(Intrinsic, jl_intrinsic_type);\n\npub struct Concrete;\nunsafe impl JuliaTypecheck for Concrete {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        (\u0026*t.ptr()).isconcretetype != 0\n    }\n}\n","traces":[{"line":78,"address":null,"length":0,"stats":{"Line":20},"fn_name":null},{"line":79,"address":null,"length":0,"stats":{"Line":20},"fn_name":null},{"line":83,"address":null,"length":0,"stats":{"Line":20},"fn_name":null},{"line":84,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":null,"length":0,"stats":{"Line":222},"fn_name":null},{"line":89,"address":null,"length":0,"stats":{"Line":222},"fn_name":null},{"line":93,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":147,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":148,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":253,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":258,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":266,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":267,"address":null,"length":0,"stats":{"Line":12},"fn_name":null},{"line":270,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":273,"address":null,"length":0,"stats":{"Line":12},"fn_name":null},{"line":274,"address":null,"length":0,"stats":{"Line":12},"fn_name":null},{"line":278,"address":4383319,"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":292,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":304,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":313,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":314,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":323,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":324,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":405,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":416,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":null,"length":0,"stats":{"Line":0},"fn_name":null}],"covered":45,"coverable":97},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","expr.rs"],"content":"//! Support for values with the `Core.Expr` type.\n\nuse super::array::Array;\nuse super::symbol::Symbol;\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_expr_t, jl_expr_type};\nuse std::marker::PhantomData;\n\n/// A compound expression in Julia ASTs.\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct Expr\u003c'frame\u003e(*mut jl_expr_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e Expr\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(expr: *mut jl_expr_t) -\u003e Self {\n        Expr(expr, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_expr_t {\n        self.0\n    }\n\n    /// Returns the head of the expression.\n    pub fn head(self) -\u003e Symbol\u003c'frame\u003e {\n        unsafe { Symbol::wrap((\u0026*self.ptr()).head) }\n    }\n\n    /// Returns the arguments of the expression.\n    pub fn args(self) -\u003e Array\u003c'frame, 'static\u003e {\n        unsafe { Array::wrap((\u0026*self.ptr()).args) }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for Expr\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for Expr\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAnExpr)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(Expr\u003c'frame\u003e, jl_expr_type, 'frame);\nimpl_julia_type!(Expr\u003c'frame\u003e, jl_expr_type, 'frame);\nimpl_valid_layout!(Expr\u003c'frame\u003e, 'frame);\n","traces":[{"line":18,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":4216551,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","method.rs"],"content":"//! Support for values with the `Core.Method` type.\n//!\n//! The documentation for this module has been slightly adapted from the comments for this struct\n//! in [`julia.h`]\n//!\n//! [`julia.h`]: https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/src/julia.h#L273\n\nuse super::array::Array;\nuse super::method_instance::MethodInstance;\nuse super::module::Module;\nuse super::simple_vector::SimpleVector;\nuse super::symbol::Symbol;\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_method_t, jl_method_type};\nuse std::marker::PhantomData;\n\n/// This type describes a single method definition, and stores data shared by the specializations\n/// of a function.\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct Method\u003c'frame\u003e(*mut jl_method_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e Method\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(method: *mut jl_method_t) -\u003e Self {\n        Method(method, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_method_t {\n        self.0\n    }\n\n    /// Method name for error reporting\n    pub fn name(self) -\u003e Symbol\u003c'frame\u003e {\n        unsafe { Symbol::wrap((\u0026*self.ptr()).name) }\n    }\n\n    /// Method module\n    pub fn module(self) -\u003e Module\u003c'frame\u003e {\n        unsafe { Module::wrap((\u0026*self.ptr()).module) }\n    }\n\n    /// Method file\n    pub fn file(self) -\u003e Symbol\u003c'frame\u003e {\n        unsafe { Symbol::wrap((\u0026*self.ptr()).file) }\n    }\n\n    /// Method line in file\n    pub fn line(self) -\u003e i32 {\n        unsafe { (\u0026*self.ptr()).line }\n    }\n\n    pub fn primary_world(self) -\u003e usize {\n        unsafe { (\u0026*self.ptr()).primary_world }\n    }\n\n    pub fn deleted_world(self) -\u003e usize {\n        unsafe { (\u0026*self.ptr()).deleted_world }\n    }\n\n    /// Method's type signature.\n    pub fn signature(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).sig) }\n    }\n\n    /// List of potentially-ambiguous methods (nothing = none, Vector{Any} of TypeMapEntry otherwise)\n    pub fn ambiguous(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).ambig) }\n    }\n\n    /// Forward references to later items (typemap entries) which might sort before this one\n    pub fn resorted(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).resorted) }\n    }\n\n    /// Table of all `Method` specializations, allocated as [hashable, ..., NULL, linear, ....]\n    pub fn specializations(self) -\u003e SimpleVector\u003c'frame\u003e {\n        unsafe { SimpleVector::wrap((\u0026*self.ptr()).specializations) }\n    }\n\n    /// Index lookup by hash into specializations\n    pub fn speckeyset(self) -\u003e Array\u003c'frame, 'static\u003e {\n        unsafe { Array::wrap((\u0026*self.ptr()).speckeyset) }\n    }\n\n    /// Compacted list of slot names (String)\n    pub fn slot_syms(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).slot_syms) }\n    }\n\n    // Original code template (`Core.CodeInfo`, but may be compressed), `None` for builtins.\n    pub fn source(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let source = (\u0026*self.ptr()).source;\n            if source.is_null() {\n                None\n            } else {\n                Some(Value::wrap(source))\n            }\n        }\n    }\n\n    /// Unspecialized executable method instance, or `None`\n    pub fn unspecialized(self) -\u003e Option\u003cMethodInstance\u003c'frame\u003e\u003e {\n        unsafe {\n            let unspecialized = (\u0026*self.ptr()).unspecialized;\n            if unspecialized.is_null() {\n                None\n            } else {\n                Some(MethodInstance::wrap(unspecialized))\n            }\n        }\n    }\n\n    /// Executable code-generating function if available\n    pub fn generator(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let generator = (\u0026*self.ptr()).generator;\n            if generator.is_null() {\n                None\n            } else {\n                Some(Value::wrap(generator))\n            }\n        }\n    }\n\n    /// Pointers in generated code (shared to reduce memory), or `None`\n    pub fn roots(self) -\u003e Option\u003cArray\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let roots = (\u0026*self.ptr()).roots;\n            if roots.is_null() {\n                None\n            } else {\n                Some(Array::wrap(roots))\n            }\n        }\n    }\n\n    /// `SimpleVector(rettype, sig)` if a ccallable entry point is requested for this\n    pub fn ccallable(self) -\u003e Option\u003cSimpleVector\u003c'frame\u003e\u003e {\n        unsafe {\n            let ccallable = (\u0026*self.ptr()).ccallable;\n            if ccallable.is_null() {\n                None\n            } else {\n                Some(SimpleVector::wrap(ccallable))\n            }\n        }\n    }\n\n    /// Cache of specializations of this method for invoke(), i.e.\n    /// cases where this method was called even though it was not necessarily\n    /// the most specific for the argument types.\n    pub fn invokes(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).invokes) }\n    }\n\n    pub fn n_args(self) -\u003e i32 {\n        unsafe { (\u0026*self.ptr()).nargs }\n    }\n\n    /// Bit flags: whether each of the first 8 arguments is called\n    pub fn called(self) -\u003e i32 {\n        unsafe { (\u0026*self.ptr()).called }\n    }\n\n    /// Bit flags: which arguments should not be specialized\n    pub fn nospecialize(self) -\u003e i32 {\n        unsafe { (\u0026*self.ptr()).nospecialize }\n    }\n\n    /// Number of leading arguments that are actually keyword arguments\n    /// of another method.\n    pub fn nkw(self) -\u003e i32 {\n        unsafe { (\u0026*self.ptr()).nkw }\n    }\n\n    pub fn is_varargs(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).isva != 0 }\n    }\n\n    pub fn pure(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).pure_ != 0 }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for Method\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for Method\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAMethod)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(Method\u003c'frame\u003e, jl_method_type, 'frame);\nimpl_julia_type!(Method\u003c'frame\u003e, jl_method_type, 'frame);\nimpl_valid_layout!(Method\u003c'frame\u003e, 'frame);\n","traces":[{"line":27,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":4341863,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","method_instance.rs"],"content":"//! Support for values with the `Core.MethodInstance` type.\n//!\n//! The documentation for this module has been slightly adapted from the comments for this struct\n//! in [`julia.h`]\n//!\n//! [`julia.h`]: https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/src/julia.h#L321\nuse super::array::Array;\nuse super::code_instance::CodeInstance;\nuse super::simple_vector::SimpleVector;\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_method_instance_t, jl_method_instance_type};\nuse std::marker::PhantomData;\n\n/// This type is a placeholder to cache data for a specType signature specialization of a `Method`\n/// can can be used as a unique dictionary key representation of a call to a particular `Method`\n/// with a particular set of argument types\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct MethodInstance\u003c'frame\u003e(*mut jl_method_instance_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e MethodInstance\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(method_instance: *mut jl_method_instance_t) -\u003e Self {\n        MethodInstance(method_instance, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_method_instance_t {\n        self.0\n    }\n\n    /// Context for this code\n    pub fn def(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).def.value) }\n    }\n\n    // Argument types this was specialized for\n    pub fn spec_types(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).specTypes) }\n    }\n\n    // Static parameter values, indexed by def.method-\u003esparam_syms\n    pub fn sparam_vals(self) -\u003e SimpleVector\u003c'frame\u003e {\n        unsafe { SimpleVector::wrap((\u0026*self.ptr()).sparam_vals) }\n    }\n\n    // Cached uncompressed code, for generated functions, top-level thunks, or the interpreter\n    pub fn uninferred(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).uninferred) }\n    }\n\n    /// List of method-instances which contain a call into this method-instance\n    pub fn backedges(self) -\u003e Array\u003c'frame, 'static\u003e {\n        unsafe { Array::wrap((\u0026*self.ptr()).backedges) }\n    }\n\n    pub fn cache(self) -\u003e CodeInstance\u003c'frame\u003e {\n        unsafe { CodeInstance::wrap((\u0026*self.ptr()).cache) }\n    }\n\n    /// Flags to tell if inference is running on this object\n    pub fn in_inference(self) -\u003e u8 {\n        unsafe { (\u0026*self.ptr()).inInference }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for MethodInstance\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for MethodInstance\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAMethodInstance)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(MethodInstance\u003c'frame\u003e, jl_method_instance_type, 'frame);\nimpl_julia_type!(MethodInstance\u003c'frame\u003e, jl_method_instance_type, 'frame);\nimpl_valid_layout!(MethodInstance\u003c'frame\u003e, 'frame);\n","traces":[{"line":25,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":4309543,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","method_table.rs"],"content":"//! Support for values with the `Core.MethodTable` type.\n//!\n//! The documentation for this module has been slightly adapted from the comments for this struct\n//! in [`julia.h`]\n//!\n//! [`julia.h`]: https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/src/julia.h#L535\n\nuse super::{array::Array, module::Module, symbol::Symbol, Value};\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_methtable_t, jl_methtable_type};\nuse std::marker::PhantomData;\n\n/// contains the TypeMap for one Type\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct MethodTable\u003c'frame\u003e(*mut jl_methtable_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e MethodTable\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(method_table: *mut jl_methtable_t) -\u003e Self {\n        MethodTable(method_table, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_methtable_t {\n        self.0\n    }\n\n    /// Sometimes a hack used by serialization to handle kwsorter\n    pub fn name(self) -\u003e Symbol\u003c'frame\u003e {\n        unsafe { Symbol::wrap((\u0026*self.ptr()).name) }\n    }\n\n    pub fn defs(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).defs) }\n    }\n\n    pub fn cache(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).cache) }\n    }\n\n    /// Max # of non-vararg arguments in a signature\n    pub fn max_args(self) -\u003e isize {\n        unsafe { (\u0026*self.ptr()).max_args }\n    }\n\n    /// Keyword argument sorter function\n    pub fn kwsorter(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).kwsorter) }\n    }\n\n    /// Used for incremental serialization to locate original binding\n    pub fn module(self) -\u003e Module\u003c'frame\u003e {\n        unsafe { Module::wrap((\u0026*self.ptr()).module) }\n    }\n\n    pub fn backedges(self) -\u003e Array\u003c'frame, 'static\u003e {\n        unsafe { Array::wrap((\u0026*self.ptr()).backedges) }\n    }\n\n    /// 0, or 1 to skip splitting typemap on first (function) argument\n    pub fn offs(self) -\u003e u8 {\n        unsafe { (\u0026*self.ptr()).offs }\n    }\n\n    // Whether this accepts adding new methods\n    pub fn frozen(self) -\u003e u8 {\n        unsafe { (\u0026*self.ptr()).frozen }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for MethodTable\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for MethodTable\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAMethTable)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(MethodTable\u003c'frame\u003e, jl_methtable_type, 'frame);\nimpl_julia_type!(MethodTable\u003c'frame\u003e, jl_methtable_type, 'frame);\nimpl_valid_layout!(MethodTable\u003c'frame\u003e, 'frame);\n","traces":[{"line":21,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":4379143,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":31},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","module.rs"],"content":"//! Access Julia modules and the globals and functions defined in them.\n\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::global::Global;\nuse crate::traits::{private::Internal, Cast, TemporarySymbol};\nuse crate::value::symbol::Symbol;\nuse crate::value::Value;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{\n    jl_base_module, jl_core_module, jl_get_global, jl_main_module, jl_module_t, jl_module_type,\n    jl_set_const, jl_set_global, jl_typeis,\n};\nuse std::fmt::{Debug, Formatter, Result as FmtResult};\nuse std::marker::PhantomData;\n\n/// Functionality in Julia can be accessed through its module system. You can get a handle to the\n/// three standard modules, `Main`, `Base`, and `Core` and access their submodules through them.\n/// If you include your own Julia code with [`Julia::include`], its contents are made available\n/// relative to `Main`.\n///\n/// This struct implements [`JuliaTypecheck`] and [`Cast`]. It can be used in combination with\n/// [`DataType::is`] and [`Value::is`]; if the check returns `true` the [`Value`] can be cast to\n///  `Module`.\n///\n/// [`Julia::include`]: ../../struct.Julia.html#method.include\n/// [`JuliaTypecheck`]: ../../traits/trait.JuliaTypecheck.html\n/// [`Cast`]: ../../traits/trait.Cast.html\n/// [`DataType::is`]: ../datatype/struct.DataType.html#method.is\n/// [`Value::is`]: ../struct.Value.html#method.is\n/// [`Value`]: ../struct.Value.html\n#[derive(Copy, Clone)]\n#[repr(transparent)]\npub struct Module\u003c'base\u003e(*mut jl_module_t, PhantomData\u003c\u0026'base ()\u003e);\n\nimpl\u003c'base\u003e Module\u003c'base\u003e {\n    pub(crate) unsafe fn wrap(module: *mut jl_module_t) -\u003e Self {\n        Module(module, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_module_t {\n        self.0\n    }\n\n    /// Returns the name of this module.\n    pub fn name(self) -\u003e Symbol\u003c'base\u003e {\n        unsafe { Symbol::wrap((\u0026*(self.ptr())).name) }\n    }\n\n    /// Returns the parent of this module.\n    pub fn parent(self) -\u003e Option\u003cSelf\u003e {\n        unsafe {\n            let parent = (\u0026*(self.ptr())).parent;\n            if parent.is_null() {\n                return None;\n            }\n\n            Some(Self::wrap(parent))\n        }\n    }\n\n    /// Extend the lifetime of this module; if `self` has originally been created by calling some\n    /// Julia function the lifetime will be limited to the frame the function is called with. This\n    /// can be extended to the lifetime of `Global` by calling this method.\n    pub fn extend\u003c'global\u003e(self, _: Global\u003c'global\u003e) -\u003e Module\u003c'global\u003e {\n        unsafe { Module::wrap(self.ptr()) }\n    }\n\n    /// Returns a handle to Julia's `Main`-module. If you include your own Julia code by calling\n    /// [`Julia::include`], handles to functions, globals, and submodules defined in these\n    /// included files are available through this module.\n    ///\n    /// [`Julia::include`]: ../../struct.Julia.html#method.include\n    pub fn main(_: Global\u003c'base\u003e) -\u003e Self {\n        unsafe { Module::wrap(jl_main_module) }\n    }\n\n    /// Returns a handle to Julia's `Core`-module.\n    pub fn core(_: Global\u003c'base\u003e) -\u003e Self {\n        unsafe { Module::wrap(jl_core_module) }\n    }\n\n    /// Returns a handle to Julia's `Base`-module.\n    pub fn base(_: Global\u003c'base\u003e) -\u003e Self {\n        unsafe { Module::wrap(jl_base_module) }\n    }\n\n    /// Returns the submodule named `name` relative to this module. You have to visit this level\n    /// by level: you can't access `Main.A.B` by calling this function with `\"A.B\"`, but have to\n    /// access `A` first and then `B`.\n    ///\n    /// Returns an error if the submodule doesn't exist.\n    pub fn submodule\u003cN\u003e(self, name: N) -\u003e JlrsResult\u003cSelf\u003e\n    where\n        N: TemporarySymbol,\n    {\n        unsafe {\n            // safe because jl_symbol_n copies the contents\n            let symbol = name.temporary_symbol(Internal);\n\n            let submodule = jl_get_global(self.ptr(), symbol.ptr());\n\n            if !submodule.is_null() \u0026\u0026 jl_typeis(submodule, jl_module_type) {\n                Ok(Module(submodule as *mut jl_module_t, PhantomData))\n            } else {\n                Err(JlrsError::NotAModule(symbol.into()).into())\n            }\n        }\n    }\n\n    /// Set a global value in this module. This is unsafe because if another global value was\n    /// previously assigned to this name, this previous value can become eligible for garbage\n    /// collection. Don't use the previous value after calling this method.\n    pub unsafe fn set_global\u003c'frame, N\u003e(\n        self,\n        name: N,\n        value: Value\u003c'frame, 'static\u003e,\n    ) -\u003e Value\u003c'base, 'static\u003e\n    where\n        N: TemporarySymbol,\n    {\n        jl_set_global(\n            self.ptr(),\n            name.temporary_symbol(Internal).ptr(),\n            value.ptr(),\n        );\n        Value::wrap(value.ptr())\n    }\n\n    /// Set a constant in this module.\n    pub fn set_const\u003c'frame, N\u003e(\n        self,\n        name: N,\n        value: Value\u003c'frame, 'static\u003e,\n    ) -\u003e JlrsResult\u003cValue\u003c'base, 'static\u003e\u003e\n    where\n        N: TemporarySymbol,\n    {\n        unsafe {\n            let symbol = name.temporary_symbol(Internal);\n            if self.global(symbol).is_ok() {\n                Err(JlrsError::ConstAlreadyExists(symbol.into()))?;\n            }\n\n            jl_set_const(self.ptr(), symbol.ptr(), value.ptr());\n\n            Ok(Value::wrap(value.ptr()))\n        }\n    }\n\n    /// Returns the global named `name` in this module.\n    /// Returns an error if the global doesn't exist.\n    pub fn global\u003cN\u003e(self, name: N) -\u003e JlrsResult\u003cValue\u003c'base, 'static\u003e\u003e\n    where\n        N: TemporarySymbol,\n    {\n        unsafe {\n            let symbol = name.temporary_symbol(Internal);\n\n            // there doesn't seem to be a way to check if this is actually a\n            // function...\n            let func = jl_get_global(self.ptr(), symbol.ptr());\n            if func.is_null() {\n                return Err(JlrsError::FunctionNotFound(symbol.into()).into());\n            }\n\n            Ok(Value::wrap(func.cast()))\n        }\n    }\n\n    /// Returns the function named `name` in this module. Note that all globals defined within the\n    /// module will be successfully resolved into a function; Julia will throw an exception if you\n    /// try to call something that isn't a function. This means that this method is just an alias\n    /// for `Module::global`.\n    ///\n    /// Returns an error if th function doesn't exist.\n    pub fn function\u003cN\u003e(self, name: N) -\u003e JlrsResult\u003cValue\u003c'base, 'static\u003e\u003e\n    where\n        N: TemporarySymbol,\n    {\n        self.global(name)\n    }\n}\n\nimpl\u003c'base\u003e Into\u003cValue\u003c'base, 'static\u003e\u003e for Module\u003c'base\u003e {\n    fn into(self) -\u003e Value\u003c'base, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for Module\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAModule(\"This\".to_string()))?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(Module\u003c'frame\u003e, jl_module_type, 'frame);\nimpl_julia_type!(Module\u003c'frame\u003e, jl_module_type, 'frame);\nimpl_valid_layout!(Module\u003c'frame\u003e, 'frame);\n\nimpl\u003c'frame, 'data\u003e Debug for Module\u003c'frame\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e FmtResult {\n        let name: String = self.name().into();\n        f.debug_tuple(\"Module\").field(\u0026name).finish()\n    }\n}\n","traces":[{"line":36,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":37,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":41,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":42,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":75,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":79,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":85,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":93,"address":4217024,"length":1,"stats":{"Line":13},"fn_name":"submodule\u003c\u0026str\u003e"},{"line":99,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":101,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":103,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":104,"address":null,"length":0,"stats":{"Line":13},"fn_name":null},{"line":106,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":4245936,"length":1,"stats":{"Line":22},"fn_name":"global\u003cjlrs::value::symbol::Symbol\u003e"},{"line":158,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":162,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":163,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":164,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":167,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":177,"address":4339200,"length":1,"stats":{"Line":21},"fn_name":"function\u003c\u0026str\u003e"},{"line":181,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":186,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":187,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":193,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":194,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":195,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":202,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":4409399,"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":null,"length":0,"stats":{"Line":0},"fn_name":null}],"covered":44,"coverable":56},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","simple_vector.rs"],"content":"//! Support for values with the `Core.SimpleVector` (`SVec`) type.\n\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::value::Value;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_simplevector_type, jl_svec_data, jl_svec_t};\nuse std::marker::PhantomData;\n\n/// A `SimpleVector` is a fixed-size array that contains `Value`s.\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct SimpleVector\u003c'frame\u003e(*mut jl_svec_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e SimpleVector\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(svec: *mut jl_svec_t) -\u003e Self {\n        SimpleVector(svec, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_svec_t {\n        self.0\n    }\n\n    /// Returns the length of this `SimpleVector`.\n    pub fn len(self) -\u003e usize {\n        unsafe { (\u0026*self.ptr()).length }\n    }\n\n    /// Returns the data of this `SimpleVector`.\n    pub fn data(self) -\u003e \u0026'frame [Value\u003c'frame, 'static\u003e] {\n        unsafe { std::slice::from_raw_parts(jl_svec_data(self.ptr()).cast(), self.len()) }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for SimpleVector\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for SimpleVector\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAnSVec)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(SimpleVector\u003c'frame\u003e, jl_simplevector_type, 'frame);\nimpl_julia_type!(SimpleVector\u003c'frame\u003e, jl_simplevector_type, 'frame);\nimpl_valid_layout!(SimpleVector\u003c'frame\u003e, 'frame);\n","traces":[{"line":16,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":4244343,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","string.rs"],"content":"//! Support for accessing raw Julia strings.\n\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::value::Value;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::jl_string_type;\nuse std::ffi::CStr;\nuse std::marker::PhantomData;\nuse std::mem;\nuse std::slice;\n\n/// A raw Julia string.\n#[derive(Copy, Clone)]\n#[repr(transparent)]\npub struct JuliaString\u003c'frame\u003e(*const u8, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e JuliaString\u003c'frame\u003e {\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *const u8 {\n        self.0\n    }\n\n    /// Returns the length of the string.\n    pub fn len(self) -\u003e usize {\n        unsafe { *self.0.cast() }\n    }\n\n    /// Returns the string as a `CStr`.\n    pub fn as_c_str(self) -\u003e \u0026'frame CStr {\n        unsafe {\n            let str_begin = self.0.add(mem::size_of::\u003cusize\u003e());\n            CStr::from_ptr(str_begin.cast())\n        }\n    }\n\n    /// Returns the string as a slice of bytes without the terminating `\\0`.\n    pub fn as_slice(self) -\u003e \u0026'frame [u8] {\n        unsafe {\n            let str_begin = self.0.add(mem::size_of::\u003cusize\u003e());\n            slice::from_raw_parts(str_begin, self.len())\n        }\n    }\n\n    /// Returns the string as a string slice, or an error if it the string contains\n    /// invalid characters\n    pub fn as_str(self) -\u003e JlrsResult\u003c\u0026'frame str\u003e {\n        Ok(std::str::from_utf8(self.as_slice()).or(Err(JlrsError::NotUnicode))?)\n    }\n\n    /// Returns the string as a string slice without checking if the string is properly encoded.\n    pub unsafe fn as_str_unchecked(self) -\u003e \u0026'frame str {\n        std::str::from_utf8_unchecked(self.as_slice())\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for JuliaString\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { mem::transmute(self.ptr()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for JuliaString\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAString)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        std::mem::transmute(value)\n    }\n}\n\nimpl_julia_typecheck!(JuliaString\u003c'frame\u003e, jl_string_type, 'frame);\nimpl_julia_type!(JuliaString\u003c'frame\u003e, jl_string_type, 'frame);\nimpl_valid_layout!(JuliaString\u003c'frame\u003e, 'frame);\n","traces":[{"line":20,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":4377495,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":23},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","symbol.rs"],"content":"//! Symbols represent identifiers like module and function names.\n\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::global::Global;\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_sym_t, jl_symbol_n, jl_symbol_name, jl_symbol_type};\nuse std::ffi::CStr;\nuse std::fmt::{Debug, Formatter, Result as FmtResult};\nuse std::marker::PhantomData;\n\n/// `Symbol`s are used Julia to represent identifiers, `:x` represents the `Symbol` `x`. Things\n/// that can be accessed using a `Symbol` include submodules, functions, and globals. However,\n/// the methods that provide this functionality in `jlrs` can use strings instead.\n///\n/// This struct implements [`JuliaTypecheck`] and [`Cast`]. It can be used in combination with\n/// [`DataType::is`] and [`Value::is`]; if the check returns` true` the [`Value`] can be cast to\n/// `Symbol`:\n///\n/// ```\n/// # use jlrs::prelude::*;\n/// # use jlrs::util::JULIA;\n/// # fn main() {\n/// # JULIA.with(|j| {\n/// # let mut julia = j.borrow_mut();\n/// julia.frame(2, |global, frame| {\n///     let symbol_func = Module::core(global).function(\"Symbol\")?;\n///     let symbol_str = Value::new(frame, \"+\")?;\n///     let symbol_val = symbol_func.call1(frame, symbol_str)?.unwrap();\n///     assert!(symbol_val.is::\u003cSymbol\u003e());\n///\n///     let symbol = symbol_val.cast::\u003cSymbol\u003e()?;\n///     assert!(Module::base(global).function(symbol).is_ok());\n///     Ok(())\n/// }).unwrap();\n/// # });\n/// # }\n/// ```\n#[repr(transparent)]\n#[derive(Copy, Clone)]\npub struct Symbol\u003c'base\u003e(*mut jl_sym_t, PhantomData\u003c\u0026'base ()\u003e);\n\nimpl\u003c'base\u003e Symbol\u003c'base\u003e {\n    pub(crate) unsafe fn wrap(ptr: *mut jl_sym_t) -\u003e Self {\n        assert!(!ptr.is_null());\n        Symbol(ptr, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_sym_t {\n        self.0\n    }\n\n    /// Convert the given string to a `Symbol`.\n    pub fn new\u003cS: AsRef\u003cstr\u003e\u003e(global: Global\u003c'base\u003e, symbol: S) -\u003e Self {\n        Symbol::from((global, symbol))\n    }\n\n    /// Extend the `Symbol`'s lifetime. `Symbol`s are not garbage collected, but a `Symbol`\n    /// returned as a [`Value`] from a Julia function inherits the frame's lifetime when it's cast\n    /// to a `Symbol`. Its lifetime can be safely extended from `'frame` to `'global` using this\n    /// method.\n    pub fn extend\u003c'global\u003e(self, _: Global\u003c'global\u003e) -\u003e Symbol\u003c'global\u003e {\n        unsafe { Symbol::wrap(self.ptr()) }\n    }\n\n    /// The hash of this `Symbol`.\n    pub fn hash(self) -\u003e usize {\n        unsafe { (\u0026*self.ptr()).hash }\n    }\n\n    /// `Symbol`s are stored using an invasive binary tree, this returns the left branch of the\n    /// current node.\n    pub fn left(self) -\u003e Option\u003cSymbol\u003c'base\u003e\u003e {\n        unsafe {\n            let ref_self = \u0026*self.ptr();\n            if ref_self.left.is_null() {\n                return None;\n            }\n\n            Some(Symbol::wrap(ref_self.left))\n        }\n    }\n\n    /// `Symbol`s are stored using an invasive binary tree, this returns the right branch of the\n    /// current node.\n    pub fn right(self) -\u003e Option\u003cSymbol\u003c'base\u003e\u003e {\n        unsafe {\n            let ref_self = \u0026*self.ptr();\n            if ref_self.right.is_null() {\n                return None;\n            }\n\n            Some(Symbol::wrap(ref_self.right))\n        }\n    }\n}\n\nimpl\u003c'base\u003e Into\u003cString\u003e for Symbol\u003c'base\u003e {\n    fn into(self) -\u003e String {\n        unsafe {\n            let ptr = jl_symbol_name(self.ptr()).cast();\n            let symbol = CStr::from_ptr(ptr);\n            symbol.to_str().unwrap().into()\n        }\n    }\n}\n\nimpl\u003c'base\u003e Into\u003cValue\u003c'base, 'static\u003e\u003e for Symbol\u003c'base\u003e {\n    fn into(self) -\u003e Value\u003c'base, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nimpl\u003c'base, S\u003e From\u003c(Global\u003c'base\u003e, S)\u003e for Symbol\u003c'base\u003e\nwhere\n    S: AsRef\u003cstr\u003e,\n{\n    fn from((_, symbol): (Global\u003c'base\u003e, S)) -\u003e Self {\n        unsafe {\n            let symbol_str = symbol.as_ref();\n            let symbol_ptr = symbol_str.as_ptr();\n            let symbol = jl_symbol_n(symbol_ptr.cast(), symbol_str.as_bytes().len());\n            Symbol::wrap(symbol)\n        }\n    }\n}\n\nimpl\u003c'scope\u003e Debug for Symbol\u003c'scope\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e FmtResult {\n        unsafe {\n            let ptr = jl_symbol_name(self.ptr()).cast();\n            let symbol = CStr::from_ptr(ptr);\n            f.debug_tuple(\"Symbol\").field(\u0026symbol).finish()\n        }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for Symbol\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotASymbol)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(Symbol\u003c'frame\u003e, jl_symbol_type, 'frame);\nimpl_julia_type!(Symbol\u003c'frame\u003e, jl_symbol_type, 'frame);\nimpl_valid_layout!(Symbol\u003c'frame\u003e, 'frame);\n","traces":[{"line":45,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":47,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":51,"address":null,"length":0,"stats":{"Line":21},"fn_name":null},{"line":52,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":105,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":143,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":144,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":4318135,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":25,"coverable":43},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","task.rs"],"content":"//! Support for values with the `Core.Task` type.\n//!\n//! The documentation for this module has been slightly adapted from the comments for this struct\n//! in [`julia.h`]\n//!\n//! [`julia.h`]: https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/src/julia.h#L1727\nuse super::symbol::Symbol;\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_task_t, jl_task_type};\nuse std::marker::PhantomData;\n\n/// A Julia `Task` (coroutine).\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct Task\u003c'frame\u003e(*mut jl_task_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e Task\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(task: *mut jl_task_t) -\u003e Self {\n        Task(task, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_task_t {\n        self.0\n    }\n\n    /// Invasive linked list for scheduler\n    pub fn next(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let next = (\u0026*self.ptr()).next;\n            if next.is_null() {\n                None\n            } else {\n                Some(Value::wrap(next))\n            }\n        }\n    }\n\n    /// Invasive linked list for scheduler\n    pub fn queue(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let queue = (\u0026*self.ptr()).queue;\n            if queue.is_null() {\n                None\n            } else {\n                Some(Value::wrap(queue))\n            }\n        }\n    }\n\n    pub fn tls(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe {\n            let tls = (\u0026*self.ptr()).tls;\n            Value::wrap(tls)\n        }\n    }\n\n    pub fn state(self) -\u003e Symbol\u003c'frame\u003e {\n        unsafe {\n            let state = (\u0026*self.ptr()).state;\n            Symbol::wrap(state)\n        }\n    }\n\n    pub fn donenotify(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let donenotify = (\u0026*self.ptr()).donenotify;\n            if donenotify.is_null() {\n                None\n            } else {\n                Some(Value::wrap(donenotify))\n            }\n        }\n    }\n\n    pub fn result(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let result = (\u0026*self.ptr()).result;\n            if result.is_null() {\n                None\n            } else {\n                Some(Value::wrap(result))\n            }\n        }\n    }\n\n    pub fn exception(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let exception = (\u0026*self.ptr()).exception;\n            if exception.is_null() {\n                None\n            } else {\n                Some(Value::wrap(exception))\n            }\n        }\n    }\n\n    pub fn backtrace(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let backtrace = (\u0026*self.ptr()).backtrace;\n            if backtrace.is_null() {\n                None\n            } else {\n                Some(Value::wrap(backtrace))\n            }\n        }\n    }\n\n    pub fn logstate(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let logstate = (\u0026*self.ptr()).logstate;\n            if logstate.is_null() {\n                None\n            } else {\n                Some(Value::wrap(logstate))\n            }\n        }\n    }\n\n    pub fn start(self) -\u003e Option\u003cValue\u003c'frame, 'static\u003e\u003e {\n        unsafe {\n            let start = (\u0026*self.ptr()).start;\n            if start.is_null() {\n                None\n            } else {\n                Some(Value::wrap(start))\n            }\n        }\n    }\n\n    /// Record whether this Task can be migrated to a new thread\n    pub fn sticky(self) -\u003e u8 {\n        unsafe { (\u0026*self.ptr()).sticky }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for Task\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for Task\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotATask)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(Task\u003c'frame\u003e, jl_task_type, 'frame);\nimpl_julia_type!(Task\u003c'frame\u003e, jl_task_type, 'frame);\nimpl_valid_layout!(Task\u003c'frame\u003e, 'frame);\n","traces":[{"line":21,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":4246727,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":61},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","tuple.rs"],"content":"//! Generic `Tuple`s of different sizes.\n//!\n//! In this module generic tuple types from `Tuple0` up to and including `Tuple32` are available.\n//! These types can be use to work with tuple values from Julia. A new tuple can be created with\n//! `Value::new` if all fields implement the `IntoJulia` trait:\n//!\n//! ```\n//! # use jlrs::prelude::*;\n//! # use jlrs::util::JULIA;\n//! # fn main() {\n//! # JULIA.with(|j| {\n//! # let mut julia = j.borrow_mut();\n//! julia.frame(2, |global, frame| {\n//!     let tup = Tuple2(2i32, true);\n//!     let val = Value::new(frame, tup)?;\n//!     assert!(val.is::\u003cTuple2\u003ci32, bool\u003e\u003e());\n//!     assert!(val.cast::\u003cTuple2\u003ci32, bool\u003e\u003e().is_ok());\n//!     Ok(())\n//! }).unwrap();\n//! # });\n//! # }\n//! ```\n\nuse super::datatype::DataType;\nuse crate::traits::JuliaTypecheck;\nuse jl_sys::jl_tuple_typename;\n\n/// A typecheck that can be used in combination with `DataType::is`. This method returns true if\n/// a value of this type is a tuple.\npub struct Tuple;\n\nunsafe impl JuliaTypecheck for Tuple {\n    unsafe fn julia_typecheck(t: DataType) -\u003e bool {\n        (\u0026*t.ptr()).name == jl_tuple_typename\n    }\n}\n\nmacro_rules! count {\n    ($t:ident, $($x:ident),+) =\u003e {\n        1 + count!($($x),+)\n    };\n    ($t:ident) =\u003e {\n        1\n    };\n}\n\nmacro_rules! check {\n    ($fieldtypes:expr, $n:expr, $t:ident, $($x:ident),+) =\u003e {\n        \u003c$t\u003e::valid_layout($fieldtypes[$n - 1 - count!($($x),+)]) \u0026\u0026 check!($fieldtypes, $n, $($x),+)\n    };\n    ($fieldtypes:expr, $n:expr, $t:ident) =\u003e {\n        \u003c$t\u003e::valid_layout($fieldtypes[$n - 1])\n    };\n}\n\nmacro_rules! impl_tuple {\n    ($name:ident, $($types:tt),+) =\u003e {\n        #[repr(C)]\n        #[derive(Copy, Clone, Debug, PartialEq)]\n        pub struct $name\u003c$($types),+\u003e($(pub $types),+);\n\n        unsafe impl\u003c$($types),+\u003e $crate::traits::JuliaType for $name\u003c$($types),+\u003e where $($types: $crate::traits::JuliaType),+\n        {\n            unsafe fn julia_type() -\u003e *mut $crate::jl_sys_export::jl_datatype_t {\n                let types = \u0026mut [$(\u003c$types as $crate::traits::JuliaType\u003e::julia_type()),+];\n                $crate::jl_sys_export::jl_apply_tuple_type_v(types.as_mut_ptr().cast(), types.len())\n            }\n        }\n\n        unsafe impl\u003c$($types),+\u003e $crate::traits::IntoJulia for $name\u003c$($types),+\u003e  where $($types: $crate::traits::IntoJulia + $crate::traits::JuliaType + Copy),+\n        {\n            unsafe fn into_julia(\u0026self) -\u003e *mut $crate::jl_sys_export::jl_value_t {\n                let ty = \u003cSelf as $crate::traits::JuliaType\u003e::julia_type();\n                let tuple = $crate::jl_sys_export::jl_new_struct_uninit(ty.cast());\n                let data: *mut Self = tuple.cast();\n                ::std::ptr::write(data, *self);\n\n                tuple\n            }\n        }\n\n        unsafe impl\u003c$($types),+\u003e $crate::traits::ValidLayout for $name\u003c$($types),+\u003e  where $($types: $crate::traits::ValidLayout + Copy),+ {\n            unsafe fn valid_layout(v: $crate::value::Value) -\u003e bool {\n                if let Ok(dt) = v.cast::\u003c$crate::value::datatype::DataType\u003e() {\n                    let fieldtypes = dt.field_types();\n                    let n = count!($($types),+);\n                    if fieldtypes.len() != n {\n                        return false;\n                    }\n\n                    if !check!(fieldtypes, n, $($types),+) {\n                        return false\n                    }\n                }\n\n                true\n            }\n        }\n\n        unsafe impl\u003c'frame, 'data, $($types),+\u003e $crate::traits::Cast\u003c'frame, 'data\u003e for $name\u003c$($types),+\u003e  where $($types: $crate::traits::ValidLayout + Copy),+ {\n            type Output = Self;\n\n            fn cast(value: $crate::value::Value) -\u003e $crate::error::JlrsResult\u003cSelf::Output\u003e {\n                if value.is_nothing() {\n                    Err($crate::error::JlrsError::Nothing)?;\n                }\n\n                unsafe {\n                    if \u003cSelf::Output as $crate::traits::ValidLayout\u003e::valid_layout(value.datatype().unwrap().into()) {\n                        Ok(Self::cast_unchecked(value))\n                    } else {\n                        Err($crate::error::JlrsError::WrongType)?\n                    }\n                }\n            }\n\n            unsafe fn cast_unchecked(value: $crate::value::Value) -\u003e Self::Output {\n                *(value.ptr() as *mut Self::Output)\n            }\n        }\n\n        unsafe impl\u003c$($types),+\u003e $crate::traits::JuliaTypecheck for $name\u003c$($types),+\u003e where $($types: $crate::traits::JuliaType),+ {\n            unsafe fn julia_typecheck(t: $crate::value::datatype::DataType) -\u003e bool {\n                t.ptr() == \u003cSelf as $crate::traits::JuliaType\u003e::julia_type()\n            }\n        }\n    };\n    ($name:ident) =\u003e {\n        #[repr(C)]\n        #[derive(Copy, Clone, Debug)]\n        pub struct $name();\n\n        unsafe impl $crate::value::JuliaType for $name\n        {\n            unsafe fn julia_type() -\u003e *mut $crate::jl_sys_export::jl_datatype_t {\n                $crate::jl_sys_export::jl_emptytuple_type\n            }\n        }\n\n        unsafe impl $crate::value::IntoJulia for $name\n        {\n            unsafe fn into_julia(\u0026self) -\u003e *mut $crate::jl_sys_export::jl_value_t {\n                $crate::jl_sys_export::jl_emptytuple\n            }\n        }\n\n        unsafe impl $crate::traits::ValidLayout for $name {\n            unsafe fn valid_layout(v: $crate::value::Value) -\u003e bool {\n                if let Ok(dt) = v.cast::\u003c$crate::value::datatype::DataType\u003e() {\n                    if dt.is::\u003cSelf\u003e() {\n                        return true;\n                    }\n                }\n\n                true\n            }\n        }\n\n        unsafe impl\u003c'frame, 'data\u003e $crate::traits::Cast\u003c'frame, 'data\u003e for $name {\n            type Output = Self;\n\n            fn cast(value: $crate::value::Value) -\u003e $crate::error::JlrsResult\u003cSelf::Output\u003e {\n                if value.is_nothing() {\n                    Err($crate::error::JlrsError::Nothing)?;\n                }\n\n                unsafe {\n                    if \u003cSelf::Output as $crate::traits::ValidLayout\u003e::valid_layout(value.datatype().unwrap().into()) {\n                        Ok(Self::cast_unchecked(value))\n                    } else {\n                        Err($crate::error::JlrsError::WrongType)?\n                    }\n                }\n            }\n\n            unsafe fn cast_unchecked(value: $crate::value::Value) -\u003e Self::Output {\n                *(value.ptr() as *mut Self::Output)\n            }\n        }\n\n        unsafe impl $crate::traits::JuliaTypecheck for $name {\n            unsafe fn julia_typecheck(t: $crate::value::datatype::DataType) -\u003e bool {\n                t.ptr() == \u003cSelf as $crate::traits::JuliaType\u003e::julia_type()\n            }\n        }\n    };\n}\n\nimpl_tuple!(Tuple0);\nimpl_tuple!(Tuple1, T1);\nimpl_tuple!(Tuple2, T1, T2);\nimpl_tuple!(Tuple3, T1, T2, T3);\nimpl_tuple!(Tuple4, T1, T2, T3, T4);\nimpl_tuple!(Tuple5, T1, T2, T3, T4, T5);\nimpl_tuple!(Tuple6, T1, T2, T3, T4, T5, T6);\nimpl_tuple!(Tuple7, T1, T2, T3, T4, T5, T6, T7);\nimpl_tuple!(Tuple8, T1, T2, T3, T4, T5, T6, T7, T8);\nimpl_tuple!(Tuple9, T1, T2, T3, T4, T5, T6, T7, T8, T9);\nimpl_tuple!(Tuple10, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);\nimpl_tuple!(Tuple11, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);\nimpl_tuple!(Tuple12, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);\nimpl_tuple!(Tuple13, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);\nimpl_tuple!(Tuple14, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);\nimpl_tuple!(Tuple15, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);\nimpl_tuple!(Tuple16, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);\nimpl_tuple!(Tuple17, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);\nimpl_tuple!(\n    Tuple18, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18\n);\nimpl_tuple!(\n    Tuple19, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19\n);\nimpl_tuple!(\n    Tuple20, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20\n);\nimpl_tuple!(\n    Tuple21, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21\n);\nimpl_tuple!(\n    Tuple22, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22\n);\nimpl_tuple!(\n    Tuple23, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23\n);\nimpl_tuple!(\n    Tuple24, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23, T24\n);\nimpl_tuple!(\n    Tuple25, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23, T24, T25\n);\nimpl_tuple!(\n    Tuple26, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23, T24, T25, T26\n);\nimpl_tuple!(\n    Tuple27, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23, T24, T25, T26, T27\n);\nimpl_tuple!(\n    Tuple28, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23, T24, T25, T26, T27, T28\n);\nimpl_tuple!(\n    Tuple29, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23, T24, T25, T26, T27, T28, T29\n);\nimpl_tuple!(\n    Tuple30, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30\n);\nimpl_tuple!(\n    Tuple31, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31\n);\nimpl_tuple!(\n    Tuple32, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,\n    T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32\n);\n","traces":[{"line":33,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":34,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":4222755,"length":1,"stats":{"Line":5},"fn_name":null},{"line":43,"address":4221994,"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":4222819,"length":1,"stats":{"Line":5},"fn_name":null},{"line":52,"address":4222058,"length":1,"stats":{"Line":8},"fn_name":null},{"line":59,"address":4474352,"length":1,"stats":{"Line":4},"fn_name":"fmt\u003cjlrs_derive_tests::impls::WithGenericT\u003ci64\u003e\u003e"},{"line":60,"address":4474373,"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":4220640,"length":1,"stats":{"Line":3},"fn_name":"julia_type\u003cu64\u003e"},{"line":65,"address":4220644,"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":4220675,"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":4220512,"length":1,"stats":{"Line":3},"fn_name":"into_julia\u003cu64\u003e"},{"line":73,"address":4220526,"length":1,"stats":{"Line":3},"fn_name":null},{"line":74,"address":4220546,"length":1,"stats":{"Line":3},"fn_name":null},{"line":75,"address":4220583,"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":4220603,"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":4221872,"length":1,"stats":{"Line":8},"fn_name":"valid_layout\u003cu64\u003e"},{"line":84,"address":4221884,"length":1,"stats":{"Line":8},"fn_name":null},{"line":85,"address":4221940,"length":1,"stats":{"Line":8},"fn_name":null},{"line":87,"address":4222006,"length":1,"stats":{"Line":8},"fn_name":null},{"line":88,"address":4222088,"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":4222181,"length":1,"stats":{"Line":8},"fn_name":null},{"line":92,"address":4222189,"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":4222207,"length":1,"stats":{"Line":8},"fn_name":null},{"line":103,"address":4219472,"length":1,"stats":{"Line":6},"fn_name":"cast\u003cu64\u003e"},{"line":104,"address":4219495,"length":1,"stats":{"Line":6},"fn_name":null},{"line":105,"address":4219550,"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":4219897,"length":1,"stats":{"Line":6},"fn_name":null},{"line":110,"address":4220080,"length":1,"stats":{"Line":6},"fn_name":null},{"line":112,"address":4219984,"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":4219424,"length":1,"stats":{"Line":6},"fn_name":"cast_unchecked\u003cu64\u003e"},{"line":118,"address":4219433,"length":1,"stats":{"Line":6},"fn_name":null},{"line":123,"address":4222288,"length":1,"stats":{"Line":2},"fn_name":"julia_typecheck\u003cu64\u003e"},{"line":124,"address":4222297,"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":4315904,"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":135,"address":4314656,"length":1,"stats":{"Line":1},"fn_name":"julia_type"},{"line":136,"address":4314663,"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":4314672,"length":1,"stats":{"Line":1},"fn_name":"into_julia"},{"line":143,"address":4314684,"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":4314704,"length":1,"stats":{"Line":1},"fn_name":"valid_layout"},{"line":149,"address":4314713,"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":4314762,"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":4314800,"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":4314843,"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":4314864,"length":1,"stats":{"Line":1},"fn_name":"cast"},{"line":163,"address":4314884,"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":4314925,"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":4315280,"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":4315460,"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":4315364,"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":4315824,"length":1,"stats":{"Line":1},"fn_name":"cast_unchecked"},{"line":177,"address":4315829,"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":4315840,"length":1,"stats":{"Line":1},"fn_name":"julia_typecheck"},{"line":183,"address":4315849,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":46,"coverable":54},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","type_name.rs"],"content":"//! Support for values with the `Core.TypeName` type.\n//!\n//! The documentation for this module has been slightly adapted from the comments for this struct\n//! in [`julia.h`]\n//!\n//! [`julia.h`]: https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/src/julia.h#L380\n\nuse super::{\n    method_table::MethodTable, module::Module, simple_vector::SimpleVector, symbol::Symbol, Value,\n};\n\nuse super::array::Array;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_typename_t, jl_typename_type};\nuse std::marker::PhantomData;\n\n/// Describes the syntactic structure of a type and stores all data common to different\n/// instantiations of the type, including a cache for hash-consed allocation of `DataType`s.\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct TypeName\u003c'frame\u003e(*mut jl_typename_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e TypeName\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(typename: *mut jl_typename_t) -\u003e Self {\n        TypeName(typename, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_typename_t {\n        self.0\n    }\n\n    pub fn name(self) -\u003e Symbol\u003c'frame\u003e {\n        unsafe { Symbol::wrap((\u0026*self.ptr()).name) }\n    }\n\n    pub fn module(self) -\u003e Module\u003c'frame\u003e {\n        unsafe { Module::wrap((\u0026*self.ptr()).module) }\n    }\n\n    /// Field names.\n    pub fn names(self) -\u003e SimpleVector\u003c'frame\u003e {\n        unsafe { SimpleVector::wrap((\u0026*self.ptr()).names) }\n    }\n\n    /// Either the only instantiation of the type (if no parameters) or a `UnionAll` accepting\n    /// parameters to make an instantiation.\n    pub fn wrapper(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).wrapper) }\n    }\n\n    /// Sorted array.\n    pub fn cache(self) -\u003e SimpleVector\u003c'frame\u003e {\n        unsafe { SimpleVector::wrap((\u0026*self.ptr()).cache) }\n    }\n\n    /// Unsorted array.\n    pub fn linearcache(self) -\u003e SimpleVector\u003c'frame\u003e {\n        unsafe { SimpleVector::wrap((\u0026*self.ptr()).linearcache) }\n    }\n\n    pub fn hash(self) -\u003e isize {\n        unsafe { (\u0026*self.ptr()).hash }\n    }\n\n    pub fn mt(self) -\u003e MethodTable\u003c'frame\u003e {\n        unsafe { MethodTable::wrap((\u0026*self.ptr()).mt) }\n    }\n\n    /// Incomplete instantiations of this type.\n    pub fn partial(self) -\u003e Array\u003c'frame, 'static\u003e {\n        unsafe { Array::wrap((\u0026*self.ptr()).partial) }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for TypeName\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for TypeName\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotASymbol)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(TypeName\u003c'frame\u003e, jl_typename_type, 'frame);\nimpl_julia_type!(TypeName\u003c'frame\u003e, jl_typename_type, 'frame);\nimpl_valid_layout!(TypeName\u003c'frame\u003e, 'frame);\n","traces":[{"line":26,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":4407671,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":31},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","type_var.rs"],"content":"//! Support for values with the `Core.TypeVar` type.\n\nuse super::symbol::Symbol;\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_tvar_t, jl_tvar_type};\nuse std::marker::PhantomData;\n\n/// This is a unknown, but possibly restricted, type parameter. In `Array{T, N}`, `T` and `N` are\n/// `TypeVar`s.\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct TypeVar\u003c'frame\u003e(*mut jl_tvar_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e TypeVar\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(type_var: *mut jl_tvar_t) -\u003e Self {\n        TypeVar(type_var, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_tvar_t {\n        self.0\n    }\n\n    /// The name of this `TypeVar`.\n    pub fn name(self) -\u003e Symbol\u003c'frame\u003e {\n        unsafe { Symbol::wrap((\u0026*self.ptr()).name) }\n    }\n\n    /// The lower bound of this `TypeVar`.\n    pub fn lower_bound(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).lb) }\n    }\n\n    /// The upper bound of this `TypeVar`.\n    pub fn upper_bound(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).ub) }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for TypeVar\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for TypeVar\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotATypeVar)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(TypeVar\u003c'frame\u003e, jl_tvar_type, 'frame);\nimpl_julia_type!(TypeVar\u003c'frame\u003e, jl_tvar_type, 'frame);\nimpl_valid_layout!(TypeVar\u003c'frame\u003e, 'frame);\n","traces":[{"line":18,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":4284487,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","typemap_entry.rs"],"content":"//! Support for values with the `Core.TypeMapEntry` type.\n//!\n//! The documentation for this module has been slightly adapted from the comments for this struct\n//! in [`julia.h`]\n//!\n//! [`julia.h`]: https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/src/julia.h#505\n\nuse super::datatype::DataType;\nuse super::simple_vector::SimpleVector;\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_typemap_entry_t, jl_typemap_entry_type};\nuse std::marker::PhantomData;\n\n/// One Type-to-Value entry\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct TypeMapEntry\u003c'frame\u003e(*mut jl_typemap_entry_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e TypeMapEntry\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(typemap_entry: *mut jl_typemap_entry_t) -\u003e Self {\n        TypeMapEntry(typemap_entry, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_typemap_entry_t {\n        self.0\n    }\n\n    /// Invasive linked list\n    pub fn next(self) -\u003e Option\u003cSelf\u003e {\n        unsafe {\n            let next = (\u0026*self.ptr()).next;\n            if next.is_null() {\n                None\n            } else {\n                Some(TypeMapEntry::wrap(next))\n            }\n        }\n    }\n\n    /// The type signature for this entry\n    pub fn signature(self) -\u003e DataType\u003c'frame\u003e {\n        unsafe { DataType::wrap((\u0026*self.ptr()).sig) }\n    }\n\n    /// A simple signature for fast rejection\n    pub fn simple_signature(self) -\u003e DataType\u003c'frame\u003e {\n        unsafe { DataType::wrap((\u0026*self.ptr()).simplesig) }\n    }\n\n    pub fn guard_signature(self) -\u003e SimpleVector\u003c'frame\u003e {\n        unsafe { SimpleVector::wrap((\u0026*self.ptr()).guardsigs) }\n    }\n\n    pub fn min_world(self) -\u003e usize {\n        unsafe { (\u0026*self.ptr()).min_world }\n    }\n\n    pub fn max_world(self) -\u003e usize {\n        unsafe { (\u0026*self.ptr()).max_world }\n    }\n\n    pub fn func(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).func.value) }\n    }\n\n    /// `isleaftype(sig) \u0026 !any(isType, sig)` : unsorted and very fast\n    pub fn is_leaf_signature(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).isleafsig != 0 }\n    }\n\n    /// `all(isleaftype | isAny | isType | isVararg, sig)` : sorted and fast\n    pub fn is_simple_signature(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).issimplesig != 0 }\n    }\n\n    /// `isVararg(sig)`\n    pub fn is_vararg(self) -\u003e bool {\n        unsafe { (\u0026*self.ptr()).va != 0 }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for TypeMapEntry\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for TypeMapEntry\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotATypeMapEntry)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(TypeMapEntry\u003c'frame\u003e, jl_typemap_entry_type, 'frame);\nimpl_julia_type!(TypeMapEntry\u003c'frame\u003e, jl_typemap_entry_type, 'frame);\nimpl_valid_layout!(TypeMapEntry\u003c'frame\u003e, 'frame);\n","traces":[{"line":23,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":4248487,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":36},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","typemap_level.rs"],"content":"//! Support for values with the `Core.TypeMapLevel` type.\n//!\n//! The documentation for this module has been slightly adapted from the comments for this struct\n//! in [`julia.h`]\n//!\n//! [`julia.h`]: https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/src/julia.h#525\n\nuse super::array::Array;\nuse super::typemap_entry::TypeMapEntry;\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_typemap_level_t, jl_typemap_level_type};\nuse std::marker::PhantomData;\n\n/// One level in a TypeMap tree\n/// Indexed by key if it is a sublevel in an array\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct TypeMapLevel\u003c'frame\u003e(*mut jl_typemap_level_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e TypeMapLevel\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(typemap_level: *mut jl_typemap_level_t) -\u003e Self {\n        TypeMapLevel(typemap_level, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_typemap_level_t {\n        self.0\n    }\n\n    pub fn arg1(self) -\u003e Array\u003c'frame, 'static\u003e {\n        unsafe { Array::wrap((\u0026*self.ptr()).arg1) }\n    }\n\n    pub fn targ(self) -\u003e Array\u003c'frame, 'static\u003e {\n        unsafe { Array::wrap((\u0026*self.ptr()).targ) }\n    }\n\n    pub fn linear(self) -\u003e TypeMapEntry\u003c'frame\u003e {\n        unsafe { TypeMapEntry::wrap((\u0026*self.ptr()).linear) }\n    }\n\n    pub fn any(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).any) }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for TypeMapLevel\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for TypeMapLevel\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotATypeMapLevel)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(TypeMapLevel\u003c'frame\u003e, jl_typemap_level_type, 'frame);\nimpl_julia_type!(TypeMapLevel\u003c'frame\u003e, jl_typemap_level_type, 'frame);\nimpl_valid_layout!(TypeMapLevel\u003c'frame\u003e, 'frame);\n","traces":[{"line":24,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":4331255,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","union.rs"],"content":"//! Support for Julia `Union`s and union-fields.\n\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::{Align, BitsUnion as BU, Cast, Flag};\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_islayout_inline, jl_uniontype_t, jl_uniontype_type};\nuse std::marker::PhantomData;\n\n/// A struct field can have a type that's a union of several types. In this case, the type of this\n/// field is an instance of `Union`.\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct Union\u003c'frame\u003e(*mut jl_uniontype_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e Union\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(union: *mut jl_uniontype_t) -\u003e Self {\n        Union(union, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_uniontype_t {\n        self.0\n    }\n\n    /// Returns true if all the isbits union optimization applies to this union type.\n    pub fn isbitsunion(self) -\u003e bool {\n        unsafe {\n            let v: Value = self.into();\n            jl_islayout_inline(v.ptr(), \u0026mut 0, \u0026mut 0) != 0\n        }\n    }\n\n    /// Returns true if the isbits union optimization applies to this union type and calculates\n    /// the size and aligment if it does. If this method returns false, the calculated size and\n    /// alignment are invalid.\n    pub fn isbits_size_align(self, size: \u0026mut usize, align: \u0026mut usize) -\u003e bool {\n        unsafe {\n            let v: Value = self.into();\n            jl_islayout_inline(v.ptr(), size, align) != 0\n        }\n    }\n\n    /// Returns the size of a field that is of this `Union` type excluding the flag that is used\n    /// in bits unions.\n    pub fn size(self) -\u003e usize {\n        let mut sz = 0;\n        if !self.isbits_size_align(\u0026mut sz, \u0026mut 0) {\n            return std::mem::size_of::\u003cusize\u003e();\n        }\n\n        sz\n    }\n\n    /// Unions are stored as binary trees, the arguments are stored as its leaves. This method\n    /// returns one of its branches.\n    pub fn a(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).a) }\n    }\n\n    /// Unions are stored as binary trees, the arguments are stored as its leaves. This method\n    /// returns one of its branches.\n    pub fn b(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).b) }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for Union\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for Union\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAUnion)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(Union\u003c'frame\u003e, jl_uniontype_type, 'frame);\nimpl_julia_type!(Union\u003c'frame\u003e, jl_uniontype_type, 'frame);\nimpl_valid_layout!(Union\u003c'frame\u003e, 'frame);\n\n/// Ensures the next field is aligned to 1 byte.\n#[repr(C, align(1))]\n#[derive(Copy, Clone, Debug, PartialEq)]\npub struct Align1;\n\nunsafe impl Align for Align1 {\n    const ALIGNMENT: usize = 1;\n}\n\n/// Ensures the next field is aligned to 2 bytes.\n#[repr(C, align(2))]\n#[derive(Copy, Clone, Debug, PartialEq)]\npub struct Align2;\n\nunsafe impl Align for Align2 {\n    const ALIGNMENT: usize = 2;\n}\n\n/// Ensures the next field is aligned to 4 bytes.\n#[repr(C, align(4))]\n#[derive(Copy, Clone, Debug, PartialEq)]\npub struct Align4;\n\nunsafe impl Align for Align4 {\n    const ALIGNMENT: usize = 4;\n}\n\n/// Ensures the next field is aligned to 8 bytes.\n#[repr(C, align(8))]\n#[derive(Copy, Clone, Debug, PartialEq)]\npub struct Align8;\n\nunsafe impl Align for Align8 {\n    const ALIGNMENT: usize = 8;\n}\n\n/// Ensures the next field is aligned to 16 bytes.\n#[repr(C, align(16))]\n#[derive(Copy, Clone, Debug, PartialEq)]\npub struct Align16;\n\nunsafe impl Align for Align16 {\n    const ALIGNMENT: usize = 16;\n}\n\n/// When a `Union` is used as a field type in a struct, there are two possible representations.\n/// Which representation is chosen depends on its arguments.\n///\n/// In the general case the `Union` is simply represented as a `Value`. If all of the are isbits*\n/// types an inline representation is used. In this case, the value is essentially stored in an\n/// array of bytes that is large enough to contain the largest-sized value, followed by a single,\n/// byte-sized flag. This array has the same alignment as the value with the largest required\n/// alignment.\n///\n/// In order to take all of this into account, when mapping a Julia struct that has one of these\n/// optimized unions as a field, they are translated to three distinct fields. The first is a\n/// zero-sized type with a set alignment, the second a `BitsUnion`, and finally a `u8`. The\n/// generic parameter of `BitsUnion` must always be `[MaybeUninit\u003cu8\u003e; N]` with N explicitly equal\n/// to the size of the largest possible value. The previous, zero-sized, field ensures the\n/// `BitsUnion` is properly aligned, the flag indicates the type of the stored value.\n///\n/// Currently, even though a struct that contains an optimized union is supported by the\n/// `JuliaStruct` macro, these fields can't be used from Rust. If you want to access the value,\n/// you can use `Value::get_field` which will essentially convert it to the general representation.\n///\n/// *The types that are eligible for the optimization is actually not limited to just isbits\n/// types. In particular, a struct which contains an optimized union as a field is no longer an\n/// isbits type but the optimization still applies.\n#[repr(transparent)]\n#[derive(Copy, Clone, Debug)]\npub struct BitsUnion\u003cT\u003e(T);\n\nunsafe impl\u003cT\u003e BU for BitsUnion\u003cT\u003e {}\n\npub unsafe fn correct_layout_for\u003cA: Align, B: BU, F: Flag\u003e(u: Union) -\u003e bool {\n    let mut jl_sz = 0;\n    let mut jl_align = 0;\n    if !u.isbits_size_align(\u0026mut jl_sz, \u0026mut jl_align) {\n        return false;\n    }\n\n    A::ALIGNMENT == jl_align \u0026\u0026 std::mem::size_of::\u003cB\u003e() == jl_sz\n}\n","traces":[{"line":17,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":4332887,"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":4494992,"length":1,"stats":{"Line":2},"fn_name":"correct_layout_for\u003cjlrs::value::union::Align4,jlrs::value::union::BitsUnion\u003c[core::mem::maybe_uninit::MaybeUninit\u003cu8\u003e; 6]\u003e,u8\u003e"},{"line":168,"address":4495001,"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":4495010,"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":4495019,"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":4495063,"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":4495049,"length":1,"stats":{"Line":2},"fn_name":null}],"covered":21,"coverable":34},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","union_all.rs"],"content":"//! Support for values with the `Core.UnionAll` type.\n\nuse super::type_var::TypeVar;\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::value::datatype::DataType;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_unionall_t, jl_unionall_type};\nuse std::marker::PhantomData;\n\n/// An iterated union of types. If a struct field has a parametric type with some of its\n/// parameters unknown, its type is represented by a `UnionAll`.\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct UnionAll\u003c'frame\u003e(*mut jl_unionall_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e UnionAll\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(union_all: *mut jl_unionall_t) -\u003e Self {\n        UnionAll(union_all, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_unionall_t {\n        self.0\n    }\n\n    /// The type at the bottom of this `UnionAll`.\n    pub fn base_type(self) -\u003e DataType\u003c'frame\u003e {\n        let mut b = self;\n        while b.body().is::\u003cUnionAll\u003e() {\n            unsafe {\n                b = Value::from(b.body()).cast_unchecked::\u003cUnionAll\u003e();\n            }\n        }\n\n        Value::from(b.body()).cast::\u003cDataType\u003e().unwrap()\n    }\n\n    /// The body of this `UnionAll`. This is either another `UnionAll` or a `DataType`.\n    pub fn body(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).body) }\n    }\n\n    /// The type variable associated with this \"layer\" of the `UnionAll`.\n    pub fn var(self) -\u003e TypeVar\u003c'frame\u003e {\n        unsafe { TypeVar::wrap((\u0026*self.ptr()).var) }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for UnionAll\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for UnionAll\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAUnionAll)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(UnionAll\u003c'frame\u003e, jl_unionall_type, 'frame);\nimpl_julia_type!(UnionAll\u003c'frame\u003e, jl_unionall_type, 'frame);\nimpl_valid_layout!(UnionAll\u003c'frame\u003e, 'frame);\n","traces":[{"line":19,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":20,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":4337687,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":22},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value","weak_ref.rs"],"content":"//! Support for values with the `Core.WeakRef` type.\n\nuse super::Value;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::traits::Cast;\nuse crate::{impl_julia_type, impl_julia_typecheck, impl_valid_layout};\nuse jl_sys::{jl_weakref_t, jl_weakref_type};\nuse std::marker::PhantomData;\n\n/// A weak reference.\n#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n#[repr(transparent)]\npub struct WeakRef\u003c'frame\u003e(*mut jl_weakref_t, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e WeakRef\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(weak_ref: *mut jl_weakref_t) -\u003e Self {\n        WeakRef(weak_ref, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_weakref_t {\n        self.0\n    }\n\n    /// The referenced `Value`.\n    pub fn value(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap((\u0026*self.ptr()).value) }\n    }\n}\n\nimpl\u003c'frame\u003e Into\u003cValue\u003c'frame, 'static\u003e\u003e for WeakRef\u003c'frame\u003e {\n    fn into(self) -\u003e Value\u003c'frame, 'static\u003e {\n        unsafe { Value::wrap(self.ptr().cast()) }\n    }\n}\n\nunsafe impl\u003c'frame, 'data\u003e Cast\u003c'frame, 'data\u003e for WeakRef\u003c'frame\u003e {\n    type Output = Self;\n    fn cast(value: Value\u003c'frame, 'data\u003e) -\u003e JlrsResult\u003cSelf::Output\u003e {\n        if value.is::\u003cSelf::Output\u003e() {\n            return unsafe { Ok(Self::cast_unchecked(value)) };\n        }\n\n        Err(JlrsError::NotAWeakRef)?\n    }\n\n    unsafe fn cast_unchecked(value: Value\u003c'frame, 'data\u003e) -\u003e Self::Output {\n        Self::wrap(value.ptr().cast())\n    }\n}\n\nimpl_julia_typecheck!(WeakRef\u003c'frame\u003e, jl_weakref_type, 'frame);\nimpl_julia_type!(WeakRef\u003c'frame\u003e, jl_weakref_type, 'frame);\nimpl_valid_layout!(WeakRef\u003c'frame\u003e, 'frame);\n","traces":[{"line":16,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":4390519,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":15},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","src","value.rs"],"content":"//! Julia values and functions.\n//!\n//! When using this crate Julia data will usually be returned as a [`Value`]. A [`Value`] is a\n//! \"generic\" wrapper. Type information will generally be available allowing you to safely convert\n//! a [`Value`] to its actual type. Data like arrays and modules can be returned as a [`Value`].\n//! These, and other types with a custom implementation in the C API, can be found in the\n//! submodules of this module.\n//!\n//! One special property of a [`Value`] is that it can always be called as a function; there's no\n//! way to check if a [`Value`] is actually a function except trying to call it. Multiple\n//! [`Value`]s can be created at the same time by using [`Values`].\n//!\n//! [`Value`]: struct.Value.html\n//! [`Values`]: struct.Values.html\n\nuse self::array::{Array, Dimensions};\nuse self::datatype::DataType;\nuse self::module::Module;\nuse self::symbol::Symbol;\nuse crate::error::{JlrsError, JlrsResult};\nuse crate::frame::Output;\nuse crate::global::Global;\nuse crate::impl_julia_type;\nuse crate::traits::{\n    private::Internal, Cast, Frame, IntoJulia, JuliaType, JuliaTypecheck, TemporarySymbol,\n    ValidLayout,\n};\nuse jl_sys::{\n    jl_alloc_array_1d, jl_alloc_array_2d, jl_alloc_array_3d, jl_any_type, jl_apply_array_type,\n    jl_apply_tuple_type_v, jl_call, jl_call0, jl_call1, jl_call2, jl_call3, jl_datatype_t,\n    jl_exception_occurred, jl_field_index, jl_field_isptr, jl_field_names, jl_fieldref,\n    jl_fieldref_noalloc, jl_get_nth_field, jl_get_nth_field_noalloc, jl_new_array,\n    jl_new_struct_uninit, jl_nfields, jl_ptr_to_array, jl_ptr_to_array_1d, jl_svec_data,\n    jl_svec_len, jl_typeof, jl_typeof_str, jl_value_t,\n};\nuse std::borrow::BorrowMut;\nuse std::ffi::CStr;\nuse std::fmt::{Debug, Formatter, Result as FmtResult};\nuse std::marker::PhantomData;\nuse std::ptr::null_mut;\nuse std::slice;\n\npub mod array;\npub mod code_instance;\npub mod datatype;\npub mod expr;\npub mod method;\npub mod method_instance;\npub mod method_table;\npub mod module;\npub mod simple_vector;\npub mod string;\npub mod symbol;\npub mod task;\npub mod tuple;\npub mod type_name;\npub mod type_var;\npub mod typemap_entry;\npub mod typemap_level;\npub mod union;\npub mod union_all;\npub mod weak_ref;\n\nthread_local! {\n    // Used as a pool to convert dimensions to tuples. Safe because a thread local is initialized\n    // when `with` is first called, which happens after `Julia::init` has been called. The C API\n    // requires a mutable pointer to this array so an `UnsafeCell` is used to store it.\n    static JL_LONG_TYPE: std::cell::UnsafeCell\u003c[*mut jl_datatype_t; 8]\u003e = unsafe {\n        std::cell::UnsafeCell::new([\n            usize::julia_type(),\n            usize::julia_type(),\n            usize::julia_type(),\n            usize::julia_type(),\n            usize::julia_type(),\n            usize::julia_type(),\n            usize::julia_type(),\n            usize::julia_type(),\n        ])\n    };\n}\n\n/// This type alias is used to encode the result of a function call: `Ok` indicates the call was\n/// successful and contains the function's result, while `Err` indicates an exception was thrown\n/// and contains said exception.\npub type CallResult\u003c'frame, 'data\u003e = Result\u003cValue\u003c'frame, 'data\u003e, Value\u003c'frame, 'data\u003e\u003e;\n\n/// Several values that are allocated consecutively. This can be used in combination with\n/// [`Value::call_values`] and [`WithOutput::call_values`].\n///\n/// [`Value::call_values`]: struct.Value.html#method.call_values\n/// [`WithOutput::call_values`]: struct.WithOutput.html#method.call_values\n#[derive(Copy, Clone, Debug)]\npub struct Values\u003c'frame\u003e(*mut *mut jl_value_t, usize, PhantomData\u003c\u0026'frame ()\u003e);\n\nimpl\u003c'frame\u003e Values\u003c'frame\u003e {\n    pub(crate) unsafe fn wrap(ptr: *mut *mut jl_value_t, n: usize) -\u003e Self {\n        Values(ptr, n, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut *mut jl_value_t {\n        self.0\n    }\n\n    /// Returns the number of `Value`s in this group.\n    pub fn len(self) -\u003e usize {\n        self.1\n    }\n\n    /// Get a specific `Value` in this group. Returns an error if the index is out of bounds.\n    pub fn value(self, index: usize) -\u003e JlrsResult\u003cValue\u003c'frame, 'static\u003e\u003e {\n        if index \u003e= self.len() {\n            return Err(JlrsError::OutOfBounds(index, self.len()).into());\n        }\n\n        unsafe { Ok(Value(*(self.ptr().add(index)), PhantomData, PhantomData)) }\n    }\n\n    /// Allocate several values of the same type, this type must implement [`IntoJulia`]. The\n    /// values will be protected from garbage collection inside the frame used to create them.\n    /// This takes as many slots on the GC stack as values that are allocated.\n    ///\n    /// Returns an error if there is not enough space on the stack.\n    ///\n    /// [`IntoJulia`]: ../traits/trait.IntoJulia.html\n    pub fn new\u003cT, V, F\u003e(frame: \u0026mut F, data: V) -\u003e JlrsResult\u003cSelf\u003e\n    where\n        T: IntoJulia,\n        V: AsRef\u003c[T]\u003e,\n        F: Frame\u003c'frame\u003e,\n    {\n        frame\n            .create_many(data.as_ref(), Internal)\n            .map_err(Into::into)\n    }\n\n    /// Allocate several values of possibly different types, these types must implement\n    /// [`IntoJulia`]. The values will be protected from garbage collection inside the frame used\n    /// to create them. This takes as many slots on the GC stack as values that are allocated.\n    ///\n    /// Returns an error if there is not enough space on the stack.\n    ///\n    /// [`IntoJulia`]: ../traits/trait.IntoJulia.html\n    pub fn new_dyn\u003c'v, V, F\u003e(frame: \u0026mut F, data: V) -\u003e JlrsResult\u003cSelf\u003e\n    where\n        V: AsRef\u003c[\u0026'v dyn IntoJulia]\u003e,\n        F: Frame\u003c'frame\u003e,\n    {\n        frame\n            .create_many_dyn(data.as_ref(), Internal)\n            .map_err(Into::into)\n    }\n}\n\n/// When working with the Julia C API most data is returned as a raw pointer to a `jl_value_t`.\n/// This pointer is similar to a void pointer in the sense that this pointer can point to data of\n/// any type. It's up to the user to determine the correct type and cast the pointer. In order to\n/// make this possible, data pointed to by a `jl_value_t`-pointer is guaranteed to be preceded in\n/// memory by a fixed-size header that contains its type and layout-information.\n///\n/// A `Value` is a wrapper around the raw pointer to a `jl_value_t` that adds two lifetimes,\n/// `'frame` and `'data`. The first is inherited from the frame used to create the `Value`; frames\n/// ensure a `Value` is protected from garbage collection as long as the frame used to protect it\n/// has not been dropped. As a result, a `Value` can only be used when it can be guaranteed that\n/// the garbage collector won't drop it. The second indicates the lifetime of its contents; it's\n/// usually `'static`, but if you create a `Value` that borrows array data from Rust it's the\n/// lifetime of the borrow. If you call a Julia function the returned `Value` will inherit the\n/// `'data`-lifetime of the `Value`s used as arguments. This ensures that a `Value` that\n/// (possibly) borrows data from Rust can't be used after that borrow ends. If this restriction is\n/// too strict you can forget the second lifetime by calling [`Value::assume_owned`].\n///\n/// ### Creating new values\n///\n/// New `Value`s can be created from Rust in several ways. Types that implement [`IntoJulia`] can\n/// be converted to a `Value` by calling [`Value::new`]. This trait is implemented by primitive\n/// types like `bool`, `char`, `i16`, and `usize`; string types like `String`, `\u0026str`, and `Cow`;\n/// [`tuples`]; and you can derive it for your own types by deriving [`IntoJulia`]. You should\n/// use `JlrsReflect.jl` rather than doing this manually.\n///\n/// [`Value`] also has several methods to create an n-dimensional array if the element type\n/// implements [`IntoJulia`], this includes primitive types, strings. It is also implemented for\n/// bits types with no type parameters when these bindings are generated with `JlrsReflect.jl`. A\n/// new array whose data is completely managed by Julia can be created by calling\n/// [`Value::new_array`]. You can also transfer the ownership of some `Vec` to Julia and treat it\n/// as an n-dimensional array with [`Value::move_array`]. Finally, you can borrow anything that\n/// can be borrowed as a mutable slice with [`Value::borrow_array`].\n///\n/// Functions and other global values defined in a module can be accessed through that module.\n/// Please see the documentation for [`Module`] for more information.\n///\n/// ### Casting values\n///\n/// A `Value`'s type information can be accessed by calling [`Value::datatype`], this is usually\n/// not necessary to determine what kind of data it contains; you can use [`Value::is`] to query\n/// properties of the value's type. You can use [`Value::cast`] to convert the value to the\n/// appropriate type. If a type implements both [`JuliaTypecheck`] and [`Cast`], which are used by\n/// [`Value::is`] and [`Value::cast`] respectively, the former returning `true` when called with\n/// that type as generic parameter indicates that the latter will succeed. For example,\n/// `value.is::\u003cu8\u003e()` returning true means `value.cast::\u003cu8\u003e()` will succeed. You can derive\n/// these traits for custom structs by deriving [`JuliaStruct`].\n///\n/// The methods that create a new `Value` come in two varieties: `\u003cmethod\u003e` and `\u003cmethod\u003e_output`.\n/// The first will use a slot in the current frame to protect the value from garbage collection,\n/// while the latter uses a slot in another active frame.\n///\n/// [`Value::assume_owned`]: struct.Value.html#method.assume_owned\n/// [`Value`]: struct.Value.html\n/// [`Value::move_array`]: struct.Value.html#method.move_array\n/// [`Value::new_array`]: struct.Value.html#method.new_array\n/// [`Value::borrow_array`]: struct.Value.html#method.borrow_array\n/// [`IntoJulia`]: ../traits/trait.IntoJulia.html\n/// [`JuliaType`]: ../traits/trait.JuliaType.html\n/// [`Value::new`]: struct.Value.html#method.new\n/// [`Value::datatype`]: struct.Value.html#method.datatype\n/// [`JuliaStruct`]: ../traits/trait.JuliaStruct.html\n/// [`tuples`]: ./tuple/index.html\n/// [`Module`]: ./module/struct.Module.html\n/// [`Value::datatype`]: struct.Value.html#method.datatype\n/// [`Value::is`]: struct.Value.html#method.is\n/// [`Value::cast`]: struct.Value.html#method.cast\n/// [`JuliaTypecheck`]: ../traits/trait.JuliaTypecheck.html\n/// [`Cast`]: ../traits/trait.Cast.html\n#[repr(transparent)]\n#[derive(Copy, Clone)]\npub struct Value\u003c'frame, 'data\u003e(\n    *mut jl_value_t,\n    PhantomData\u003c\u0026'frame ()\u003e,\n    PhantomData\u003c\u0026'data ()\u003e,\n);\n\nimpl\u003c'frame, 'data\u003e Value\u003c'frame, 'data\u003e {\n    pub(crate) unsafe fn wrap(ptr: *mut jl_value_t) -\u003e Value\u003c'frame, 'static\u003e {\n        Value(ptr, PhantomData, PhantomData)\n    }\n\n    #[doc(hidden)]\n    pub unsafe fn ptr(self) -\u003e *mut jl_value_t {\n        self.0\n    }\n\n    /// Returns `nothing` as a `Value`. Because `nothing` is a singleton this takes no slot on the\n    /// GC stack.\n    pub fn nothing\u003cF\u003e(_frame: \u0026mut F) -\u003e Value\u003c'frame, 'static\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe { Value::wrap(jl_sys::jl_nothing) }\n    }\n\n    /// Create a new Julia value, any type that implements [`IntoJulia`] can be converted using\n    /// this function. The value will be protected from garbage collection inside the frame used\n    /// to create it. One free slot on the GC stack is required for this function to succeed,\n    /// returns an error if no slot is available.\n    ///\n    /// [`IntoJulia`]: ../traits/trait.IntoJulia.html\n    pub fn new\u003cV, F\u003e(frame: \u0026mut F, value: V) -\u003e JlrsResult\u003cValue\u003c'frame, 'static\u003e\u003e\n    where\n        V: IntoJulia,\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            frame\n                .protect(value.into_julia(), Internal)\n                .map_err(Into::into)\n        }\n    }\n\n    /// Create a new Julia value using the output to protect it from garbage collection, any type\n    /// that implements [`IntoJulia`] can be converted using this function. The value will be\n    /// protected from garbage collection until the frame the output belongs to goes out of scope.\n    ///\n    /// [`IntoJulia`]: ../traits/trait.IntoJulia.html\n    pub fn new_output\u003c'output, V, F\u003e(\n        frame: \u0026mut F,\n        output: Output\u003c'output\u003e,\n        value: V,\n    ) -\u003e Value\u003c'output, 'static\u003e\n    where\n        V: IntoJulia,\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe { frame.assign_output(output, value.into_julia(), Internal) }\n    }\n\n    /// Returns true if the value is `nothing`.\n    pub fn is_nothing(self) -\u003e bool {\n        unsafe {\n            self.ptr() == null_mut() || jl_typeof(self.ptr()) == jl_sys::jl_nothing_type.cast()\n        }\n    }\n\n    /// Performs the given type check. For types that represent Julia data, this check comes down\n    /// to checking if the data has that type. This works for primitive types, for example:\n    ///\n    /// ```no_run\n    /// # use jlrs::prelude::*;\n    /// # fn main() {\n    /// # let mut julia = unsafe { Julia::init(16).unwrap() };\n    /// julia.frame(1, |_global, frame| {\n    ///     let i = Value::new(frame, 2u64)?;\n    ///     assert!(i.is::\u003cu64\u003e());\n    ///     Ok(())\n    /// }).unwrap();\n    /// # }\n    /// ```\n    ///\n    /// \"Special\" types in Julia that are defined in C, like [`Array`], [`Module`] and\n    /// [`DataType`], are also supported:\n    ///\n    /// ```no_run\n    /// # use jlrs::prelude::*;\n    /// # fn main() {\n    /// # let mut julia = unsafe { Julia::init(16).unwrap() };\n    /// julia.frame(1, |_global, frame| {\n    ///     let arr = Value::new_array::\u003cf64, _, _\u003e(frame, (3, 3))?;\n    ///     assert!(arr.is::\u003cArray\u003e());\n    ///     Ok(())\n    /// }).unwrap();\n    /// # }\n    /// ```\n    ///\n    /// If you derive [`JuliaStruct`] for some type, that type will be supported by this method. A\n    /// full list of supported checks can be found [here].\n    ///\n    /// [`Array`]: array/struct.Array.html\n    /// [`DataType`]: datatype/struct.DataType.html\n    /// [`Module`]: module/struct.Module.html\n    /// [`Symbol`]: symbol/struct.Symbol.html\n    /// [`JuliaStruct`]: ../traits/trait.JuliaStruct.html\n    /// [here]: ../traits/trait.JuliaTypecheck.html#implementors\n    pub fn is\u003cT: JuliaTypecheck\u003e(self) -\u003e bool {\n        if self.is_nothing() {\n            return false;\n        }\n\n        self.datatype().unwrap().is::\u003cT\u003e()\n    }\n\n    /// Returns the `DataType` of this value, or `None` if the value constains a null pointer.\n    pub fn datatype(self) -\u003e Option\u003cDataType\u003c'frame\u003e\u003e {\n        unsafe {\n            if self.ptr().is_null() {\n                return None;\n            }\n\n            Some(DataType::wrap(jl_typeof(self.ptr()).cast()))\n        }\n    }\n\n    /// Cast the contents of this value into a compatible Rust type. Any type which implements\n    /// `Cast` can be used as a target, by default this includes primitive types like `u8`, `f32`\n    /// and `bool`, and builtin types like [`Array`], [`JuliaString`] and [`Symbol`]. You can\n    /// implement this trait for custom types by deriving [`JuliaStruct`].\n    ///\n    /// [`Array`]: array/struct.Array.html\n    /// [`JuliaString`]: string/struct.JuliaString.html\n    /// [`Symbol`]: symbol/struct.Symbol.html\n    /// [`JuliaStruct`]: ../traits/trait.JuliaStruct.html\n    pub fn cast\u003cT: Cast\u003c'frame, 'data\u003e\u003e(self) -\u003e JlrsResult\u003c\u003cT as Cast\u003c'frame, 'data\u003e\u003e::Output\u003e {\n        T::cast(self)\n    }\n\n    /// Cast the contents of this value into a compatible Rust type without checking if the layout is valid.\n    ///\n    /// Safety:\n    ///\n    /// You must guarantee `self.is::\u003cT\u003e()` would have returned `true`.\n    pub unsafe fn cast_unchecked\u003cT: Cast\u003c'frame, 'data\u003e\u003e(\n        self,\n    ) -\u003e \u003cT as Cast\u003c'frame, 'data\u003e\u003e::Output {\n        T::cast_unchecked(self)\n    }\n\n    /// Returns the type name of this value.\n    pub fn type_name(self) -\u003e \u0026'frame str {\n        unsafe {\n            if self.ptr().is_null() {\n                return \"null\";\n            }\n            let type_name = jl_typeof_str(self.ptr());\n            let type_name_ref = CStr::from_ptr(type_name);\n            type_name_ref.to_str().unwrap()\n        }\n    }\n\n    /// Returns true if the value is an array with elements of type `T`.\n    pub fn is_array_of\u003cT: ValidLayout\u003e(self) -\u003e bool {\n        match self.cast::\u003cArray\u003e() {\n            Ok(arr) =\u003e arr.contains::\u003cT\u003e(),\n            Err(_) =\u003e false,\n        }\n    }\n\n    /// Returns the field names of this value as a slice of `Symbol`s. These symbols can be used\n    /// to access their fields with [`Value::get_field`].\n    ///\n    /// [`Value::get_field`]: struct.Value.html#method.get_field\n    pub fn field_names(self) -\u003e \u0026'frame [Symbol\u003c'frame\u003e] {\n        if self.is_nothing() {\n            return \u0026[];\n        }\n\n        unsafe {\n            let tp = jl_typeof(self.ptr());\n            let field_names = jl_field_names(tp.cast());\n            let len = jl_svec_len(field_names);\n            let items: *mut Symbol = jl_svec_data(field_names).cast();\n            slice::from_raw_parts(items.cast(), len)\n        }\n    }\n\n    /// Returns the number of fields the underlying Julia value has. These fields can be accessed\n    /// with [`Value::get_field_n`].\n    ///\n    /// [`Value::get_field_n`]: struct.Value.html#method.get_field_n\n    pub fn n_fields(self) -\u003e usize {\n        if self.is_nothing() {\n            return 0;\n        }\n\n        unsafe { jl_nfields(self.ptr()) as _ }\n    }\n\n    /// Returns the field at index `idx` if it exists. If it does not exist\n    /// `JlrsError::OutOfBounds` is returned. This function assumes the field must be protected\n    /// from garbage collection, so calling this function will take a single slot on the GC stack.\n    /// If there is no slot available `JlrsError::AllocError` is returned.\n    pub fn get_nth_field\u003c'fr, F\u003e(self, frame: \u0026mut F, idx: usize) -\u003e JlrsResult\u003cValue\u003c'fr, 'data\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            if idx \u003e= self.n_fields() {\n                return Err(JlrsError::OutOfBounds(idx, self.n_fields()).into());\n            }\n\n            frame\n                .protect(jl_fieldref(self.ptr(), idx), Internal)\n                .map_err(Into::into)\n        }\n    }\n\n    /// Returns the field at index `idx` if it exists. If it does not exist\n    /// `JlrsError::OutOfBounds` is returned. This function assumes the field must be protected\n    /// from garbage collection and uses the provided output to do so.\n    pub fn get_nth_field_output\u003c'output, 'fr, F\u003e(\n        self,\n        frame: \u0026mut F,\n        output: Output\u003c'output\u003e,\n        idx: usize,\n    ) -\u003e JlrsResult\u003cValue\u003c'output, 'data\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            if idx \u003e= self.n_fields() {\n                return Err(JlrsError::OutOfBounds(idx, self.n_fields()).into());\n            }\n\n            Ok(frame.assign_output(output, jl_fieldref(self.ptr(), idx), Internal))\n        }\n    }\n\n    /// Returns the field at index `idx` if it exists and no allocation is required to return it.\n    /// Allocation is not required if the field is a pointer to another value.\n    ///\n    /// If the field does not exist `JlrsError::NoSuchField` is returned. If allocating is\n    /// required to return the field, `JlrsError::NotAPointerField` is returned.\n    ///\n    /// This function is unsafe because the value returned as a result will only be valid as long\n    /// as the field is not changed.\n    pub unsafe fn get_nth_field_noalloc(self, idx: usize) -\u003e JlrsResult\u003cValue\u003c'frame, 'data\u003e\u003e {\n        if self.is_nothing() {\n            Err(JlrsError::Nothing)?;\n        }\n\n        if idx \u003e= self.n_fields() {\n            Err(JlrsError::OutOfBounds(idx, self.n_fields()))?\n        }\n\n        if !jl_field_isptr(self.datatype().unwrap().ptr(), idx as _) {\n            Err(JlrsError::NotAPointerField(idx))?;\n        }\n\n        Ok(Value::wrap(jl_fieldref_noalloc(self.ptr(), idx)))\n    }\n\n    /// Returns the field with the name `field_name` if it exists. If it does not exist\n    /// `JlrsError::NoSuchField` is returned. This function assumes the field must be protected\n    /// from garbage collection, so calling this function will take a single slot on the GC stack.\n    /// If there is no slot available `JlrsError::AllocError` is returned.\n    pub fn get_field\u003c'fr, N, F\u003e(self, frame: \u0026mut F, field_name: N) -\u003e JlrsResult\u003cValue\u003c'fr, 'data\u003e\u003e\n    where\n        N: TemporarySymbol,\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let symbol = field_name.temporary_symbol(Internal);\n\n            if self.is_nothing() {\n                Err(JlrsError::Nothing)?;\n            }\n\n            let jl_type = jl_typeof(self.ptr()).cast();\n            let idx = jl_field_index(jl_type, symbol.ptr(), 0);\n\n            if idx \u003c 0 {\n                return Err(JlrsError::NoSuchField(symbol.into()).into());\n            }\n\n            frame\n                .protect(jl_get_nth_field(self.ptr(), idx as _), Internal)\n                .map_err(Into::into)\n        }\n    }\n\n    /// Returns the field with the name `field_name` if it exists. If it does not exist\n    /// `JlrsError::NoSuchField` is returned. This function assumes the field must be protected\n    /// from garbage collection and uses the provided output to do so.\n    pub fn get_field_output\u003c'output, 'fr, N, F\u003e(\n        self,\n        frame: \u0026mut F,\n        output: Output\u003c'output\u003e,\n        field_name: N,\n    ) -\u003e JlrsResult\u003cValue\u003c'output, 'data\u003e\u003e\n    where\n        N: TemporarySymbol,\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let symbol = field_name.temporary_symbol(Internal);\n\n            if self.is_nothing() {\n                Err(JlrsError::Nothing)?;\n            }\n\n            let jl_type = jl_typeof(self.ptr()).cast();\n            let idx = jl_field_index(jl_type, symbol.ptr(), 0);\n\n            if idx \u003c 0 {\n                return Err(JlrsError::NoSuchField(symbol.into()).into());\n            }\n\n            Ok(frame.assign_output(output, jl_get_nth_field(self.ptr(), idx as _), Internal))\n        }\n    }\n\n    /// Returns the field with the name `field_name` if it exists and no allocation is required\n    /// to return it. Allocation is not required if the field is a pointer to another value.\n    ///\n    /// If the field does not exist `JlrsError::NoSuchField` is returned. If allocating is\n    /// required to return the field, `JlrsError::NotAPointerField` is returned.\n    ///\n    /// This function is unsafe because the value returned as a result will only be valid as long\n    /// as the field is not changed.\n    pub unsafe fn get_field_noalloc\u003cN\u003e(self, field_name: N) -\u003e JlrsResult\u003cValue\u003c'frame, 'data\u003e\u003e\n    where\n        N: TemporarySymbol,\n    {\n        let symbol = field_name.temporary_symbol(Internal);\n\n        if self.is_nothing() {\n            Err(JlrsError::Nothing)?;\n        }\n\n        let jl_type = jl_typeof(self.ptr()).cast();\n        let idx = jl_field_index(jl_type, symbol.ptr(), 0);\n\n        if idx \u003c 0 {\n            return Err(JlrsError::NoSuchField(symbol.into()).into());\n        }\n\n        if !jl_field_isptr(self.datatype().unwrap().ptr(), idx) {\n            Err(JlrsError::NotAPointerField(idx as _))?;\n        }\n\n        Ok(Value::wrap(jl_get_nth_field_noalloc(self.ptr(), idx as _)))\n    }\n\n    /// If you call a function with one or more borrowed arrays as arguments, its result can only\n    /// be used when all the borrows are active. If this result doesn't reference any borrowed\n    /// data this function can be used to relax its second lifetime to `'static`.\n    ///\n    /// Safety: The value must not contain a reference any borrowed data.\n    pub unsafe fn assume_owned(self) -\u003e Value\u003c'frame, 'static\u003e {\n        Value::wrap(self.ptr())\n    }\n\n    /// Extend the `Value`'s lifetime to the `Output's lifetime. The original value will still be\n    /// valid after calling this method, the data will be protected from garbage collection until\n    /// the `Output`'s frame goes out of scope.\n    pub fn extend\u003c'output, F\u003e(self, frame: \u0026mut F, output: Output\u003c'output\u003e) -\u003e Value\u003c'output, 'data\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe { frame.assign_output(output, self.ptr().cast(), Internal) }\n    }\n\n    /// Allocates a new n-dimensional array in Julia.\n    ///\n    /// Creating an an array with 1, 2 or 3 dimensions requires one slot on the GC stack. If you\n    /// create an array with more dimensions an extra frame is created with a single slot,\n    /// temporarily taking 3 additional slots.\n    ///\n    /// This function returns an error if there are not enough slots available.\n    pub fn new_array\u003cT, D, F\u003e(frame: \u0026mut F, dimensions: D) -\u003e JlrsResult\u003cValue\u003c'frame, 'static\u003e\u003e\n    where\n        T: IntoJulia + JuliaType,\n        D: Into\u003cDimensions\u003e,\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let array = new_array::\u003cT, _, _\u003e(frame, dimensions)?;\n            frame.protect(array, Internal).map_err(Into::into)\n        }\n    }\n\n    /// Allocates a new n-dimensional array in Julia using an `Output`.\n    ///\n    /// Because an `Output` is used, no additional slot in the current frame is used if you create\n    /// an array with 1, 2 or 3 dimensions. If you create an array with more dimensions an extra\n    // frame is created with a single slot, temporarily taking 3 additional slots.\n    ///\n    /// This function returns an error if there are not enough slots available.\n    pub fn new_array_output\u003c'output, T, D, F\u003e(\n        frame: \u0026mut F,\n        output: Output\u003c'output\u003e,\n        dimensions: D,\n    ) -\u003e JlrsResult\u003cValue\u003c'output, 'static\u003e\u003e\n    where\n        T: IntoJulia + JuliaType,\n        D: Into\u003cDimensions\u003e,\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let array = new_array::\u003cT, _, _\u003e(frame, dimensions)?;\n            Ok(frame.assign_output(output, array, Internal))\n        }\n    }\n\n    /// Borrows an n-dimensional array from Rust for use in Julia.\n    ///\n    /// Borrowing an array with one dimension requires one slot on the GC stack. If you borrow an\n    /// array with more dimensions, an extra frame is created with a single slot slot, temporarily\n    /// taking 3 additional slots.\n    ///\n    /// This function returns an error if there are not enough slots available.\n    pub fn borrow_array\u003cT, D, V, F\u003e(\n        frame: \u0026mut F,\n        data: \u0026'data mut V,\n        dimensions: D,\n    ) -\u003e JlrsResult\u003cValue\u003c'frame, 'data\u003e\u003e\n    where\n        T: IntoJulia + JuliaType,\n        D: Into\u003cDimensions\u003e,\n        V: BorrowMut\u003c[T]\u003e,\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let array = borrow_array(frame, data, dimensions)?;\n            frame.protect(array, Internal).map_err(Into::into)\n        }\n    }\n\n    /// Borrows an n-dimensional array from Rust for use in Julia using an `Output`.\n    ///\n    /// Because an `Output` is used, no additional slot in the current frame is used for the array\n    /// itself. If you borrow an array with more than 1 dimension an extra frame is created with a\n    /// single slot, temporarily taking 3 additional slots.\n    ///\n    /// This function returns an error if there are not enough slots available.\n    pub fn borrow_array_output\u003c'output, 'borrow, T, D, V, F\u003e(\n        frame: \u0026mut F,\n        output: Output\u003c'output\u003e,\n        data: \u0026'borrow mut V,\n        dimensions: D,\n    ) -\u003e JlrsResult\u003cValue\u003c'output, 'borrow\u003e\u003e\n    where\n        'borrow: 'output,\n        T: IntoJulia + JuliaType,\n        D: Into\u003cDimensions\u003e,\n        V: BorrowMut\u003c[T]\u003e,\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let array = borrow_array(frame, data, dimensions)?;\n            Ok(frame.assign_output(output, array, Internal))\n        }\n    }\n\n    /// Moves an n-dimensional array from Rust to Julia.\n    ///\n    /// Moving an array with one dimension requires one slot on the GC stack. If you move an array\n    /// with more dimensions, an extra frame is created with a single slot slot, temporarily\n    /// taking 3 additional slots.\n    ///\n    /// This function returns an error if there are not enough slots available.\n    pub fn move_array\u003cT, D, F\u003e(\n        frame: \u0026mut F,\n        data: Vec\u003cT\u003e,\n        dimensions: D,\n    ) -\u003e JlrsResult\u003cValue\u003c'frame, 'static\u003e\u003e\n    where\n        T: IntoJulia + JuliaType,\n        D: Into\u003cDimensions\u003e,\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let array = move_array(frame, data, dimensions)?;\n            frame.protect(array, Internal).map_err(Into::into)\n        }\n    }\n\n    /// Moves an n-dimensional array from Rust to Julia using an output.\n    ///\n    /// Because an `Output` is used, no additional slot in the current frame is used for the array\n    /// itself. If you move an array with more dimensions, an extra frame is created with a single\n    /// slot slot, temporarily taking 3 additional slots.\n    ///\n    /// This function returns an error if there are not enough slots available.\n    pub fn move_array_output\u003c'output, T, D, F\u003e(\n        frame: \u0026mut F,\n        output: Output\u003c'output\u003e,\n        data: Vec\u003cT\u003e,\n        dimensions: D,\n    ) -\u003e JlrsResult\u003cValue\u003c'output, 'static\u003e\u003e\n    where\n        T: IntoJulia + JuliaType,\n        D: Into\u003cDimensions\u003e,\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let array = move_array(frame, data, dimensions)?;\n            Ok(frame.assign_output(output, array, Internal))\n        }\n    }\n\n    /// Wraps a `Value` so that a function call will not require a slot in the current frame but\n    /// uses the one that was allocated for the output.\n    pub fn with_output\u003c'output\u003e(\n        self,\n        output: Output\u003c'output\u003e,\n    ) -\u003e WithOutput\u003c'output, Value\u003c'frame, 'data\u003e\u003e {\n        WithOutput {\n            value: self,\n            output,\n        }\n    }\n\n    /// Call this value as a function that takes zero arguments, this takes one slot on the GC\n    /// stack. Returns the result of this function call if no exception is thrown, the exception\n    /// if one is, or an error if no space is left on the stack.\n    pub fn call0\u003cF\u003e(self, frame: \u0026mut F) -\u003e JlrsResult\u003cCallResult\u003c'frame, 'static\u003e\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let res = jl_call0(self.ptr());\n            try_protect(frame, res)\n        }\n    }\n\n    /// Call this value as a function that takes one argument, this takes one slot on the GC\n    /// stack. Returns the result of this function call if no exception is thrown, the exception\n    /// if one is, or an error if no space is left on the stack.\n    pub fn call1\u003c'borrow, F\u003e(\n        self,\n        frame: \u0026mut F,\n        arg: Value\u003c'_, 'borrow\u003e,\n    ) -\u003e JlrsResult\u003cCallResult\u003c'frame, 'borrow\u003e\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let res = jl_call1(self.ptr().cast(), arg.ptr());\n            try_protect(frame, res)\n        }\n    }\n\n    /// Call this value as a function that takes two arguments, this takes one slot on the GC\n    /// stack. Returns the result of this function call if no exception is thrown, the exception\n    /// if one is, or an error if no space is left on the stack.\n    pub fn call2\u003c'borrow, F\u003e(\n        self,\n        frame: \u0026mut F,\n        arg0: Value\u003c'_, 'borrow\u003e,\n        arg1: Value\u003c'_, 'borrow\u003e,\n    ) -\u003e JlrsResult\u003cCallResult\u003c'frame, 'borrow\u003e\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let res = jl_call2(self.ptr().cast(), arg0.ptr(), arg1.ptr());\n            try_protect(frame, res)\n        }\n    }\n\n    /// Call this value as a function that takes three arguments, this takes one slot on the GC\n    /// stack. Returns the result of this function call if no exception is thrown, the exception\n    /// if one is, or an error if no space is left on the stack.\n    pub fn call3\u003c'borrow, F\u003e(\n        self,\n        frame: \u0026mut F,\n        arg0: Value\u003c'_, 'borrow\u003e,\n        arg1: Value\u003c'_, 'borrow\u003e,\n        arg2: Value\u003c'_, 'borrow\u003e,\n    ) -\u003e JlrsResult\u003cCallResult\u003c'frame, 'borrow\u003e\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let res = jl_call3(self.ptr().cast(), arg0.ptr(), arg1.ptr(), arg2.ptr());\n            try_protect(frame, res)\n        }\n    }\n\n    /// Call this value as a function that takes several arguments, this takes one slot on the GC\n    /// stack. Returns the result of this function call if no exception is thrown, the exception\n    /// if one is, or an error if no space is left on the stack.\n    pub fn call\u003c'value, 'borrow, V, F\u003e(\n        self,\n        frame: \u0026mut F,\n        mut args: V,\n    ) -\u003e JlrsResult\u003cCallResult\u003c'frame, 'borrow\u003e\u003e\n    where\n        V: AsMut\u003c[Value\u003c'value, 'borrow\u003e]\u003e,\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let args = args.as_mut();\n            let n = args.len();\n            let res = jl_call(self.ptr().cast(), args.as_mut_ptr().cast(), n as _);\n            try_protect(frame, res)\n        }\n    }\n\n    /// Call this value as a function that takes several arguments in a single `Values`, this\n    /// takes one slot on the GC stack. Returns the result of this function call if no exception\n    /// is thrown, the exception if one is, or an error if no space is left on the stack.\n    pub fn call_values\u003cF\u003e(\n        self,\n        frame: \u0026mut F,\n        args: Values,\n    ) -\u003e JlrsResult\u003cCallResult\u003c'frame, 'static\u003e\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let res = jl_call(self.ptr().cast(), args.ptr(), args.len() as _);\n            try_protect(frame, res)\n        }\n    }\n\n    /// Returns an anonymous function that wraps this value in a try-catch block. Calling this\n    /// anonymous function with some arguments will call the value as a function with those\n    /// arguments and return its result, or catch the exception, print the stackstrace, and\n    /// rethrow that exception. This takes one slot on the GC stack. You must include `jlrs.jl` to\n    /// use this function.\n    pub fn tracing_call\u003cF\u003e(self, frame: \u0026mut F) -\u003e JlrsResult\u003cCallResult\u003c'frame, 'data\u003e\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let global = Global::new();\n            let func = Module::main(global)\n                .submodule(\"Jlrs\")?\n                .function(\"tracingcall\")?;\n            let res = jl_call1(func.ptr(), self.ptr());\n            try_protect(frame, res)\n        }\n    }\n\n    /// Returns an anonymous function that wraps this value in a try-catch block. Calling this\n    /// anonymous function with some arguments will call the value as a function with those\n    /// arguments and return its result, or catch the exception and throw a new one with two\n    /// fields, `exc` and `stacktrace`, containing the original exception and the stacktrace\n    /// respectively. This takes one slot on the GC stack. You must include `jlrs.jl` to use this\n    /// function.\n    pub fn attach_stacktrace\u003cF\u003e(self, frame: \u0026mut F) -\u003e JlrsResult\u003cCallResult\u003c'frame, 'data\u003e\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n    {\n        unsafe {\n            let global = Global::new();\n            let func = Module::main(global)\n                .submodule(\"Jlrs\")?\n                .function(\"attachstacktrace\")?;\n            let res = jl_call1(func.ptr(), self.ptr());\n            try_protect(frame, res)\n        }\n    }\n}\n\nimpl\u003c'frame, 'data\u003e Debug for Value\u003c'frame, 'data\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e FmtResult {\n        f.debug_tuple(\"Value\").field(\u0026self.type_name()).finish()\n    }\n}\n\nimpl_julia_type!(Value\u003c'frame, 'data\u003e, jl_any_type, 'frame, 'data);\n\nunsafe impl\u003c'frame, 'data\u003e ValidLayout for Value\u003c'frame, 'data\u003e {\n    unsafe fn valid_layout(v: Value) -\u003e bool {\n        if let Ok(dt) = v.cast::\u003cDataType\u003e() {\n            !dt.isinlinealloc()\n        } else if v.cast::\u003cunion_all::UnionAll\u003e().is_ok() {\n            true\n        } else if let Ok(u) = v.cast::\u003cunion::Union\u003e() {\n            !u.isbitsunion()\n        } else {\n            false\n        }\n    }\n}\n\n/// A wrapper that will let you call a `Value` as a function and store the result using an\n/// `Output`. The function call will not require a slot in the current frame but uses the one\n/// that was allocated for the output. You can create this by calling [`Value::with_output`].\n///\n/// Because the result of a function call is stored in an already allocated slot, calling a\n/// function returns the `CallResult` directly rather than wrapping it in a `JlrsResult` except\n/// for the methods that depend on `jlrs.jl`.\n///\n/// [`Value::with_output`]: Value.html#method.with_output\npub struct WithOutput\u003c'output, V\u003e {\n    value: V,\n    output: Output\u003c'output\u003e,\n}\n\nimpl\u003c'output, 'frame, 'data\u003e WithOutput\u003c'output, Value\u003c'frame, 'data\u003e\u003e {\n    /// Call the value as a function that takes zero arguments and use the `Output` to extend the\n    /// result's lifetime. This takes no space on the GC stack. Returns the result of this\n    /// function call if no exception is thrown or the exception if one is.\n    pub fn call0\u003c'fr, F\u003e(self, frame: \u0026mut F) -\u003e CallResult\u003c'output, 'static\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let res = jl_call0(self.value.ptr());\n            assign(frame, self.output, res)\n        }\n    }\n\n    /// Call the value as a function that takes one argument and use the `Output` to extend the\n    /// result's lifetime. This takes no space on the GC stack. Returns the result of this\n    /// function call if no exception is thrown or the exception if one is.\n    pub fn call1\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026mut F,\n        arg: Value\u003c'_, 'borrow\u003e,\n    ) -\u003e CallResult\u003c'output, 'borrow\u003e\n    where\n        'borrow: 'output,\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let res = jl_call1(self.value.ptr().cast(), arg.ptr());\n            assign(frame, self.output, res)\n        }\n    }\n\n    /// Call the value as a function that takes two arguments and use the `Output` to extend the\n    /// result's lifetime. This takes no space on the GC stack. Returns the result of this\n    /// function call if no exception is thrown or the exception if one is.\n    pub fn call2\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026mut F,\n        arg0: Value\u003c'_, 'borrow\u003e,\n        arg1: Value\u003c'_, 'borrow\u003e,\n    ) -\u003e CallResult\u003c'output, 'borrow\u003e\n    where\n        'borrow: 'output,\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let res = jl_call2(self.value.ptr().cast(), arg0.ptr(), arg1.ptr());\n            assign(frame, self.output, res)\n        }\n    }\n\n    /// Call the value as a function that takes three arguments and use the `Output` to extend\n    /// the result's lifetime. This takes no space on the GC stack. Returns the result of this\n    /// function call if no exception is thrown or the exception if one is.\n    pub fn call3\u003c'borrow, 'fr, F\u003e(\n        self,\n        frame: \u0026mut F,\n        arg0: Value\u003c'_, 'borrow\u003e,\n        arg1: Value\u003c'_, 'borrow\u003e,\n        arg2: Value\u003c'_, 'borrow\u003e,\n    ) -\u003e CallResult\u003c'output, 'borrow\u003e\n    where\n        'borrow: 'output,\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let res = jl_call3(self.value.ptr().cast(), arg0.ptr(), arg1.ptr(), arg2.ptr());\n            assign(frame, self.output, res)\n        }\n    }\n\n    /// Call the value as a function that takes several arguments and use the `Output` to extend\n    /// the result's lifetime. This takes no space on the GC stack. Returns the result of this\n    /// function call if no exception is thrown or the exception if one is.\n    pub fn call\u003c'value, 'borrow, 'fr, V, F\u003e(\n        self,\n        frame: \u0026mut F,\n        mut args: V,\n    ) -\u003e CallResult\u003c'output, 'borrow\u003e\n    where\n        'borrow: 'output,\n        V: AsMut\u003c[Value\u003c'value, 'borrow\u003e]\u003e,\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let args = args.as_mut();\n            let n = args.len();\n            let res = jl_call(self.value.ptr().cast(), args.as_mut_ptr().cast(), n as _);\n            assign(frame, self.output, res)\n        }\n    }\n\n    /// Call the value as a function that takes several arguments in a single `Values` and use\n    /// the `Output` to extend the result's lifetime. This takes no space on the GC stack. Returns\n    /// the result of this function call if no exception is thrown or the exception if one is.\n    pub fn call_values\u003c'fr, F\u003e(self, frame: \u0026mut F, args: Values) -\u003e CallResult\u003c'output, 'static\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let res = jl_call(self.value.ptr().cast(), args.ptr(), args.len() as _);\n            assign(frame, self.output, res)\n        }\n    }\n\n    /// Returns an anonymous function that wraps the value in a try-catch block. Calling this\n    /// anonymous function with some arguments will call the value as a function with those\n    /// arguments and return its result, or catch the exception, print the stackstrace, and\n    /// rethrow that exception. The output is used to protect the result. You must include\n    /// `jlrs.jl` to use this function.\n    pub fn tracing_call\u003c'fr, F\u003e(self, frame: \u0026mut F) -\u003e JlrsResult\u003cCallResult\u003c'output, 'data\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let global = Global::new();\n            let func = Module::main(global)\n                .submodule(\"Jlrs\")?\n                .function(\"tracingcall\")?;\n            let res = jl_call1(func.ptr(), self.value.ptr());\n            Ok(assign(frame, self.output, res))\n        }\n    }\n\n    /// Returns an anonymous function that wraps the value in a try-catch block. Calling this\n    /// anonymous function with some arguments will call the value as a function with those\n    /// arguments and return its result, or catch the exception and throw a new one with two\n    /// fields, `exc` and `stacktrace`, containing the original exception and the stacktrace\n    /// respectively. The output is used to protect the result. You must include `jlrs.jl` to use\n    /// this function.\n    pub fn attach_stacktrace\u003c'fr, F\u003e(self, frame: \u0026mut F) -\u003e JlrsResult\u003cCallResult\u003c'output, 'data\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n    {\n        unsafe {\n            let global = Global::new();\n            let func = Module::main(global)\n                .submodule(\"Jlrs\")?\n                .function(\"attachstacktrace\")?;\n            let res = jl_call1(func.ptr(), self.value.ptr());\n            Ok(assign(frame, self.output, res))\n        }\n    }\n}\n\nunsafe fn new_array\u003c'frame, T, D, F\u003e(frame: \u0026mut F, dimensions: D) -\u003e JlrsResult\u003c*mut jl_value_t\u003e\nwhere\n    T: IntoJulia + JuliaType,\n    D: Into\u003cDimensions\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    let dims = dimensions.into();\n    let array_type = jl_apply_array_type(T::julia_type().cast(), dims.n_dimensions());\n\n    match dims.n_dimensions() {\n        1 =\u003e Ok(jl_alloc_array_1d(array_type, dims.n_elements(0)).cast()),\n        2 =\u003e Ok(jl_alloc_array_2d(array_type, dims.n_elements(0), dims.n_elements(1)).cast()),\n        3 =\u003e Ok(jl_alloc_array_3d(\n            array_type,\n            dims.n_elements(0),\n            dims.n_elements(1),\n            dims.n_elements(2),\n        )\n        .cast()),\n        n if n \u003c= 8 =\u003e frame.frame(1, |frame| {\n            let tuple = small_dim_tuple(frame, \u0026dims)?;\n            Ok(jl_new_array(array_type, tuple.ptr()).cast())\n        }),\n        _ =\u003e frame.frame(1, |frame| {\n            let tuple = large_dim_tuple(frame, \u0026dims)?;\n            Ok(jl_new_array(array_type, tuple.ptr()).cast())\n        }),\n    }\n}\n\nunsafe fn borrow_array\u003c'data, 'frame, T, D, V, F\u003e(\n    frame: \u0026mut F,\n    data: \u0026'data mut V,\n    dimensions: D,\n) -\u003e JlrsResult\u003c*mut jl_value_t\u003e\nwhere\n    T: IntoJulia + JuliaType,\n    D: Into\u003cDimensions\u003e,\n    V: BorrowMut\u003c[T]\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    let dims = dimensions.into();\n    let array_type = jl_apply_array_type(T::julia_type().cast(), dims.n_dimensions());\n\n    match dims.n_dimensions() {\n        1 =\u003e Ok(jl_ptr_to_array_1d(\n            array_type,\n            data.borrow_mut().as_mut_ptr().cast(),\n            dims.n_elements(0),\n            0,\n        )\n        .cast()),\n        n if n \u003c= 8 =\u003e frame.frame(1, |frame| {\n            let tuple = small_dim_tuple(frame, \u0026dims)?;\n\n            Ok(jl_ptr_to_array(\n                array_type,\n                data.borrow_mut().as_mut_ptr().cast(),\n                tuple.ptr(),\n                0,\n            )\n            .cast())\n        }),\n        _ =\u003e frame.frame(1, |frame| {\n            let tuple = large_dim_tuple(frame, \u0026dims)?;\n\n            Ok(jl_ptr_to_array(\n                array_type,\n                data.borrow_mut().as_mut_ptr().cast(),\n                tuple.ptr(),\n                0,\n            )\n            .cast())\n        }),\n    }\n}\n\nunsafe fn move_array\u003c'frame, T, D, F\u003e(\n    frame: \u0026mut F,\n    data: Vec\u003cT\u003e,\n    dimensions: D,\n) -\u003e JlrsResult\u003c*mut jl_value_t\u003e\nwhere\n    T: IntoJulia + JuliaType,\n    D: Into\u003cDimensions\u003e,\n    F: Frame\u003c'frame\u003e,\n{\n    let dims = dimensions.into();\n    let array_type = jl_apply_array_type(T::julia_type().cast(), dims.n_dimensions());\n\n    match dims.n_dimensions() {\n        1 =\u003e Ok(jl_ptr_to_array_1d(\n            array_type,\n            Box::into_raw(data.into_boxed_slice()).cast(),\n            dims.n_elements(0),\n            1,\n        )\n        .cast()),\n        n if n \u003c= 8 =\u003e frame.frame(1, |frame| {\n            let tuple = small_dim_tuple(frame, \u0026dims)?;\n\n            Ok(jl_ptr_to_array(\n                array_type,\n                Box::into_raw(data.into_boxed_slice()).cast(),\n                tuple.ptr(),\n                1,\n            )\n            .cast())\n        }),\n        _ =\u003e frame.frame(1, |frame| {\n            let tuple = large_dim_tuple(frame, \u0026dims)?;\n\n            Ok(jl_ptr_to_array(\n                array_type,\n                Box::into_raw(data.into_boxed_slice()).cast(),\n                tuple.ptr(),\n                1,\n            )\n            .cast())\n        }),\n    }\n}\n\nunsafe fn try_protect\u003c'frame, F\u003e(\n    frame: \u0026mut F,\n    res: *mut jl_value_t,\n) -\u003e JlrsResult\u003cCallResult\u003c'frame, 'static\u003e\u003e\nwhere\n    F: Frame\u003c'frame\u003e,\n{\n    let exc = jl_sys::jl_exception_occurred();\n\n    if !exc.is_null() {\n        match frame.protect(exc, Internal) {\n            Ok(exc) =\u003e Ok(Err(exc)),\n            Err(a) =\u003e Err(a.into()),\n        }\n    } else {\n        match frame.protect(res, Internal) {\n            Ok(v) =\u003e Ok(Ok(v)),\n            Err(a) =\u003e Err(a.into()),\n        }\n    }\n}\n\nunsafe fn assign\u003c'output, 'frame, F\u003e(\n    frame: \u0026mut F,\n    output: Output\u003c'output\u003e,\n    res: *mut jl_value_t,\n) -\u003e CallResult\u003c'output, 'static\u003e\nwhere\n    F: Frame\u003c'frame\u003e,\n{\n    let exc = jl_exception_occurred();\n\n    if !exc.is_null() {\n        Err(frame.assign_output(output, exc, Internal))\n    } else {\n        Ok(frame.assign_output(output, res, Internal))\n    }\n}\n\nunsafe fn small_dim_tuple\u003c'frame, F\u003e(\n    frame: \u0026mut F,\n    dims: \u0026Dimensions,\n) -\u003e JlrsResult\u003cValue\u003c'frame, 'static\u003e\u003e\nwhere\n    F: Frame\u003c'frame\u003e,\n{\n    let n = dims.n_dimensions();\n    assert!(n \u003c= 8);\n    let elem_types = JL_LONG_TYPE.with(|longs| longs.get());\n    let tuple_type = jl_apply_tuple_type_v(elem_types.cast(), n);\n    let tuple = jl_new_struct_uninit(tuple_type);\n    let v = try_protect(frame, tuple)?.unwrap();\n\n    let usize_ptr: *mut usize = v.ptr().cast();\n    std::ptr::copy_nonoverlapping(dims.as_slice().as_ptr(), usize_ptr, n);\n\n    Ok(v)\n}\n\nunsafe fn large_dim_tuple\u003c'frame, F\u003e(\n    frame: \u0026mut F,\n    dims: \u0026Dimensions,\n) -\u003e JlrsResult\u003cValue\u003c'frame, 'static\u003e\u003e\nwhere\n    F: Frame\u003c'frame\u003e,\n{\n    let n = dims.n_dimensions();\n    let mut elem_types = vec![usize::julia_type(); n];\n    let tuple_type = jl_apply_tuple_type_v(elem_types.as_mut_ptr().cast(), n);\n    let tuple = jl_new_struct_uninit(tuple_type);\n    let v = try_protect(frame, tuple)?.unwrap();\n\n    let usize_ptr: *mut usize = v.ptr().cast();\n    std::ptr::copy_nonoverlapping(dims.as_slice().as_ptr(), usize_ptr, n);\n\n    Ok(v)\n}\n","traces":[{"line":64,"address":4224225,"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":4224121,"length":1,"stats":{"Line":6},"fn_name":null},{"line":70,"address":4224036,"length":1,"stats":{"Line":6},"fn_name":null},{"line":71,"address":4224046,"length":1,"stats":{"Line":6},"fn_name":null},{"line":72,"address":4224056,"length":1,"stats":{"Line":6},"fn_name":null},{"line":73,"address":4224066,"length":1,"stats":{"Line":6},"fn_name":null},{"line":74,"address":4224076,"length":1,"stats":{"Line":6},"fn_name":null},{"line":75,"address":4224086,"length":1,"stats":{"Line":6},"fn_name":null},{"line":76,"address":4224096,"length":1,"stats":{"Line":6},"fn_name":null},{"line":77,"address":4224106,"length":1,"stats":{"Line":6},"fn_name":null},{"line":96,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":4282112,"length":1,"stats":{"Line":6},"fn_name":"new\u003cu32,[u32; 4],jlrs::frame::DynamicFrame\u003e"},{"line":132,"address":null,"length":0,"stats":{"Line":6},"fn_name":null},{"line":134,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":4284976,"length":1,"stats":{"Line":3},"fn_name":"new_dyn\u003c[\u0026IntoJulia; 3],jlrs::frame::StaticFrame\u003e"},{"line":149,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":151,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":233,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":237,"address":null,"length":0,"stats":{"Line":22},"fn_name":null},{"line":238,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":4284336,"length":1,"stats":{"Line":1},"fn_name":"nothing\u003cjlrs::frame::StaticFrame\u003e"},{"line":247,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":4216768,"length":1,"stats":{"Line":107},"fn_name":"new\u003cjlrs::value::tuple::Tuple2\u003cu64, i32\u003e,jlrs::frame::StaticFrame\u003e"},{"line":262,"address":null,"length":0,"stats":{"Line":107},"fn_name":null},{"line":264,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":null,"length":0,"stats":{"Line":20},"fn_name":null},{"line":288,"address":null,"length":0,"stats":{"Line":20},"fn_name":null},{"line":331,"address":null,"length":0,"stats":{"Line":121},"fn_name":null},{"line":332,"address":null,"length":0,"stats":{"Line":121},"fn_name":null},{"line":333,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":null,"length":0,"stats":{"Line":120},"fn_name":null},{"line":340,"address":null,"length":0,"stats":{"Line":20},"fn_name":null},{"line":342,"address":null,"length":0,"stats":{"Line":20},"fn_name":null},{"line":343,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":null,"length":0,"stats":{"Line":20},"fn_name":null},{"line":359,"address":null,"length":0,"stats":{"Line":122},"fn_name":null},{"line":360,"address":null,"length":0,"stats":{"Line":122},"fn_name":null},{"line":368,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":371,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":375,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":377,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":378,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":381,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":382,"address":null,"length":0,"stats":{"Line":5},"fn_name":null},{"line":387,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":388,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":389,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":390,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":399,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":400,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":405,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":406,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":407,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":408,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":416,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":417,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":418,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":428,"address":4230512,"length":1,"stats":{"Line":3},"fn_name":"get_nth_field\u003cjlrs::frame::StaticFrame\u003e"},{"line":433,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":434,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":437,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":439,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":456,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":457,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":460,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":472,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":473,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":478,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":482,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":485,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":4226144,"length":1,"stats":{"Line":4},"fn_name":"get_field\u003c\u0026str,jlrs::frame::StaticFrame\u003e"},{"line":498,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":500,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":501,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":505,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":507,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":508,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":511,"address":null,"length":0,"stats":{"Line":4},"fn_name":null},{"line":513,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":531,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":533,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":534,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":538,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":540,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":541,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":556,"address":4231984,"length":1,"stats":{"Line":1},"fn_name":"get_field_noalloc\u003c\u0026str\u003e"},{"line":560,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":562,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":563,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":567,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":569,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":570,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":574,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":577,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":585,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":4236976,"length":1,"stats":{"Line":32},"fn_name":"new_array\u003ci32,(usize, usize),jlrs::frame::DynamicFrame\u003e"},{"line":613,"address":null,"length":0,"stats":{"Line":32},"fn_name":null},{"line":614,"address":null,"length":0,"stats":{"Line":32},"fn_name":null},{"line":625,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":636,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":637,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":648,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":660,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":661,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":672,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":686,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":687,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":698,"address":null,"length":0,"stats":{"Line":36},"fn_name":null},{"line":709,"address":null,"length":0,"stats":{"Line":36},"fn_name":null},{"line":710,"address":null,"length":0,"stats":{"Line":36},"fn_name":null},{"line":721,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":733,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":734,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":740,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":753,"address":4220432,"length":1,"stats":{"Line":7},"fn_name":"call0\u003cjlrs::frame::StaticFrame\u003e"},{"line":758,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":759,"address":null,"length":0,"stats":{"Line":7},"fn_name":null},{"line":766,"address":null,"length":0,"stats":{"Line":23},"fn_name":null},{"line":775,"address":null,"length":0,"stats":{"Line":23},"fn_name":null},{"line":776,"address":null,"length":0,"stats":{"Line":23},"fn_name":null},{"line":783,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":793,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":794,"address":null,"length":0,"stats":{"Line":8},"fn_name":null},{"line":801,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":812,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":813,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":820,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":830,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":831,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":832,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":833,"address":null,"length":0,"stats":{"Line":3},"fn_name":null},{"line":840,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":849,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":850,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":859,"address":4278448,"length":1,"stats":{"Line":1},"fn_name":"tracing_call\u003cjlrs::frame::DynamicFrame\u003e"},{"line":864,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":865,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":866,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":867,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":868,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":869,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":879,"address":4225200,"length":1,"stats":{"Line":2},"fn_name":"attach_stacktrace\u003cjlrs::frame::StaticFrame\u003e"},{"line":884,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":885,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":886,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":887,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":888,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":889,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":895,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":4224567,"length":1,"stats":{"Line":0},"fn_name":null},{"line":903,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":904,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":905,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":906,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":907,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":908,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":909,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":911,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":4276656,"length":1,"stats":{"Line":2},"fn_name":"call0\u003cjlrs::frame::StaticFrame\u003e"},{"line":939,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":940,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":947,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":957,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":958,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":965,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":976,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":977,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":984,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":996,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":997,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1004,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1015,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1016,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1017,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1018,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1025,"address":4274224,"length":1,"stats":{"Line":2},"fn_name":"call_values\u003cjlrs::frame::DynamicFrame\u003e"},{"line":1030,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1031,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":1040,"address":4274640,"length":1,"stats":{"Line":1},"fn_name":"tracing_call\u003cjlrs::frame::DynamicFrame\u003e"},{"line":1045,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1046,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1047,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1048,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1049,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1050,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1060,"address":4275296,"length":1,"stats":{"Line":1},"fn_name":"attach_stacktrace\u003cjlrs::frame::DynamicFrame\u003e"},{"line":1065,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1066,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1067,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1068,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1069,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":1075,"address":4237280,"length":1,"stats":{"Line":32},"fn_name":"new_array\u003ci32,(usize, usize),jlrs::frame::DynamicFrame\u003e"},{"line":1081,"address":4237311,"length":1,"stats":{"Line":32},"fn_name":null},{"line":1082,"address":4237353,"length":1,"stats":{"Line":32},"fn_name":null},{"line":1084,"address":4237472,"length":1,"stats":{"Line":32},"fn_name":null},{"line":1085,"address":4237515,"length":1,"stats":{"Line":32},"fn_name":null},{"line":1086,"address":4237719,"length":1,"stats":{"Line":11},"fn_name":null},{"line":1087,"address":4237991,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1088,"address":4237869,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1089,"address":4237877,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1090,"address":4237913,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1091,"address":4237942,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1094,"address":4238053,"length":1,"stats":{"Line":17},"fn_name":null},{"line":1095,"address":4238401,"length":1,"stats":{"Line":8},"fn_name":null},{"line":1096,"address":4238516,"length":1,"stats":{"Line":8},"fn_name":null},{"line":1098,"address":4238182,"length":1,"stats":{"Line":2},"fn_name":null},{"line":1099,"address":4238753,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1100,"address":4238868,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1105,"address":4219424,"length":1,"stats":{"Line":7},"fn_name":"borrow_array\u003cu64,usize,alloc::vec::Vec\u003cu64\u003e,jlrs::frame::DynamicFrame\u003e"},{"line":1116,"address":4219455,"length":1,"stats":{"Line":7},"fn_name":null},{"line":1117,"address":4219500,"length":1,"stats":{"Line":7},"fn_name":null},{"line":1119,"address":4219601,"length":1,"stats":{"Line":7},"fn_name":null},{"line":1120,"address":4219638,"length":1,"stats":{"Line":7},"fn_name":null},{"line":1121,"address":4219653,"length":1,"stats":{"Line":3},"fn_name":null},{"line":1122,"address":4219661,"length":1,"stats":{"Line":3},"fn_name":null},{"line":1123,"address":4219733,"length":1,"stats":{"Line":3},"fn_name":null},{"line":1127,"address":4219840,"length":1,"stats":{"Line":7},"fn_name":null},{"line":1128,"address":4222911,"length":1,"stats":{"Line":3},"fn_name":null},{"line":1130,"address":4223253,"length":1,"stats":{"Line":3},"fn_name":null},{"line":1131,"address":4223036,"length":1,"stats":{"Line":3},"fn_name":null},{"line":1132,"address":4223043,"length":1,"stats":{"Line":3},"fn_name":null},{"line":1133,"address":4223225,"length":1,"stats":{"Line":3},"fn_name":null},{"line":1138,"address":4219977,"length":1,"stats":{"Line":2},"fn_name":null},{"line":1139,"address":4222479,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1141,"address":4222821,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1142,"address":4222604,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1143,"address":4222611,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1144,"address":4222793,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1152,"address":4221248,"length":1,"stats":{"Line":36},"fn_name":"move_array\u003cf64,usize,jlrs::frame::StaticFrame\u003e"},{"line":1162,"address":4221271,"length":1,"stats":{"Line":36},"fn_name":null},{"line":1163,"address":4221343,"length":1,"stats":{"Line":36},"fn_name":null},{"line":1165,"address":4221453,"length":1,"stats":{"Line":36},"fn_name":null},{"line":1166,"address":4221490,"length":1,"stats":{"Line":36},"fn_name":null},{"line":1167,"address":4221505,"length":1,"stats":{"Line":9},"fn_name":null},{"line":1168,"address":4221513,"length":1,"stats":{"Line":9},"fn_name":null},{"line":1169,"address":4221634,"length":1,"stats":{"Line":9},"fn_name":null},{"line":1173,"address":4221744,"length":1,"stats":{"Line":53},"fn_name":null},{"line":1174,"address":4222863,"length":1,"stats":{"Line":26},"fn_name":null},{"line":1176,"address":4223342,"length":1,"stats":{"Line":26},"fn_name":null},{"line":1177,"address":4223045,"length":1,"stats":{"Line":26},"fn_name":null},{"line":1178,"address":4223052,"length":1,"stats":{"Line":26},"fn_name":null},{"line":1179,"address":4223306,"length":1,"stats":{"Line":26},"fn_name":null},{"line":1184,"address":4221896,"length":1,"stats":{"Line":2},"fn_name":null},{"line":1185,"address":4222207,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1187,"address":4222686,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1188,"address":4222389,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1189,"address":4222396,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1190,"address":4222650,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1198,"address":4222640,"length":1,"stats":{"Line":25},"fn_name":"try_protect\u003cjlrs::frame::DynamicFrame\u003e"},{"line":1205,"address":4222686,"length":1,"stats":{"Line":25},"fn_name":null},{"line":1207,"address":4222710,"length":1,"stats":{"Line":25},"fn_name":null},{"line":1208,"address":4222759,"length":1,"stats":{"Line":4},"fn_name":null},{"line":1209,"address":4222780,"length":1,"stats":{"Line":4},"fn_name":null},{"line":1210,"address":4222792,"length":1,"stats":{"Line":0},"fn_name":null},{"line":1213,"address":4222730,"length":1,"stats":{"Line":25},"fn_name":null},{"line":1214,"address":4222975,"length":1,"stats":{"Line":25},"fn_name":null},{"line":1215,"address":4222990,"length":1,"stats":{"Line":0},"fn_name":null},{"line":1220,"address":4282368,"length":1,"stats":{"Line":2},"fn_name":"assign\u003cjlrs::frame::StaticFrame\u003e"},{"line":1228,"address":4282402,"length":1,"stats":{"Line":2},"fn_name":null},{"line":1230,"address":4282423,"length":1,"stats":{"Line":2},"fn_name":null},{"line":1231,"address":4282486,"length":1,"stats":{"Line":0},"fn_name":null},{"line":1233,"address":4282458,"length":1,"stats":{"Line":2},"fn_name":null},{"line":1237,"address":4224224,"length":1,"stats":{"Line":6},"fn_name":"small_dim_tuple\u003cjlrs::frame::StaticFrame\u003e"},{"line":1244,"address":4224255,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1245,"address":4224287,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1246,"address":4224302,"length":1,"stats":{"Line":12},"fn_name":null},{"line":1247,"address":4224364,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1248,"address":4224408,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1249,"address":4224427,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1251,"address":4224693,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1252,"address":4224736,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1254,"address":4224799,"length":1,"stats":{"Line":6},"fn_name":null},{"line":1257,"address":4223504,"length":1,"stats":{"Line":1},"fn_name":"large_dim_tuple\u003cjlrs::frame::StaticFrame\u003e"},{"line":1264,"address":4223535,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1265,"address":4223582,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1266,"address":4223624,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1267,"address":4223702,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1268,"address":4223721,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1270,"address":4224003,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1271,"address":4224056,"length":1,"stats":{"Line":1},"fn_name":null},{"line":1273,"address":4224142,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":282,"coverable":311},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","access_fields.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\nuse jlrs::value::datatype::Mutable;\n\n#[test]\nfn access_tuple_fields() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(4, |global, frame| {\n            // Returns (1, 2, 3) as Tuple{UInt32, UInt16, Int64}\n            let func = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"inlinetuple\")?;\n            let tup = func.call0(frame)?.unwrap();\n\n            let output = frame.output()?;\n\n            assert!(tup.is::\u003cTuple\u003e());\n            assert_eq!(tup.n_fields(), 3);\n            let v1 = tup.get_nth_field(frame, 0)?;\n            let v2 = tup.get_nth_field(frame, 1)?;\n            let v3 = tup.get_nth_field_output(frame, output, 2)?;\n\n            assert!(v1.is::\u003cu32\u003e());\n            assert!(v2.is::\u003cu16\u003e());\n            assert!(v3.is::\u003ci64\u003e());\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn cannot_access_oob_tuple_field() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(4, |global, frame| {\n            // Returns (1, 2, 3) as Tuple{UInt32, UInt16, Int64}\n            let func = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"inlinetuple\")?;\n            let tup = func.call0(frame)?.unwrap();\n            assert!(tup.get_nth_field(frame, 3).is_err());\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn access_non_pointer_tuple_field_must_alloc() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(4, |global, frame| {\n            // Returns (1, 2, 3) as Tuple{UInt32, UInt16, Int64}\n            let func = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"inlinetuple\")?;\n            let tup = func.call0(frame)?.unwrap();\n            assert!(unsafe { tup.get_nth_field_noalloc(2).is_err() });\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn access_mutable_struct_fields() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(5, |global, frame| {\n            //mutable struct MutableStruct\n            //  x\n            //  y::UInt64\n            //end\n            let func = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"MutableStruct\")?;\n\n            let x = Value::new(frame, 2.0f32)?;\n            let y = Value::new(frame, 3u64)?;\n\n            let mut_struct = func.call2(frame, x, y)?.unwrap();\n            assert!(mut_struct.is::\u003cMutable\u003e());\n\n            assert!(mut_struct.get_field(frame, \"x\").is_ok());\n            let x_val = unsafe { mut_struct.get_field_noalloc(\"x\") };\n            assert!(x_val.is_ok());\n            assert!(x_val.unwrap().is::\u003cf32\u003e());\n            let output = frame.output()?;\n            assert!(mut_struct.get_field_output(frame, output, \"y\").is_ok());\n            assert!(unsafe { mut_struct.get_field_noalloc(\"y\").is_err() });\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn cannot_access_unknown_mutable_struct_field() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(5, |global, frame| {\n            //mutable struct MutableStruct\n            //  x\n            //  y::UInt64\n            //end\n            let func = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"MutableStruct\")?;\n\n            let x = Value::new(frame, 2.0f32)?;\n            let y = Value::new(frame, 3u64)?;\n\n            let mut_struct = func.call2(frame, x, y)?.unwrap();\n            assert!(mut_struct.is::\u003cMutable\u003e());\n\n            assert!(mut_struct.get_field(frame, \"z\").is_err());\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn access_bounds_error_fields() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let oob_idx = jlrs\n            .frame(5, |global, frame| {\n                let idx = Value::new(frame, 4usize)?;\n                let data = vec![1.0f64, 2., 3.];\n                let array = Value::move_array(frame, data, 3)?;\n                let func = Module::base(global).function(\"getindex\")?;\n                let out = func.call2(frame, array, idx)?.unwrap_err();\n\n                assert_eq!(out.type_name(), \"BoundsError\");\n\n                let field_names = out.field_names();\n                let f0: String = field_names[0].into();\n                assert_eq!(f0, \"a\");\n                let f1: String = field_names[1].into();\n                assert_eq!(f1, \"i\");\n\n                unsafe {\n                    out.get_field_noalloc(\"a\")?;\n                }\n\n                out.get_field(frame, field_names[1])?\n                    .get_nth_field(frame, 0)?\n                    .cast::\u003cisize\u003e()\n            })\n            .unwrap();\n\n        assert_eq!(oob_idx, 4);\n    });\n}\n\n#[test]\nfn access_bounds_error_fields_oob() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(5, |global, frame| {\n            let idx = Value::new(frame, 4usize)?;\n            let data = vec![1.0f64, 2., 3.];\n            let array = Value::move_array(frame, data, 3)?;\n            let func = Module::base(global).function(\"getindex\")?;\n            let out = func.call2(frame, array, idx)?.unwrap_err();\n\n            let field_names = out.field_names();\n            assert!(out\n                .get_field(frame, field_names[1])?\n                .get_nth_field(frame, 123)\n                .is_err());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn access_bounds_error_fields_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(5, |global, frame| {\n            let idx = Value::new(frame, 4usize)?;\n            let data = vec![1.0f64, 2., 3.];\n            let array = Value::move_array(frame, data, 3)?;\n            let func = Module::base(global).function(\"getindex\")?;\n            let out = func.call2(frame, array, idx)?.unwrap_err();\n            let output = frame.output()?;\n\n            let field_names = out.field_names();\n            assert!(out\n                .get_field(frame, field_names[1])?\n                .get_nth_field_output(frame, output, 0)\n                .is_ok());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn access_bounds_error_fields_output_oob() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(5, |global, frame| {\n            let idx = Value::new(frame, 4usize)?;\n            let data = vec![1.0f64, 2., 3.];\n            let array = Value::move_array(frame, data, 3)?;\n            let func = Module::base(global).function(\"getindex\")?;\n            let out = func.call2(frame, array, idx)?.unwrap_err();\n            let output = frame.output()?;\n\n            let field_names = out.field_names();\n            assert!(out\n                .get_field(frame, field_names[1])?\n                .get_nth_field_output(frame, output, 123)\n                .is_err());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n","traces":[{"line":6,"address":4226320,"length":1,"stats":{"Line":2},"fn_name":"access_tuple_fields"},{"line":7,"address":4226321,"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":4253097,"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":4250672,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":11,"address":4250695,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4250807,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4250824,"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":4251106,"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":4251428,"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":4251534,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4251657,"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":4251822,"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":4252279,"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":4252487,"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":4252681,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4252784,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4252841,"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":4252893,"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":4226336,"length":1,"stats":{"Line":2},"fn_name":"cannot_access_oob_tuple_field"},{"line":36,"address":4226337,"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":4254201,"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":4253280,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":40,"address":4253300,"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":4253394,"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":4253411,"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":4253657,"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":4253951,"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":4254052,"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":4226352,"length":1,"stats":{"Line":2},"fn_name":"access_non_pointer_tuple_field_must_alloc"},{"line":54,"address":4226353,"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":4255305,"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":4254384,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":58,"address":4254404,"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":4254498,"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":4254515,"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":4254761,"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":4255050,"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":4255155,"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":4226368,"length":1,"stats":{"Line":2},"fn_name":"access_mutable_struct_fields"},{"line":72,"address":4226369,"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":4257897,"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":4255488,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":79,"address":4255503,"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":4255631,"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":4255648,"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":4255954,"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":4256160,"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":4256371,"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":4256679,"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":4256701,"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":4256851,"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":4256937,"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":4256958,"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":4257064,"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":4257197,"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":4257425,"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":4257587,"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":4226384,"length":1,"stats":{"Line":2},"fn_name":"cannot_access_unknown_mutable_struct_field"},{"line":105,"address":4226385,"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":4259561,"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":4258080,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":112,"address":4258103,"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":4258215,"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":4258232,"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":4258535,"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":4258717,"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":4258901,"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":4259203,"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":4259225,"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":4259375,"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":4226400,"length":1,"stats":{"Line":2},"fn_name":"access_bounds_error_fields"},{"line":131,"address":4226401,"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":4263695,"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":4263731,"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":4259744,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":136,"address":4259770,"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":4259919,"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":4260093,"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":4260278,"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":4260500,"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":4260810,"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":4260956,"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":4261346,"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":4261389,"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":4261522,"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":4261951,"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":4262084,"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":4262584,"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":4263077,"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":4263821,"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":4226416,"length":1,"stats":{"Line":2},"fn_name":"access_bounds_error_fields_oob"},{"line":166,"address":4226417,"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":4265945,"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":4264304,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":170,"address":4264327,"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":4264454,"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":4264642,"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":4264827,"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":4265051,"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":4265359,"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":4265442,"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":4265394,"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":4265727,"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":4226432,"length":1,"stats":{"Line":2},"fn_name":"access_bounds_error_fields_output"},{"line":189,"address":4226433,"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":4267993,"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":4266128,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":193,"address":4266151,"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":4266278,"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":4266466,"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":4266651,"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":4266887,"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":4267201,"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":4267301,"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":4267459,"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":4267411,"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":4267746,"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":4226448,"length":1,"stats":{"Line":2},"fn_name":"access_bounds_error_fields_output_oob"},{"line":213,"address":4226449,"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":4270041,"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":4268176,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":217,"address":4268199,"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":4268326,"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":4268514,"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":4268699,"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":4268935,"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":4269249,"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":4269349,"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":4269507,"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":4269459,"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":4269797,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":126,"coverable":131},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","access_unboxed_array.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\nmacro_rules! impl_test {\n    ($name:ident, $name_mut:ident, $name_slice:ident, $name_slice_mut:ident, $value_type:ty) =\u003e {\n        #[test]\n        fn $name() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n\n                jlrs.frame(1, |_, frame| {\n                    let data: Vec\u003c$value_type\u003e = (1..=24).map(|x| x as $value_type).collect();\n\n                    let array = Value::move_array(frame, data, (2, 3, 4))?;\n                    let d = array.cast::\u003cArray\u003e()?.copy_inline_data::\u003c$value_type\u003e()?;\n\n                    let mut out = 1 as $value_type;\n                    for third in \u0026[0, 1, 2, 3] {\n                        for second in \u0026[0, 1, 2] {\n                            for first in \u0026[0, 1] {\n                                assert_eq!(d[(*first, *second, *third)], out);\n                                assert_eq!(*d.get((*first, *second, *third)).unwrap(), out);\n                                out += 1 as $value_type;\n                            }\n                        }\n                    }\n\n                    assert!(d.get((7, 7, 7)).is_none());\n\n                    Ok(())\n                })\n                .unwrap();\n            });\n        }\n\n        #[test]\n        fn $name_mut() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n\n                jlrs.frame(1, |_, frame| {\n                    let data: Vec\u003c$value_type\u003e = (1..=24).map(|x| x as $value_type).collect();\n\n                    let array = Value::move_array(frame, data, (2, 3, 4))?;\n                    let mut d = array.cast::\u003cArray\u003e()?.copy_inline_data::\u003c$value_type\u003e()?;\n\n                    let mut out = 2 as $value_type;\n                    for third in \u0026[0, 1, 2, 3] {\n                        for second in \u0026[0, 1, 2] {\n                            for first in \u0026[0, 1] {\n                                d[(*first, *second, *third)] += 1 as $value_type;\n                                assert_eq!(d[(*first, *second, *third)], out);\n                                let e = d.get_mut((*first, *second, *third)).unwrap();\n                                *e = *e + 1 as $value_type;\n                                assert_eq!(d[(*first, *second, *third)], out + 1 as $value_type);\n                                out += 1 as $value_type;\n                            }\n                        }\n                    }\n\n                    assert!(d.get_mut((7, 7, 7)).is_none());\n\n                    Ok(())\n                })\n                .unwrap();\n            });\n        }\n\n        #[test]\n        fn $name_slice() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n\n                jlrs.frame(1, |_, frame| {\n                    let data: Vec\u003c$value_type\u003e = (1..=24).map(|x| x as $value_type).collect();\n\n                    let array = Value::move_array(frame, data.clone(), (2, 3, 4))?;\n                    let d = array.cast::\u003cArray\u003e()?.copy_inline_data::\u003c$value_type\u003e()?;\n\n                    for (a, b) in data.iter().zip(d.as_slice()) {\n                        assert_eq!(a, b)\n                    }\n\n                    Ok(())\n                })\n                .unwrap();\n            });\n        }\n\n        #[test]\n        fn $name_slice_mut() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n\n                jlrs.frame(1, |_, frame| {\n                    let data: Vec\u003c$value_type\u003e = (1..=24).map(|x| x as $value_type).collect();\n\n                    let array = Value::move_array(frame, data.clone(), (2, 3, 4))?;\n                    let mut d = array.cast::\u003cArray\u003e()?.copy_inline_data::\u003c$value_type\u003e()?;\n\n                    for (a, b) in data.iter().zip(d.as_mut_slice()) {\n                        assert_eq!(a, b)\n                    }\n\n                    Ok(())\n                })\n                .unwrap();\n            });\n        }\n    };\n}\n\nimpl_test!(\n    array_data_3d_u8,\n    array_data_3d_u8_mut,\n    array_data_3d_u8_slice,\n    array_data_3d_u8_slice_mut,\n    u8\n);\nimpl_test!(\n    array_data_3d_u16,\n    array_data_3d_u16_mut,\n    array_data_3d_u16_slice,\n    array_data_3d_u16_slice_mut,\n    u16\n);\nimpl_test!(\n    array_data_3d_u32,\n    array_data_3d_u32_mut,\n    array_data_3d_u32_slice,\n    array_data_3d_u32_slice_mut,\n    u32\n);\nimpl_test!(\n    array_data_3d_u64,\n    array_data_3d_u64_mut,\n    array_data_3d_u64_slice,\n    array_data_3d_u64_slice_mut,\n    u64\n);\nimpl_test!(\n    array_data_3d_i8,\n    array_data_3d_i8_mut,\n    array_data_3d_i8_slice,\n    array_data_3d_i8_slice_mut,\n    i8\n);\nimpl_test!(\n    array_data_3d_i16,\n    array_data_3d_i16_mut,\n    array_data_3d_i16_slice,\n    array_data_3d_i16_slice_mut,\n    i16\n);\nimpl_test!(\n    array_data_3d_i32,\n    array_data_3d_i32_mut,\n    array_data_3d_i32_slice,\n    array_data_3d_i32_slice_mut,\n    i32\n);\nimpl_test!(\n    array_data_3d_i64,\n    array_data_3d_i64_mut,\n    array_data_3d_i64_slice,\n    array_data_3d_i64_slice_mut,\n    i64\n);\nimpl_test!(\n    array_data_3d_f32,\n    array_data_3d_f32_mut,\n    array_data_3d_f32_slice,\n    array_data_3d_f32_slice_mut,\n    f32\n);\nimpl_test!(\n    array_data_3d_f64,\n    array_data_3d_f64_mut,\n    array_data_3d_f64_slice,\n    array_data_3d_f64_slice_mut,\n    f64\n);\n\n#[test]\nfn access_copied_array_dimensions() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n            let arr = arr_val.cast::\u003cArray\u003e()?;\n\n            let data = arr.copy_inline_data::\u003cf32\u003e()?;\n            assert_eq!(data.dimensions().as_slice(), \u0026[1, 2]);\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n","traces":[{"line":7,"address":4217168,"length":1,"stats":{"Line":20},"fn_name":"array_data_3d_u8"},{"line":8,"address":4217169,"length":1,"stats":{"Line":20},"fn_name":null},{"line":9,"address":4261081,"length":1,"stats":{"Line":10},"fn_name":null},{"line":11,"address":4258224,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":12,"address":4258192,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":14,"address":4258332,"length":1,"stats":{"Line":10},"fn_name":null},{"line":15,"address":4258548,"length":1,"stats":{"Line":10},"fn_name":null},{"line":17,"address":4259032,"length":1,"stats":{"Line":10},"fn_name":null},{"line":18,"address":4259040,"length":1,"stats":{"Line":10},"fn_name":null},{"line":19,"address":4259380,"length":1,"stats":{"Line":10},"fn_name":null},{"line":20,"address":4259557,"length":1,"stats":{"Line":10},"fn_name":null},{"line":21,"address":4259734,"length":1,"stats":{"Line":10},"fn_name":null},{"line":22,"address":4259937,"length":1,"stats":{"Line":10},"fn_name":null},{"line":23,"address":4260486,"length":1,"stats":{"Line":10},"fn_name":null},{"line":28,"address":4259276,"length":1,"stats":{"Line":10},"fn_name":null},{"line":30,"address":4260883,"length":1,"stats":{"Line":10},"fn_name":null},{"line":37,"address":4217184,"length":1,"stats":{"Line":20},"fn_name":"array_data_3d_u8_mut"},{"line":38,"address":4217185,"length":1,"stats":{"Line":20},"fn_name":null},{"line":39,"address":4264569,"length":1,"stats":{"Line":10},"fn_name":null},{"line":41,"address":4261296,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":42,"address":4261264,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":44,"address":4261404,"length":1,"stats":{"Line":10},"fn_name":null},{"line":45,"address":4261620,"length":1,"stats":{"Line":10},"fn_name":null},{"line":47,"address":4262104,"length":1,"stats":{"Line":10},"fn_name":null},{"line":48,"address":4262112,"length":1,"stats":{"Line":10},"fn_name":null},{"line":49,"address":4262452,"length":1,"stats":{"Line":10},"fn_name":null},{"line":50,"address":4262629,"length":1,"stats":{"Line":10},"fn_name":null},{"line":51,"address":4262806,"length":1,"stats":{"Line":10},"fn_name":null},{"line":52,"address":4262958,"length":1,"stats":{"Line":10},"fn_name":null},{"line":53,"address":4263153,"length":1,"stats":{"Line":10},"fn_name":null},{"line":54,"address":4263636,"length":1,"stats":{"Line":10},"fn_name":null},{"line":55,"address":4263676,"length":1,"stats":{"Line":10},"fn_name":null},{"line":56,"address":4263887,"length":1,"stats":{"Line":10},"fn_name":null},{"line":61,"address":4262348,"length":1,"stats":{"Line":10},"fn_name":null},{"line":63,"address":4264284,"length":1,"stats":{"Line":10},"fn_name":null},{"line":70,"address":4217200,"length":1,"stats":{"Line":20},"fn_name":"array_data_3d_u8_slice"},{"line":71,"address":4217201,"length":1,"stats":{"Line":20},"fn_name":null},{"line":72,"address":4266713,"length":1,"stats":{"Line":10},"fn_name":null},{"line":74,"address":4264784,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":75,"address":4264752,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":77,"address":4264908,"length":1,"stats":{"Line":10},"fn_name":null},{"line":78,"address":4265135,"length":1,"stats":{"Line":10},"fn_name":null},{"line":80,"address":4265667,"length":1,"stats":{"Line":10},"fn_name":null},{"line":81,"address":4266180,"length":1,"stats":{"Line":10},"fn_name":null},{"line":84,"address":4266076,"length":1,"stats":{"Line":10},"fn_name":null},{"line":91,"address":4217216,"length":1,"stats":{"Line":20},"fn_name":"array_data_3d_u8_slice_mut"},{"line":92,"address":4217217,"length":1,"stats":{"Line":20},"fn_name":null},{"line":93,"address":4268857,"length":1,"stats":{"Line":10},"fn_name":null},{"line":95,"address":4266928,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":96,"address":4266896,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":98,"address":4267052,"length":1,"stats":{"Line":10},"fn_name":null},{"line":99,"address":4267279,"length":1,"stats":{"Line":10},"fn_name":null},{"line":101,"address":4267811,"length":1,"stats":{"Line":10},"fn_name":null},{"line":102,"address":4268324,"length":1,"stats":{"Line":10},"fn_name":null},{"line":105,"address":4268220,"length":1,"stats":{"Line":10},"fn_name":null},{"line":185,"address":4217808,"length":1,"stats":{"Line":2},"fn_name":"access_copied_array_dimensions"},{"line":186,"address":4217809,"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":4367673,"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":4366304,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":190,"address":4366319,"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":4366481,"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":4366691,"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":4366979,"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":4367240,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":64,"coverable":64},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","arrays.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn array_can_be_cast() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n            let arr = arr_val.cast::\u003cArray\u003e();\n            assert!(arr.is_ok());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn array_dimensions() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n            let arr = arr_val.cast::\u003cArray\u003e()?;\n            let dims = arr.dimensions();\n            assert_eq!(dims.as_slice(), \u0026[1, 2]);\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn check_array_contents_info() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n            let arr = arr_val.cast::\u003cArray\u003e()?;\n            assert!(arr.contains::\u003cf32\u003e());\n            assert!(arr.contains_inline::\u003cf32\u003e());\n            assert!(arr.into_typed_array::\u003cf32\u003e().is_ok());\n            assert!(arr.into_typed_array::\u003cf64\u003e().is_err());\n            assert!(!arr.has_inlined_pointers());\n            assert!(arr.is_inline_array());\n            assert!(!arr.is_value_array());\n            assert_eq!(arr.element_type().cast::\u003cDataType\u003e()?.name(), \"Float32\");\n\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn cannot_unbox_new_as_array() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(1, |_, frame| {\n            let p = Value::new(frame, 1u8)?;\n            p.cast::\u003cArray\u003e()?;\n            Ok(())\n        });\n\n        assert!(out.is_err());\n    });\n}\n\n#[test]\nfn cannot_unbox_array_with_wrong_type() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(1, |_, frame| {\n            let array = Value::new_array::\u003cf32, _, _\u003e(frame, (3, 1))?;\n            array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu8\u003e()\n        });\n\n        assert!(out.is_err());\n    });\n}\n\n#[test]\nfn typed_array_can_be_cast() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n            let arr = arr_val.cast::\u003cTypedArray\u003cf32\u003e\u003e();\n            assert!(arr.is_ok());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn typed_array_dimensions() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n            let arr = arr_val.cast::\u003cTypedArray\u003cf32\u003e\u003e()?;\n            let dims = arr.dimensions();\n            assert_eq!(dims.as_slice(), \u0026[1, 2]);\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn check_typed_array_contents_info() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n            let arr = arr_val.cast::\u003cTypedArray\u003cf32\u003e\u003e()?;\n            assert!(!arr.has_inlined_pointers());\n            assert!(arr.is_inline_array());\n            assert!(!arr.is_value_array());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n","traces":[{"line":5,"address":4235584,"length":1,"stats":{"Line":2},"fn_name":"array_can_be_cast"},{"line":6,"address":4235585,"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":4247305,"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":4246912,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":10,"address":4246924,"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":4247050,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4247155,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4247193,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4247461,"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":4235600,"length":1,"stats":{"Line":2},"fn_name":"array_dimensions"},{"line":21,"address":4235601,"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":4248553,"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":4247488,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":25,"address":4247503,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4247665,"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":4247875,"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":4247970,"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":4248141,"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":4235616,"length":1,"stats":{"Line":2},"fn_name":"check_array_contents_info"},{"line":37,"address":4235617,"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":4250617,"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":4248736,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":41,"address":4248751,"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":4248913,"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":4249123,"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":4249257,"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":4249322,"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":4249467,"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":4249612,"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":4249680,"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":4249746,"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":4249814,"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":4250182,"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":4250773,"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":4235632,"length":1,"stats":{"Line":2},"fn_name":"cannot_unbox_new_as_array"},{"line":61,"address":4235633,"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":4251209,"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":4250800,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":65,"address":4250812,"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":4250915,"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":4251072,"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":4251313,"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":4235648,"length":1,"stats":{"Line":2},"fn_name":"cannot_unbox_array_with_wrong_type"},{"line":76,"address":4235649,"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":4251916,"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":4251472,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":80,"address":4251490,"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":4251632,"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":4252010,"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":4252149,"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":4235664,"length":1,"stats":{"Line":2},"fn_name":"typed_array_can_be_cast"},{"line":90,"address":4235665,"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":4252569,"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":4252176,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":94,"address":4252188,"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":4252314,"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":4252419,"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":4252457,"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":4235680,"length":1,"stats":{"Line":2},"fn_name":"typed_array_dimensions"},{"line":105,"address":4235681,"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":4253817,"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":4252752,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":109,"address":4252767,"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":4252929,"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":4253139,"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":4253233,"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":4253404,"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":4253973,"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":4235696,"length":1,"stats":{"Line":2},"fn_name":"check_typed_array_contents_info"},{"line":121,"address":4235697,"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":4254633,"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":4254000,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":125,"address":4254015,"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":4254141,"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":4254318,"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":4254427,"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":4254483,"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":4254536,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":77,"coverable":78},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","borrow_array.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn borrow_array_1d() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        let mut data = vec![1u64, 2, 3, 4];\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let array = Value::borrow_array(frame, \u0026mut data, 4)?;\n                assert!(array.is_array_of::\u003cu64\u003e());\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu64\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 4);\n        assert_eq!(data, vec![1, 2, 3, 4]);\n    });\n}\n\n#[test]\nfn borrow_array_1d_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        let mut data = vec![1u64, 2, 3, 4];\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let output = frame.output()?;\n                let array = Value::borrow_array_output(frame, output, \u0026mut data, 4)?;\n                assert!(array.is_array_of::\u003cu64\u003e());\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu64\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 4);\n        assert_eq!(data, vec![1, 2, 3, 4]);\n    });\n}\n\n#[test]\nfn borrow_array_1d_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        let mut data = vec![1u64, 2, 3, 4];\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                let array = Value::borrow_array(frame, \u0026mut data, 4)?;\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu64\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 4);\n        assert_eq!(data, vec![1, 2, 3, 4]);\n    });\n}\n\n#[test]\nfn borrow_array_2d() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        let mut data = vec![1u64, 2, 3, 4];\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let array = Value::borrow_array(frame, \u0026mut data, (2, 2))?;\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu64\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 2);\n        assert_eq!(dims.n_elements(1), 2);\n        assert_eq!(data, vec![1, 2, 3, 4]);\n    });\n}\n\n#[test]\nfn borrow_array_2d_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        let mut data = vec![1u64, 2, 3, 4];\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                let array = Value::borrow_array(frame, \u0026mut data, (2, 2))?;\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu64\u003e()\n            })\n            .unwrap();\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 2);\n        assert_eq!(dims.n_elements(1), 2);\n        assert_eq!(data, vec![1, 2, 3, 4]);\n    });\n}\n","traces":[{"line":5,"address":4236320,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":6,"address":4236816,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":7,"address":4236831,"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":4236883,"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":4236958,"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":4236352,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":12,"address":4236380,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4236491,"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":4236591,"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":4237082,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4237249,"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":4237425,"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":4237953,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4238976,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":27,"address":4239696,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":28,"address":4239711,"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":4239763,"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":4239838,"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":4239008,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":33,"address":4239034,"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":4239157,"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":4239334,"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":4239427,"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":4239962,"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":4240129,"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":4240305,"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":4240833,"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":4241856,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":49,"address":4242288,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":50,"address":4242303,"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":4242355,"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":4242430,"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":4241888,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":55,"address":4241913,"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":4242024,"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":4242549,"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":4242716,"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":4242892,"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":4243420,"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":4244448,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":69,"address":4244912,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":70,"address":4244927,"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":4244979,"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":4245054,"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":4244480,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":75,"address":4244503,"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":4244648,"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":4245178,"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":4245345,"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":4245521,"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":4246039,"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":4246568,"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":4247584,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":90,"address":4248048,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":91,"address":4248063,"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":4248115,"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":4248190,"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":4247616,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":96,"address":4247639,"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":4247784,"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":4248309,"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":4248476,"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":4248652,"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":4249170,"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":4249699,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":65,"coverable":65},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","borrow_array_data.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\nmacro_rules! impl_test {\n    ($name:ident, $name_mut:ident, $name_slice:ident, $name_slice_mut:ident, $value_type:ty) =\u003e {\n        #[test]\n        fn $name() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n\n                jlrs.frame(5, |global, frame| {\n                    let data: Vec\u003c$value_type\u003e = (1..=24).map(|x| x as $value_type).collect();\n\n                    let array = Value::move_array(frame, data, (2, 3, 4))?;\n                    let d = array\n                        .cast::\u003cArray\u003e()?\n                        .inline_data::\u003c$value_type, _\u003e(frame)?;\n\n                    let mut out = 1 as $value_type;\n                    for third in \u0026[0, 1, 2, 3] {\n                        for second in \u0026[0, 1, 2] {\n                            for first in \u0026[0, 1] {\n                                assert_eq!(d[(*first, *second, *third)], out);\n                                out += 1 as $value_type;\n                            }\n                        }\n                    }\n\n                    let gi = Module::base(global).function(\"getindex\")?;\n                    let one = Value::new(frame, 1usize)?;\n                    let two = Value::new(frame, 2usize)?;\n                    let three = Value::new(frame, 3usize)?;\n                    let four = Value::new(frame, 4usize)?;\n\n                    out = 1 as $value_type;\n                    for third in \u0026[one, two, three, four] {\n                        for second in \u0026[one, two, three] {\n                            for first in \u0026[one, two] {\n                                frame.frame(1, |frame| {\n                                    let v =\n                                        gi.call(frame, [array, *first, *second, *third])?.unwrap();\n                                    assert_eq!(v.cast::\u003c$value_type\u003e()?, out);\n                                    out += 1 as $value_type;\n                                    Ok(())\n                                })?;\n                            }\n                        }\n                    }\n\n                    Ok(())\n                })\n                .unwrap();\n            });\n        }\n\n        #[test]\n        fn $name_mut() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n\n                jlrs.frame(5, |global, frame| {\n                    let data: Vec\u003c$value_type\u003e = (1..=24).map(|x| x as $value_type).collect();\n\n                    let array = Value::move_array(frame, data, (2, 3, 4))?;\n                    let mut d = array\n                        .cast::\u003cArray\u003e()?\n                        .inline_data_mut::\u003c$value_type, _\u003e(frame)?;\n\n                    for third in \u0026[0, 1, 2, 3] {\n                        for second in \u0026[0, 1, 2] {\n                            for first in \u0026[0, 1] {\n                                d[(*first, *second, *third)] += 1 as $value_type;\n                            }\n                        }\n                    }\n                    let gi = Module::base(global).function(\"getindex\")?;\n                    let one = Value::new(frame, 1usize)?;\n                    let two = Value::new(frame, 2usize)?;\n                    let three = Value::new(frame, 3usize)?;\n                    let four = Value::new(frame, 4usize)?;\n\n                    let mut out = 2 as $value_type;\n                    for third in \u0026[one, two, three, four] {\n                        for second in \u0026[one, two, three] {\n                            for first in \u0026[one, two] {\n                                frame.frame(1, |frame| {\n                                    let v =\n                                        gi.call(frame, [array, *first, *second, *third])?.unwrap();\n                                    assert_eq!(v.cast::\u003c$value_type\u003e()?, out);\n                                    out += 1 as $value_type;\n                                    Ok(())\n                                })?;\n                            }\n                        }\n                    }\n\n                    Ok(())\n                })\n                .unwrap();\n            });\n        }\n\n        #[test]\n        fn $name_slice() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n\n                jlrs.frame(1, |_, frame| {\n                    let data: Vec\u003c$value_type\u003e = (1..=24).map(|x| x as $value_type).collect();\n\n                    let array = Value::move_array(frame, data.clone(), (2, 3, 4))?;\n                    let d = array\n                        .cast::\u003cArray\u003e()?\n                        .inline_data::\u003c$value_type, _\u003e(frame)?;\n\n                    for (a, b) in data.iter().zip(d.as_slice()) {\n                        assert_eq!(a, b)\n                    }\n\n                    Ok(())\n                })\n                .unwrap();\n            });\n        }\n\n        #[test]\n        fn $name_slice_mut() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n\n                jlrs.frame(1, |_, frame| {\n                    let data: Vec\u003c$value_type\u003e = (1..=24).map(|x| x as $value_type).collect();\n\n                    let array = Value::move_array(frame, data.clone(), (2, 3, 4))?;\n                    let mut d = array\n                        .cast::\u003cArray\u003e()?\n                        .inline_data_mut::\u003c$value_type, _\u003e(frame)?;\n\n                    for (a, b) in data.iter().zip(d.as_mut_slice()) {\n                        assert_eq!(a, b)\n                    }\n\n                    Ok(())\n                })\n                .unwrap();\n            });\n        }\n    };\n}\n\nimpl_test!(\n    array_data_3d_u8,\n    array_data_3d_u8_mut,\n    array_data_3d_u8_slice,\n    array_data_3d_u8_mut_slice,\n    u8\n);\nimpl_test!(\n    array_data_3d_u16,\n    array_data_3d_u16_mut,\n    array_data_3d_u16_slice,\n    array_data_3d_u16_mut_slice,\n    u16\n);\nimpl_test!(\n    array_data_3d_u32,\n    array_data_3d_u32_mut,\n    array_data_3d_u32_slice,\n    array_data_3d_u32_mut_slice,\n    u32\n);\nimpl_test!(\n    array_data_3d_u64,\n    array_data_3d_u64_mut,\n    array_data_3d_u64_slice,\n    array_data_3d_u64_mut_slice,\n    u64\n);\nimpl_test!(\n    array_data_3d_i8,\n    array_data_3d_i8_mut,\n    array_data_3d_i8_slice,\n    array_data_3d_i8_mut_slice,\n    i8\n);\nimpl_test!(\n    array_data_3d_i16,\n    array_data_3d_i16_mut,\n    array_data_3d_i16_slice,\n    array_data_3d_i16_mut_slice,\n    i16\n);\nimpl_test!(\n    array_data_3d_i32,\n    array_data_3d_i32_mut,\n    array_data_3d_i32_slice,\n    array_data_3d_i32_mut_slice,\n    i32\n);\nimpl_test!(\n    array_data_3d_i64,\n    array_data_3d_i64_mut,\n    array_data_3d_i64_slice,\n    array_data_3d_i64_mut_slice,\n    i64\n);\nimpl_test!(\n    array_data_3d_f32,\n    array_data_3d_f32_mut,\n    array_data_3d_f32_slice,\n    array_data_3d_f32_mut_slice,\n    f32\n);\nimpl_test!(\n    array_data_3d_f64,\n    array_data_3d_f64_mut,\n    array_data_3d_f64_slice,\n    array_data_3d_f64_mut_slice,\n    f64\n);\n\n#[test]\nfn borrow_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |global, frame| {\n            let data: Vec\u003cu8\u003e = (1..=24).map(|x| x as u8).collect();\n\n            let array = Value::move_array(frame, data, (2, 3, 4))?;\n\n            frame.frame(4, |frame| {\n                let d = unsafe {\n                    array\n                        .cast_unchecked::\u003cArray\u003e()\n                        .inline_data::\u003cu8, _\u003e(frame)?\n                };\n\n                let mut out = 1 as u8;\n                for third in \u0026[0, 1, 2, 3] {\n                    for second in \u0026[0, 1, 2] {\n                        for first in \u0026[0, 1] {\n                            assert_eq!(d[(*first, *second, *third)], out);\n                            out += 1 as u8;\n                        }\n                    }\n                }\n\n                let gi = Module::base(global).function(\"getindex\")?;\n                let one = Value::new(frame, 1usize)?;\n                let two = Value::new(frame, 2usize)?;\n                let three = Value::new(frame, 3usize)?;\n                let four = Value::new(frame, 4usize)?;\n\n                out = 1 as u8;\n                for third in \u0026[one, two, three, four] {\n                    for second in \u0026[one, two, three] {\n                        for first in \u0026[one, two] {\n                            frame.frame(1, |frame| {\n                                let v = gi.call(frame, [array, *first, *second, *third])?.unwrap();\n                                assert_eq!(v.cast::\u003cu8\u003e()?, out);\n                                out += 1 as u8;\n                                Ok(())\n                            })?;\n                        }\n                    }\n                }\n\n                Ok(())\n            })\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn access_borrowed_array_dimensions() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n            let arr = arr_val.cast::\u003cArray\u003e()?;\n\n            let data = arr.inline_data::\u003cf32, _\u003e(frame)?;\n            assert_eq!(data.dimensions().as_slice(), \u0026[1, 2]);\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn access_mutable_borrowed_array_dimensions() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n            let arr = arr_val.cast::\u003cArray\u003e()?;\n\n            let data = arr.inline_data_mut::\u003cf32, _\u003e(frame)?;\n            assert_eq!(data.dimensions().as_slice(), \u0026[1, 2]);\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn unrestricted_array_borrow() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |_, frame| {\n            unsafe {\n                let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n                let arr_val2 = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n                let arr = arr_val.cast::\u003cArray\u003e()?;\n                let arr2 = arr_val2.cast::\u003cArray\u003e()?;\n\n                let data = arr.unrestricted_inline_data_mut::\u003cf32, _\u003e(frame)?;\n                let data2 = arr2.unrestricted_inline_data_mut::\u003cf32, _\u003e(frame)?;\n                assert_eq!(data.dimensions().as_slice(), data2.dimensions().as_slice());\n            }\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn unrestricted_typed_array_borrow() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |_, frame| {\n            unsafe {\n                let arr_val = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n                let arr_val2 = Value::new_array::\u003cf32, _, _\u003e(frame, (1, 2))?;\n                let arr = arr_val.cast::\u003cTypedArray\u003cf32\u003e\u003e()?;\n                let arr2 = arr_val2.cast::\u003cTypedArray\u003cf32\u003e\u003e()?;\n\n                let data = arr.unrestricted_inline_data_mut(frame)?;\n                let data2 = arr2.unrestricted_inline_data_mut(frame)?;\n                assert_eq!(data.dimensions().as_slice(), data2.dimensions().as_slice());\n            }\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn value_data() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |global, frame| {\n            unsafe {\n                let arr = Module::main(global)\n                    .submodule(\"JlrsTests\")?\n                    .function(\"vecofmodules\")?\n                    .call0(frame)?\n                    .unwrap()\n                    .cast::\u003cArray\u003e()?;\n                let data = arr.value_data(frame)?;\n\n                assert!(data[0].is::\u003cModule\u003e());\n            }\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn value_data_mut() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(3, |global, frame| {\n            unsafe {\n                let submod = Module::main(global).submodule(\"JlrsTests\")?;\n                let arr = submod\n                    .function(\"vecofmodules\")?\n                    .call0(frame)?\n                    .unwrap()\n                    .cast::\u003cArray\u003e()?;\n                let mut data = arr.value_data_mut(frame)?;\n                data.set(0, submod.into())?;\n\n                let getindex = Module::base(global).function(\"getindex\")?;\n                let idx = Value::new(frame, 1usize)?;\n                let entry = getindex\n                    .call2(frame, arr.into(), idx)?\n                    .unwrap()\n                    .cast::\u003cModule\u003e()?;\n\n                assert_eq!(entry.name().hash(), submod.name().hash());\n            }\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn unrestricted_value_data_mut() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(6, |global, frame| {\n            unsafe {\n                let submod = Module::main(global).submodule(\"JlrsTests\")?;\n                let arr1 = submod\n                    .function(\"vecofmodules\")?\n                    .call0(frame)?\n                    .unwrap()\n                    .cast::\u003cArray\u003e()?;\n\n                let arr2 = submod\n                    .function(\"anothervecofmodules\")?\n                    .call0(frame)?\n                    .unwrap()\n                    .cast::\u003cArray\u003e()?;\n\n                let mut data1 = arr1.unrestricted_value_data_mut(frame)?;\n                let mut data2 = arr2.unrestricted_value_data_mut(frame)?;\n                data1.set(0, submod.into())?;\n                data2.set(1, submod.into())?;\n\n                let getindex = Module::base(global).function(\"getindex\")?;\n                let idx1 = Value::new(frame, 1usize)?;\n                let idx2 = Value::new(frame, 2usize)?;\n                let entry1 = getindex\n                    .call2(frame, arr1.into(), idx1)?\n                    .unwrap()\n                    .cast::\u003cModule\u003e()?;\n                let entry2 = getindex\n                    .call2(frame, arr2.into(), idx2)?\n                    .unwrap()\n                    .cast::\u003cModule\u003e()?;\n\n                assert_eq!(entry1.name().hash(), entry2.name().hash());\n            }\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn typed_array_value_data() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |global, frame| {\n            unsafe {\n                let arr = Module::main(global)\n                    .submodule(\"JlrsTests\")?\n                    .function(\"vecofmodules\")?\n                    .call0(frame)?\n                    .unwrap()\n                    .cast::\u003cTypedArray\u003cModule\u003e\u003e()?;\n                let data = arr.value_data(frame)?;\n\n                assert!(data[0].is::\u003cModule\u003e());\n            }\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn typed_array_value_data_mut() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(3, |global, frame| {\n            unsafe {\n                let submod = Module::main(global).submodule(\"JlrsTests\")?;\n                let arr = submod\n                    .function(\"vecofmodules\")?\n                    .call0(frame)?\n                    .unwrap()\n                    .cast::\u003cTypedArray\u003cModule\u003e\u003e()?;\n                let mut data = arr.value_data_mut(frame)?;\n                data.set(0, submod.into())?;\n\n                let getindex = Module::base(global).function(\"getindex\")?;\n                let idx = Value::new(frame, 1usize)?;\n                let entry = getindex\n                    .call2(frame, arr.into(), idx)?\n                    .unwrap()\n                    .cast::\u003cModule\u003e()?;\n\n                assert_eq!(entry.name().hash(), submod.name().hash());\n            }\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn typed_array_unrestricted_value_data_mut() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(6, |global, frame| {\n            unsafe {\n                let submod = Module::main(global).submodule(\"JlrsTests\")?;\n                let arr1 = submod\n                    .function(\"vecofmodules\")?\n                    .call0(frame)?\n                    .unwrap()\n                    .cast::\u003cTypedArray\u003cModule\u003e\u003e()?;\n\n                let arr2 = submod\n                    .function(\"anothervecofmodules\")?\n                    .call0(frame)?\n                    .unwrap()\n                    .cast::\u003cTypedArray\u003cModule\u003e\u003e()?;\n\n                let mut data1 = arr1.unrestricted_value_data_mut(frame)?;\n                let mut data2 = arr2.unrestricted_value_data_mut(frame)?;\n                data1.set(0, submod.into())?;\n                data2.set(1, submod.into())?;\n\n                let getindex = Module::base(global).function(\"getindex\")?;\n                let idx1 = Value::new(frame, 1usize)?;\n                let idx2 = Value::new(frame, 2usize)?;\n                let entry1 = getindex\n                    .call2(frame, arr1.into(), idx1)?\n                    .unwrap()\n                    .cast::\u003cModule\u003e()?;\n                let entry2 = getindex\n                    .call2(frame, arr2.into(), idx2)?\n                    .unwrap()\n                    .cast::\u003cModule\u003e()?;\n\n                assert_eq!(entry1.name().hash(), entry2.name().hash());\n            }\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n","traces":[{"line":7,"address":4218448,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":8,"address":4224032,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":9,"address":4224041,"length":1,"stats":{"Line":10},"fn_name":null},{"line":11,"address":4219584,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":12,"address":4218480,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":14,"address":4219692,"length":1,"stats":{"Line":10},"fn_name":null},{"line":15,"address":4219908,"length":1,"stats":{"Line":10},"fn_name":null},{"line":16,"address":4220077,"length":1,"stats":{"Line":10},"fn_name":null},{"line":17,"address":4220094,"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":4220405,"length":1,"stats":{"Line":10},"fn_name":null},{"line":20,"address":4220413,"length":1,"stats":{"Line":10},"fn_name":null},{"line":21,"address":4220705,"length":1,"stats":{"Line":10},"fn_name":null},{"line":22,"address":4220882,"length":1,"stats":{"Line":10},"fn_name":null},{"line":23,"address":4221059,"length":1,"stats":{"Line":10},"fn_name":null},{"line":24,"address":4221246,"length":1,"stats":{"Line":10},"fn_name":null},{"line":29,"address":4220649,"length":1,"stats":{"Line":10},"fn_name":null},{"line":30,"address":4221839,"length":1,"stats":{"Line":10},"fn_name":null},{"line":31,"address":4222105,"length":1,"stats":{"Line":10},"fn_name":null},{"line":32,"address":4222358,"length":1,"stats":{"Line":10},"fn_name":null},{"line":33,"address":4222611,"length":1,"stats":{"Line":10},"fn_name":null},{"line":35,"address":4222837,"length":1,"stats":{"Line":10},"fn_name":null},{"line":36,"address":4222853,"length":1,"stats":{"Line":10},"fn_name":null},{"line":37,"address":4223158,"length":1,"stats":{"Line":10},"fn_name":null},{"line":38,"address":4223354,"length":1,"stats":{"Line":10},"fn_name":null},{"line":39,"address":4218512,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":41,"address":4218527,"length":1,"stats":{"Line":10},"fn_name":null},{"line":42,"address":4218870,"length":1,"stats":{"Line":10},"fn_name":null},{"line":43,"address":4219129,"length":1,"stats":{"Line":10},"fn_name":null},{"line":44,"address":4219480,"length":1,"stats":{"Line":10},"fn_name":null},{"line":50,"address":4223086,"length":1,"stats":{"Line":10},"fn_name":null},{"line":57,"address":4224192,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":58,"address":4229312,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":59,"address":4229321,"length":1,"stats":{"Line":10},"fn_name":null},{"line":61,"address":4225328,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":62,"address":4224224,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":64,"address":4225436,"length":1,"stats":{"Line":10},"fn_name":null},{"line":65,"address":4225652,"length":1,"stats":{"Line":10},"fn_name":null},{"line":66,"address":4225821,"length":1,"stats":{"Line":10},"fn_name":null},{"line":67,"address":4225838,"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":4226149,"length":1,"stats":{"Line":10},"fn_name":null},{"line":70,"address":4226441,"length":1,"stats":{"Line":10},"fn_name":null},{"line":71,"address":4226618,"length":1,"stats":{"Line":10},"fn_name":null},{"line":72,"address":4226795,"length":1,"stats":{"Line":10},"fn_name":null},{"line":76,"address":4226385,"length":1,"stats":{"Line":10},"fn_name":null},{"line":77,"address":4227117,"length":1,"stats":{"Line":10},"fn_name":null},{"line":78,"address":4227383,"length":1,"stats":{"Line":10},"fn_name":null},{"line":79,"address":4227636,"length":1,"stats":{"Line":10},"fn_name":null},{"line":80,"address":4227889,"length":1,"stats":{"Line":10},"fn_name":null},{"line":82,"address":4228115,"length":1,"stats":{"Line":10},"fn_name":null},{"line":83,"address":4228131,"length":1,"stats":{"Line":10},"fn_name":null},{"line":84,"address":4228436,"length":1,"stats":{"Line":10},"fn_name":null},{"line":85,"address":4228632,"length":1,"stats":{"Line":10},"fn_name":null},{"line":86,"address":4224256,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":88,"address":4224271,"length":1,"stats":{"Line":10},"fn_name":null},{"line":89,"address":4224614,"length":1,"stats":{"Line":10},"fn_name":null},{"line":90,"address":4224873,"length":1,"stats":{"Line":10},"fn_name":null},{"line":91,"address":4225224,"length":1,"stats":{"Line":10},"fn_name":null},{"line":97,"address":4228364,"length":1,"stats":{"Line":10},"fn_name":null},{"line":104,"address":4229472,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":105,"address":4231472,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":106,"address":4231481,"length":1,"stats":{"Line":10},"fn_name":null},{"line":108,"address":4229536,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":109,"address":4229504,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":111,"address":4229660,"length":1,"stats":{"Line":10},"fn_name":null},{"line":112,"address":4229887,"length":1,"stats":{"Line":10},"fn_name":null},{"line":113,"address":4230099,"length":1,"stats":{"Line":10},"fn_name":null},{"line":114,"address":4230116,"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":4230427,"length":1,"stats":{"Line":10},"fn_name":null},{"line":117,"address":4230940,"length":1,"stats":{"Line":10},"fn_name":null},{"line":120,"address":4230836,"length":1,"stats":{"Line":10},"fn_name":null},{"line":127,"address":4231632,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":128,"address":4233632,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":129,"address":4233641,"length":1,"stats":{"Line":10},"fn_name":null},{"line":131,"address":4231696,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":132,"address":4231664,"length":1,"stats":{"Line":20},"fn_name":"{{closure}}"},{"line":134,"address":4231820,"length":1,"stats":{"Line":10},"fn_name":null},{"line":135,"address":4232047,"length":1,"stats":{"Line":10},"fn_name":null},{"line":136,"address":4232259,"length":1,"stats":{"Line":10},"fn_name":null},{"line":137,"address":4232276,"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":4232587,"length":1,"stats":{"Line":10},"fn_name":null},{"line":140,"address":4233100,"length":1,"stats":{"Line":10},"fn_name":null},{"line":143,"address":4232996,"length":1,"stats":{"Line":10},"fn_name":null},{"line":151,"address":4218453,"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":4239573,"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":4260213,"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":4264501,"length":1,"stats":{"Line":3},"fn_name":null},{"line":179,"address":4279877,"length":1,"stats":{"Line":3},"fn_name":null},{"line":186,"address":4295157,"length":1,"stats":{"Line":3},"fn_name":null},{"line":193,"address":4316293,"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":4325861,"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":4354245,"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":4362101,"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":4371605,"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":4371600,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":224,"address":4377072,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":225,"address":4377081,"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":4376624,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":228,"address":4371632,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":230,"address":4376697,"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":4372736,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":234,"address":4372767,"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":4372869,"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":4373019,"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":4373027,"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":4373332,"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":4373509,"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":4373686,"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":4373873,"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":4373276,"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":4374466,"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":4374732,"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":4374985,"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":4375238,"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":4375464,"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":4375480,"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":4375785,"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":4375981,"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":4371664,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":260,"address":4371679,"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":4372022,"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":4372281,"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":4372632,"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":4375713,"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":4377232,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":278,"address":4378640,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":279,"address":4378649,"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":4377264,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":282,"address":4377279,"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":4377449,"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":4377659,"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":4377955,"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":4378210,"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":4378805,"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":4378800,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":296,"address":4380208,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":297,"address":4380217,"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":4378832,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":300,"address":4378847,"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":4379017,"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":4379227,"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":4379523,"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":4379778,"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":4380368,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":314,"address":4382784,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":315,"address":4382793,"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":4380400,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":319,"address":4380415,"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":4380585,"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":4380868,"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":4381078,"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":4381272,"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":4381597,"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":4381891,"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":4382593,"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":4382944,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":337,"address":4385360,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":338,"address":4385369,"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":4382976,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":342,"address":4382991,"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":4383161,"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":4383444,"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":4383654,"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":4383848,"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":4384173,"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":4384467,"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":4385169,"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":4385520,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":360,"address":4387008,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":361,"address":4387017,"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":4385552,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":365,"address":4385575,"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":4385687,"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":4385934,"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":4386101,"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":4385704,"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":4386377,"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":4386653,"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":4386859,"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":4387168,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":383,"address":4390512,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":384,"address":4390521,"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":4387200,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":388,"address":4387223,"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":4387385,"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":4387570,"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":4387749,"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":4387587,"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":4388067,"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":4388363,"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":4388597,"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":4388906,"length":1,"stats":{"Line":1},"fn_name":null},{"line":399,"address":4389301,"length":1,"stats":{"Line":1},"fn_name":null},{"line":400,"address":4389138,"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":4389352,"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":4389653,"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":4390265,"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":4390672,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":414,"address":4396224,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":415,"address":4396233,"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":4390704,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":419,"address":4390727,"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":4390889,"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":4391074,"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":4391253,"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":4391091,"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":4391586,"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":4391755,"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":4391934,"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":4391772,"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":4392252,"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":4392577,"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":4392863,"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":4393110,"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":4393345,"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":4393641,"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":4393894,"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":4394289,"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":4394126,"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":4394340,"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":4394804,"length":1,"stats":{"Line":1},"fn_name":null},{"line":445,"address":4394641,"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":4394855,"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":4395156,"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":4395794,"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":4396384,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":459,"address":4397872,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":460,"address":4397881,"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":4396416,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":464,"address":4396439,"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":4396551,"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":4396798,"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":4396965,"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":4396568,"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":4397241,"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":4397517,"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":4397723,"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":4398032,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":482,"address":4401376,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":483,"address":4401385,"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":4398064,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":487,"address":4398087,"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":4398249,"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":4398434,"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":4398613,"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":4398451,"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":4398931,"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":4399227,"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":4399461,"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":4399770,"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":4400161,"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":4400018,"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":4400212,"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":4400513,"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":4401125,"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":4401536,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":513,"address":4407072,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":514,"address":4407081,"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":4401568,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":518,"address":4401591,"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":4401753,"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":4401938,"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":4402117,"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":4401955,"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":4402450,"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":4402619,"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":4402798,"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":4402636,"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":4403116,"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":4403441,"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":4403727,"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":4403974,"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":4404209,"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":4404505,"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":4404758,"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":4405149,"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":4405006,"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":4405200,"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":4405660,"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":4405517,"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":4405711,"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":4406012,"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":4406650,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":264,"coverable":282},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","bounds_error.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn bounds_error() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        let oob_idx = jlrs\n            .frame(0, |global, frame| {\n                frame.frame(5, |frame| {\n                    let idx = Value::new(frame, 4usize)?;\n                    let data = vec![1.0f64, 2., 3.];\n                    let array = Value::move_array(frame, data, 3)?;\n                    let func = Module::base(global).function(\"getindex\")?;\n                    let out = func.call2(frame, array, idx)?.unwrap_err();\n\n                    assert_eq!(out.type_name(), \"BoundsError\");\n\n                    let field_names = out.field_names();\n                    let f0: String = field_names[0].into();\n                    assert_eq!(f0, \"a\");\n                    let f1: String = field_names[1].into();\n                    assert_eq!(f1, \"i\");\n\n                    out.get_field(frame, field_names[1])?\n                        .get_nth_field(frame, 0)?\n                        .cast::\u003cisize\u003e()\n                })\n            })\n            .unwrap();\n\n        assert_eq!(oob_idx, 4);\n    });\n}\n","traces":[{"line":5,"address":4218192,"length":1,"stats":{"Line":2},"fn_name":"bounds_error"},{"line":6,"address":4218193,"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":4236639,"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":4236675,"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":4236560,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":10,"address":4232912,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":11,"address":4232946,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4233092,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4233266,"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":4233451,"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":4233673,"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":4233981,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4234127,"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":4234517,"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":4234560,"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":4234693,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4235122,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4235255,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4235988,"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":4236764,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","ccall.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\nunsafe extern \"C\" fn uses_null_frame(array: TypedArray\u003cf64\u003e) -\u003e bool {\n    let mut ccall = CCall::new(0);\n\n    let out = ccall.null_frame(|frame| {\n        let borrowed = array.inline_data(frame)?;\n        Ok(borrowed[1] == 1.0)\n    });\n\n    if let Ok(o) = out {\n        o\n    } else {\n        false\n    }\n}\n\n#[test]\nfn ccall_with_array() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|global, frame| {\n            let fn_ptr = Value::new(frame, uses_null_frame as *mut std::ffi::c_void)?;\n            let mut arr_data = vec![0.0f64, 1.0f64];\n            let arr = Value::borrow_array(frame, \u0026mut arr_data, 2)?;\n            let func = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"callrustwitharr\")?;\n\n            let out = func.call2(frame, fn_ptr, arr)?.unwrap();\n            let ok = out.cast::\u003cbool\u003e()?;\n            assert!(ok);\n            Ok(())\n        })\n        .unwrap()\n    })\n}\n","traces":[{"line":4,"address":4228448,"length":1,"stats":{"Line":1},"fn_name":"uses_null_frame"},{"line":5,"address":4228460,"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":4219600,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":8,"address":4219626,"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":4219819,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4228515,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4228567,"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":4228547,"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":4220032,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":21,"address":4221744,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":22,"address":4221753,"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":4220064,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":25,"address":4220094,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4220219,"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":4220410,"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":4220569,"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":4220793,"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":4220810,"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":4221054,"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":4221367,"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":4221455,"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":4221537,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":22},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","datatype.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\nuse jlrs::value::code_instance::CodeInstance;\nuse jlrs::value::datatype::*;\nuse jlrs::value::expr::Expr;\nuse jlrs::value::method::Method;\nuse jlrs::value::method_instance::MethodInstance;\nuse jlrs::value::simple_vector::SimpleVector;\nuse jlrs::value::type_name::TypeName;\nuse jlrs::value::type_var::TypeVar;\nuse jlrs::value::union::Union;\nuse jlrs::value::union_all::UnionAll;\n\n#[test]\nfn datatype_methods() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_global, frame| {\n            let val = Value::new(frame, 3.0f32)?;\n            let dt = val.datatype().unwrap();\n\n            assert_eq!(dt.size(), 4);\n            assert_eq!(dt.align(), 4);\n            assert_eq!(dt.nbits(), 32);\n            assert_eq!(dt.nfields(), 0);\n            assert!(dt.isinlinealloc());\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn datatype_typechecks() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_global, frame| {\n            let val = Value::new(frame, 3.0f32)?;\n            let dt = val.datatype().unwrap();\n\n            assert!(!dt.is::\u003cTuple\u003e());\n            assert!(!dt.is::\u003cNamedTuple\u003e());\n            assert!(!dt.is::\u003cSimpleVector\u003e());\n            assert!(!dt.is::\u003cMutable\u003e());\n            assert!(!dt.is::\u003cMutableDatatype\u003e());\n            assert!(dt.is::\u003cImmutable\u003e());\n            assert!(!dt.is::\u003cImmutableDatatype\u003e());\n            assert!(!dt.is::\u003cUnion\u003e());\n            assert!(!dt.is::\u003cTypeVar\u003e());\n            assert!(!dt.is::\u003cUnionAll\u003e());\n            assert!(!dt.is::\u003cTypeName\u003e());\n            assert!(!dt.is::\u003ci8\u003e());\n            assert!(!dt.is::\u003ci16\u003e());\n            assert!(!dt.is::\u003ci32\u003e());\n            assert!(!dt.is::\u003ci64\u003e());\n            assert!(!dt.is::\u003cu8\u003e());\n            assert!(!dt.is::\u003cu16\u003e());\n            assert!(!dt.is::\u003cu32\u003e());\n            assert!(!dt.is::\u003cu64\u003e());\n            assert!(dt.is::\u003cf32\u003e());\n            assert!(!dt.is::\u003cf64\u003e());\n            assert!(!dt.is::\u003cbool\u003e());\n            assert!(!dt.is::\u003cchar\u003e());\n            assert!(!dt.is::\u003cSymbol\u003e());\n            assert!(!dt.is::\u003cArray\u003e());\n            assert!(!dt.is::\u003cSlot\u003e());\n            assert!(!dt.is::\u003cExpr\u003e());\n            assert!(!dt.is::\u003cGlobalRef\u003e());\n            assert!(!dt.is::\u003cGotoNode\u003e());\n            assert!(!dt.is::\u003cPhiNode\u003e());\n            assert!(!dt.is::\u003cPhiCNode\u003e());\n            assert!(!dt.is::\u003cUpsilonNode\u003e());\n            assert!(!dt.is::\u003cQuoteNode\u003e());\n            assert!(!dt.is::\u003cLineNode\u003e());\n            assert!(!dt.is::\u003cMethodInstance\u003e());\n            assert!(!dt.is::\u003cCodeInstance\u003e());\n            assert!(!dt.is::\u003cMethod\u003e());\n            assert!(!dt.is::\u003cModule\u003e());\n            assert!(!dt.is::\u003cString\u003e());\n            assert!(!dt.is::\u003cPointer\u003e());\n            assert!(!dt.is::\u003cIntrinsic\u003e());\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn function_returns_datatype() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |global, frame| {\n            let dt = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"datatype\")?;\n            let dt_val = dt.call0(frame)?.unwrap();\n\n            assert!(dt_val.is::\u003cDataType\u003e());\n            assert!(dt_val.cast::\u003cDataType\u003e().is_ok());\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n","traces":[{"line":15,"address":4220480,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":16,"address":4222672,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":17,"address":4222681,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4220512,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":20,"address":4220535,"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":4220653,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4220837,"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":4220955,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4221413,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4221868,"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":4222287,"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":4222596,"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":4222832,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":37,"address":4225552,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":38,"address":4225561,"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":4222864,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":41,"address":4222887,"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":4222981,"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":4223126,"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":4223152,"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":4223210,"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":4223269,"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":4223327,"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":4223385,"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":4223441,"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":4223499,"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":4223558,"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":4223617,"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":4223676,"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":4223735,"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":4223794,"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":4223853,"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":4223912,"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":4223971,"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":4224030,"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":4224089,"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":4224148,"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":4224207,"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":4224264,"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":4224323,"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":4224382,"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":4224441,"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":4224500,"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":4224559,"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":4224617,"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":4224676,"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":4224734,"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":4224792,"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":4224850,"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":4224908,"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":4224966,"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":4225024,"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":4225082,"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":4225141,"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":4225200,"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":4225259,"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":4225318,"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":4225377,"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":4225435,"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":4225488,"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":4225712,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":94,"address":4226704,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":95,"address":4226713,"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":4225744,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":97,"address":4225764,"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":4225858,"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":4225875,"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":4226121,"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":4226410,"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":4226433,"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":4226569,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":70,"coverable":71},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","functions.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn call0() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |global, frame| {\n            let func = Module::base(global).function(\"vect\")?;\n            func.call0(frame)?.unwrap();\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn call0_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"vect\")?;\n            func.with_output(output).call0(frame).unwrap();\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn call0_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|global, frame| {\n            let func = Module::base(global).function(\"vect\")?;\n            func.call0(frame)?.unwrap();\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn call0_dynamic_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"vect\")?;\n            func.with_output(output).call0(frame).unwrap();\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn call1() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(2, |global, frame| {\n            let func = Module::base(global).function(\"cos\")?;\n            let angle = Value::new(frame, std::f32::consts::PI)?;\n            let out = func.call1(frame, angle)?.unwrap();\n            out.cast::\u003cf32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), -1.);\n    });\n}\n\n#[test]\nfn call1_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(2, |global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"cos\")?;\n            let angle = Value::new(frame, std::f32::consts::PI)?;\n            let out = func.with_output(output).call1(frame, angle).unwrap();\n            out.cast::\u003cf32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), -1.);\n    });\n}\n\n#[test]\nfn call1_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let func = Module::base(global).function(\"cos\")?;\n            let angle = Value::new(frame, std::f32::consts::PI)?;\n            let out = func.call1(frame, angle)?.unwrap();\n            out.cast::\u003cf32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), -1.);\n    });\n}\n\n#[test]\nfn call1_dynamic_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"cos\")?;\n            let angle = Value::new(frame, std::f32::consts::PI)?;\n            let out = func.with_output(output).call1(frame, angle).unwrap();\n            out.cast::\u003cf32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), -1.);\n    });\n}\n\n#[test]\nfn call2() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(3, |global, frame| {\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let out = func.call2(frame, arg0, arg1)?.unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 3);\n    });\n}\n\n#[test]\nfn call2_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(3, |global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let out = func.with_output(output).call2(frame, arg0, arg1).unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 3);\n    });\n}\n\n#[test]\nfn call2_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let out = func.call2(frame, arg0, arg1)?.unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 3);\n    });\n}\n\n#[test]\nfn call2_dynamic_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let out = func.with_output(output).call2(frame, arg0, arg1).unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 3);\n    });\n}\n\n#[test]\nfn call3() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(4, |global, frame| {\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let arg2 = Value::new(frame, 3u32)?;\n            let out = func.call3(frame, arg0, arg1, arg2)?.unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 6);\n    });\n}\n\n#[test]\nfn call3_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(4, |global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let arg2 = Value::new(frame, 3u32)?;\n            let out = func\n                .with_output(output)\n                .call3(frame, arg0, arg1, arg2)\n                .unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 6);\n    });\n}\n\n#[test]\nfn call3_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let arg2 = Value::new(frame, 3u32)?;\n            let out = func.call3(frame, arg0, arg1, arg2)?.unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 6);\n    });\n}\n\n#[test]\nfn call3_dynamic_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let arg2 = Value::new(frame, 3u32)?;\n            let out = func\n                .with_output(output)\n                .call3(frame, arg0, arg1, arg2)\n                .unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 6);\n    });\n}\n\n#[test]\nfn call() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(5, |global, frame| {\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let arg2 = Value::new(frame, 3u32)?;\n            let arg3 = Value::new(frame, 4u32)?;\n            let out = func.call(frame, [arg0, arg1, arg2, arg3])?.unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 10);\n    });\n}\n\n#[test]\nfn call_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(5, |global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let arg2 = Value::new(frame, 3u32)?;\n            let arg3 = Value::new(frame, 4u32)?;\n            func.with_output(output)\n                .call(frame, [arg0, arg1, arg2, arg3])\n                .unwrap()\n                .cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 10);\n    });\n}\n\n#[test]\nfn call_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let arg2 = Value::new(frame, 3u32)?;\n            let arg3 = Value::new(frame, 4u32)?;\n            let out = func.call(frame, [arg0, arg1, arg2, arg3])?.unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 10);\n    });\n}\n\n#[test]\nfn call_dynamic_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"+\")?;\n            let arg0 = Value::new(frame, 1u32)?;\n            let arg1 = Value::new(frame, 2u32)?;\n            let arg2 = Value::new(frame, 3u32)?;\n            let arg3 = Value::new(frame, 4u32)?;\n            let out = func\n                .with_output(output)\n                .call(frame, [arg0, arg1, arg2, arg3])\n                .unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 10);\n    });\n}\n\n#[test]\nfn call_values() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(5, |global, frame| {\n            let func = Module::base(global).function(\"+\")?;\n            let args = Values::new(frame, [1u32, 2u32, 3u32, 4u32])?;\n            let out = func.call_values(frame, args)?.unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 10);\n    });\n}\n\n#[test]\nfn call_values_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.frame(5, |global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"+\")?;\n            let args = Values::new(frame, [1u32, 2u32, 3u32, 4u32])?;\n            let out = func.with_output(output).call_values(frame, args).unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 10);\n    });\n}\n\n#[test]\nfn call_values_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let func = Module::base(global).function(\"+\")?;\n            let args = Values::new(frame, [1u32, 2u32, 3u32, 4u32])?;\n            let out = func.call_values(frame, args)?.unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 10);\n    });\n}\n\n#[test]\nfn call_values_dynamic_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let out = jlrs.dynamic_frame(|global, frame| {\n            let output = frame.output()?;\n            let func = Module::base(global).function(\"+\")?;\n            let args = Values::new(frame, [1u32, 2u32, 3u32, 4u32])?;\n            let out = func.with_output(output).call_values(frame, args).unwrap();\n            out.cast::\u003cu32\u003e()\n        });\n\n        assert_eq!(out.unwrap(), 10);\n    });\n}\n\n#[test]\nfn jlrs_extensions_available() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|global, frame| {\n            let func = Module::base(global).function(\"+\")?;\n            assert!(func.attach_stacktrace(frame).is_ok());\n            assert!(func.tracing_call(frame).is_ok());\n\n            let o1 = frame.output()?;\n            let o2 = frame.output()?;\n            assert!(func.with_output(o1).attach_stacktrace(frame).is_ok());\n            assert!(func.with_output(o2).tracing_call(frame).is_ok());\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n","traces":[{"line":5,"address":4217632,"length":1,"stats":{"Line":2},"fn_name":"call0"},{"line":6,"address":4217633,"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":4219433,"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":4218960,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":10,"address":4218980,"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":4219110,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4219361,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4217648,"length":1,"stats":{"Line":2},"fn_name":"call0_output"},{"line":20,"address":4217649,"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":4220169,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4219616,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":24,"address":4219631,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4219736,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4219946,"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":4220098,"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":4217664,"length":1,"stats":{"Line":2},"fn_name":"call0_dynamic"},{"line":35,"address":4217665,"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":4220825,"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":4220352,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":39,"address":4220372,"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":4220502,"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":4220753,"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":4217680,"length":1,"stats":{"Line":2},"fn_name":"call0_dynamic_output"},{"line":49,"address":4217681,"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":4221545,"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":4220992,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":53,"address":4221007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":4221112,"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":4221322,"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":4221474,"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":4217696,"length":1,"stats":{"Line":2},"fn_name":"call1"},{"line":64,"address":4217697,"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":4222431,"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":4221712,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":68,"address":4221745,"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":4221893,"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":4222063,"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":4222339,"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":4222523,"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":4217712,"length":1,"stats":{"Line":2},"fn_name":"call1_output"},{"line":80,"address":4217713,"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":4223903,"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":4223072,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":84,"address":4223090,"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":4223221,"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":4223453,"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":4223637,"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":4223810,"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":4223995,"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":4217728,"length":1,"stats":{"Line":2},"fn_name":"call1_dynamic"},{"line":97,"address":4217729,"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":4225263,"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":4224544,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":101,"address":4224577,"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":4224725,"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":4224895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":4225170,"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":4225350,"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":4217744,"length":1,"stats":{"Line":2},"fn_name":"call1_dynamic_output"},{"line":113,"address":4217745,"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":4226719,"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":4225888,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":117,"address":4225906,"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":4226037,"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":4226269,"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":4226453,"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":4226626,"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":4226806,"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":4217760,"length":1,"stats":{"Line":2},"fn_name":"call2"},{"line":130,"address":4217761,"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":4228287,"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":4227344,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":134,"address":4227380,"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":4227530,"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":4227721,"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":4227894,"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":4228175,"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":4228379,"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":4217776,"length":1,"stats":{"Line":2},"fn_name":"call2_output"},{"line":147,"address":4217777,"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":4229967,"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":4228912,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":151,"address":4228930,"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":4229061,"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":4229298,"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":4229482,"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":4229676,"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":4229852,"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":4230059,"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":4217792,"length":1,"stats":{"Line":2},"fn_name":"call2_dynamic"},{"line":165,"address":4217793,"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":4231535,"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":4230592,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":169,"address":4230628,"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":4230778,"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":4230969,"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":4231142,"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":4231423,"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":4231622,"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":4217808,"length":1,"stats":{"Line":2},"fn_name":"call2_dynamic_output"},{"line":182,"address":4217809,"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":4233199,"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":4232144,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":186,"address":4232162,"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":4232293,"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":4232530,"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":4232714,"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":4232908,"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":4233084,"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":4233286,"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":4217824,"length":1,"stats":{"Line":2},"fn_name":"call3"},{"line":200,"address":4217825,"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":4235007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":4233808,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":204,"address":4233850,"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":4234018,"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":4234215,"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":4234399,"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":4234575,"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":4234872,"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":4235099,"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":4217840,"length":1,"stats":{"Line":2},"fn_name":"call3_output"},{"line":218,"address":4217841,"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":4236927,"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":4235632,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":222,"address":4235650,"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":4235781,"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":4236024,"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":4236229,"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":4236413,"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":4236610,"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":4236793,"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":4237019,"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":4217856,"length":1,"stats":{"Line":2},"fn_name":"call3_dynamic"},{"line":240,"address":4217857,"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":4238751,"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":4237552,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":244,"address":4237594,"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":4237762,"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":4237959,"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":4238143,"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":4238319,"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":4238616,"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":4238838,"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":4217872,"length":1,"stats":{"Line":2},"fn_name":"call3_dynamic_output"},{"line":258,"address":4217873,"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":4240655,"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":4239360,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":262,"address":4239378,"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":4239509,"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":4239752,"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":4239957,"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":4240141,"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":4240338,"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":4240521,"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":4240742,"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":4217888,"length":1,"stats":{"Line":2},"fn_name":"call"},{"line":280,"address":4217889,"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":4242719,"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":4241264,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":284,"address":4241306,"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":4241474,"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":4241686,"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":4241870,"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":4242054,"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":4242235,"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":4242570,"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":4242811,"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":4217904,"length":1,"stats":{"Line":2},"fn_name":"call_output"},{"line":299,"address":4217905,"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":4244895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":4243344,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":303,"address":4243362,"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":4243493,"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":4243736,"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":4243941,"length":1,"stats":{"Line":1},"fn_name":null},{"line":307,"address":4244146,"length":1,"stats":{"Line":1},"fn_name":null},{"line":308,"address":4244330,"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":4244527,"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":4244619,"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":4244987,"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":4217920,"length":1,"stats":{"Line":2},"fn_name":"call_dynamic"},{"line":321,"address":4217921,"length":1,"stats":{"Line":2},"fn_name":null},{"line":322,"address":4246975,"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":4245520,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":325,"address":4245562,"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":4245730,"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":4245942,"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":4246126,"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":4246310,"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":4246491,"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":4246826,"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":4247062,"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":4217936,"length":1,"stats":{"Line":2},"fn_name":"call_dynamic_output"},{"line":340,"address":4217937,"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":4249135,"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":4247584,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":344,"address":4247602,"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":4247733,"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":4247976,"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":4248181,"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":4248380,"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":4248564,"length":1,"stats":{"Line":1},"fn_name":null},{"line":350,"address":4248761,"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":4248853,"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":4248990,"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":4249222,"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":4217952,"length":1,"stats":{"Line":2},"fn_name":"call_values"},{"line":363,"address":4217953,"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":4250511,"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":4249744,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":367,"address":4249777,"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":4249907,"length":1,"stats":{"Line":1},"fn_name":null},{"line":369,"address":4250138,"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":4250418,"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":4250603,"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":4217968,"length":1,"stats":{"Line":2},"fn_name":"call_values_output"},{"line":379,"address":4217969,"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":4252015,"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":4251136,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":383,"address":4251154,"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":4251279,"length":1,"stats":{"Line":1},"fn_name":null},{"line":385,"address":4251487,"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":4251746,"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":4251922,"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":4252107,"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":4217984,"length":1,"stats":{"Line":2},"fn_name":"call_values_dynamic"},{"line":396,"address":4217985,"length":1,"stats":{"Line":2},"fn_name":null},{"line":397,"address":4253407,"length":1,"stats":{"Line":1},"fn_name":null},{"line":399,"address":4252640,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":400,"address":4252673,"length":1,"stats":{"Line":1},"fn_name":null},{"line":401,"address":4252803,"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":4253034,"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":4253314,"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":4253494,"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":4218000,"length":1,"stats":{"Line":2},"fn_name":"call_values_dynamic_output"},{"line":412,"address":4218001,"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":4254895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":4254016,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":416,"address":4254034,"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":4254159,"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":4254367,"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":4254626,"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":4254802,"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":4254982,"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":4218016,"length":1,"stats":{"Line":2},"fn_name":"jlrs_extensions_available"},{"line":429,"address":4218017,"length":1,"stats":{"Line":2},"fn_name":null},{"line":430,"address":4256873,"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":4255504,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":433,"address":4255527,"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":4255687,"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":4255879,"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":4256009,"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":4256131,"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":4256319,"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":4256526,"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":4256677,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":257,"coverable":257},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","large_array.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn create_large_array() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let array = Value::new_array::\u003cf32, _, _\u003e(frame, \u0026[1, 1, 1, 1, 1, 1, 1, 1, 1][..]);\n            assert!(array.is_ok());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn move_large_array() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let array = Value::move_array(frame, vec![1u64], \u0026[1, 1, 1, 1, 1, 1, 1, 1, 1][..]);\n            assert!(array.is_ok());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn borrow_large_array() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let mut data = vec![1u32];\n            let array = Value::borrow_array(frame, \u0026mut data, \u0026[1, 1, 1, 1, 1, 1, 1, 1, 1][..]);\n            assert!(array.is_ok());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_large_array_requires_slot() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(0, |_, frame| {\n            let array = Value::new_array::\u003cf32, _, _\u003e(frame, \u0026[1, 1, 1, 1, 1, 1, 1, 1, 1][..]);\n            assert!(array.is_err());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn move_large_array_requires_slot() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(0, |_, frame| {\n            let array = Value::move_array(frame, vec![1u64], \u0026[1, 1, 1, 1, 1, 1, 1, 1, 1][..]);\n            assert!(array.is_err());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn borrow_large_array_requires_slot() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(0, |_, frame| {\n            let mut data = vec![1u32];\n            let array = Value::borrow_array(frame, \u0026mut data, \u0026[1, 1, 1, 1, 1, 1, 1, 1, 1][..]);\n            assert!(array.is_err());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n","traces":[{"line":5,"address":4229328,"length":1,"stats":{"Line":2},"fn_name":"create_large_array"},{"line":6,"address":4229329,"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":4249241,"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":4249024,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":10,"address":4249040,"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":4249127,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4229344,"length":1,"stats":{"Line":2},"fn_name":"move_large_array"},{"line":20,"address":4229345,"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":4249785,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4249424,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":24,"address":4249436,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4249617,"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":4229360,"length":1,"stats":{"Line":2},"fn_name":"borrow_large_array"},{"line":34,"address":4229361,"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":4250297,"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":4249968,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":38,"address":4249980,"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":4250042,"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":4250152,"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":4229376,"length":1,"stats":{"Line":2},"fn_name":"create_large_array_requires_slot"},{"line":49,"address":4229377,"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":4250697,"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":4250480,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":53,"address":4250496,"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":4250583,"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":4229392,"length":1,"stats":{"Line":2},"fn_name":"move_large_array_requires_slot"},{"line":63,"address":4229393,"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":4251241,"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":4250880,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":67,"address":4250892,"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":4251073,"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":4229408,"length":1,"stats":{"Line":2},"fn_name":"borrow_large_array_requires_slot"},{"line":77,"address":4229409,"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":4251753,"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":4251424,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":81,"address":4251436,"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":4251498,"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":4251608,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":38,"coverable":38},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","managed_array.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn array_1d() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let new_array = Value::new_array::\u003cf32, _, _\u003e(frame, 3)?;\n                new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cf32\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data.len(), 3);\n    });\n}\n\n#[test]\nfn array_1d_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let output = frame.output()?;\n                let new_array = Value::new_array_output::\u003cf32, _, _\u003e(frame, output, 3)?;\n                new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cf32\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data.len(), 3);\n    });\n}\n\n#[test]\nfn array_1d_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.frame(1, |frame| {\n                    let new_array = Value::new_array::\u003cf64, _, _\u003e(frame, 3)?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cf64\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data.len(), 3);\n    });\n}\n\n#[test]\nfn array_1d_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003ci8, _, _\u003e(frame, 3)?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003ci8\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data.len(), 3);\n    });\n}\n\n#[test]\nfn array_1d_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                let new_array = Value::new_array::\u003ci16, _, _\u003e(frame, 3)?;\n                new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003ci16\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data.len(), 3);\n    });\n}\n\n#[test]\nfn array_1d_dynamic_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.frame(1, |frame| {\n                    let new_array = Value::new_array::\u003ci32, _, _\u003e(frame, 3)?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003ci32\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data.len(), 3);\n    });\n}\n\n#[test]\nfn array_1d_dynamic_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003ci64, _, _\u003e(frame, 3)?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003ci64\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data.len(), 3);\n    });\n}\n\n#[test]\nfn array_2d() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let new_array = Value::new_array::\u003cu8, _, _\u003e(frame, (3, 4))?;\n                new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu8\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data.len(), 12);\n    });\n}\n\n#[test]\nfn array_2d_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.frame(1, |frame| {\n                    let new_array = Value::new_array::\u003cu16, _, _\u003e(frame, (3, 4))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu16\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data.len(), 12);\n    });\n}\n\n#[test]\nfn array_2d_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003cu32, _, _\u003e(frame, (3, 4))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu32\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data.len(), 12);\n    });\n}\n\n#[test]\nfn array_2d_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                let new_array = Value::new_array::\u003cu64, _, _\u003e(frame, (3, 4))?;\n                new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu64\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data.len(), 12);\n    });\n}\n\n#[test]\nfn array_2d_dynamic_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.frame(1, |frame| {\n                    let new_array = Value::new_array::\u003cusize, _, _\u003e(frame, (3, 4))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cusize\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data.len(), 12);\n    });\n}\n\n#[test]\nfn array_2d_dynamic_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003cisize, _, _\u003e(frame, (3, 4))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cisize\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data.len(), 12);\n    });\n}\n\n#[test]\nfn array_3d() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let new_array = Value::new_array::\u003cu8, _, _\u003e(frame, (3, 4, 5))?;\n                new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu8\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 3);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(data.len(), 60);\n    });\n}\n\n#[test]\nfn array_3d_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.frame(1, |frame| {\n                    let new_array = Value::new_array::\u003cu16, _, _\u003e(frame, (3, 4, 5))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu16\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 3);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(data.len(), 60);\n    });\n}\n\n#[test]\nfn array_3d_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003cu32, _, _\u003e(frame, (3, 4, 5))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu32\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 3);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(data.len(), 60);\n    });\n}\n\n#[test]\nfn array_3d_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                let new_array = Value::new_array::\u003cu64, _, _\u003e(frame, (3, 4, 5))?;\n                new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu64\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 3);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(data.len(), 60);\n    });\n}\n\n#[test]\nfn array_3d_dynamic_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.frame(1, |frame| {\n                    let new_array = Value::new_array::\u003cusize, _, _\u003e(frame, (3, 4, 5))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cusize\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 3);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(data.len(), 60);\n    });\n}\n\n#[test]\nfn array_3d_dynamic_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003cisize, _, _\u003e(frame, (3, 4, 5))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cisize\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 3);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(data.len(), 60);\n    });\n}\n\n#[test]\nfn array_4d() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let new_array = Value::new_array::\u003cu8, _, _\u003e(frame, (3, 4, 5, 6))?;\n                new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu8\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 4);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(dims.n_elements(3), 6);\n        assert_eq!(data.len(), 360);\n    });\n}\n\n#[test]\nfn array_4d_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.frame(1, |frame| {\n                    let new_array = Value::new_array::\u003cu16, _, _\u003e(frame, (3, 4, 5, 6))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu16\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 4);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(dims.n_elements(3), 6);\n        assert_eq!(data.len(), 360);\n    });\n}\n\n#[test]\nfn array_4d_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003cu32, _, _\u003e(frame, (3, 4, 5, 6))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu32\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 4);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(dims.n_elements(3), 6);\n        assert_eq!(data.len(), 360);\n    });\n}\n\n#[test]\nfn array_4d_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                let new_array = Value::new_array::\u003cu64, _, _\u003e(frame, (3, 4, 5, 6))?;\n                new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu64\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 4);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(dims.n_elements(3), 6);\n        assert_eq!(data.len(), 360);\n    });\n}\n\n#[test]\nfn array_4d_dynamic_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.frame(1, |frame| {\n                    let new_array = Value::new_array::\u003cusize, _, _\u003e(frame, (3, 4, 5, 6))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cusize\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 4);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(dims.n_elements(3), 6);\n        assert_eq!(data.len(), 360);\n    });\n}\n\n#[test]\nfn array_4d_dynamic_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003cisize, _, _\u003e(frame, (3, 4, 5, 6))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cisize\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 4);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(dims.n_elements(3), 6);\n        assert_eq!(data.len(), 360);\n    });\n}\n\n#[test]\nfn array_of_bools() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003cbool, _, _\u003e(frame, (3, 4, 5, 6))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cbool\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 4);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(dims.n_elements(3), 6);\n        assert_eq!(data.len(), 360);\n    });\n}\n\n#[test]\nfn array_of_chars() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let new_array = Value::new_array::\u003cchar, _, _\u003e(frame, (3, 4, 5, 6))?;\n                    new_array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cchar\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 4);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(dims.n_elements(2), 5);\n        assert_eq!(dims.n_elements(3), 6);\n        assert_eq!(data.len(), 360);\n    });\n}\n","traces":[{"line":5,"address":4270448,"length":1,"stats":{"Line":2},"fn_name":"array_1d"},{"line":6,"address":4270449,"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":4403871,"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":4403913,"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":4403456,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":11,"address":4403476,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4403587,"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":4404014,"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":4404181,"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":4404357,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4404883,"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":4270464,"length":1,"stats":{"Line":2},"fn_name":"array_1d_output"},{"line":25,"address":4270465,"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":4406415,"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":4406457,"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":4405824,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":30,"address":4405842,"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":4405946,"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":4406108,"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":4406558,"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":4406725,"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":4406901,"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":4407427,"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":4270480,"length":1,"stats":{"Line":2},"fn_name":"array_1d_nested"},{"line":45,"address":4270481,"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":4408815,"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":4408857,"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":4408752,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":50,"address":4408368,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":51,"address":4408388,"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":4408496,"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":4408957,"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":4409124,"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":4409300,"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":4409826,"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":4270496,"length":1,"stats":{"Line":2},"fn_name":"array_1d_nested_dynamic"},{"line":66,"address":4270497,"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":4411199,"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":4411241,"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":4411152,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":71,"address":4410768,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":72,"address":4410788,"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":4410896,"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":4411341,"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":4411508,"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":4411684,"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":4412210,"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":4270512,"length":1,"stats":{"Line":2},"fn_name":"array_1d_dynamic"},{"line":87,"address":4270513,"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":4413567,"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":4413609,"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":4413152,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":92,"address":4413172,"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":4413283,"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":4413705,"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":4413872,"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":4414048,"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":4414574,"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":4270528,"length":1,"stats":{"Line":2},"fn_name":"array_1d_dynamic_nested"},{"line":106,"address":4270529,"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":4415967,"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":4416009,"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":4415904,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":111,"address":4415520,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":112,"address":4415540,"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":4415648,"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":4416105,"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":4416272,"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":4416448,"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":4416974,"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":4270544,"length":1,"stats":{"Line":2},"fn_name":"array_1d_dynamic_nested_dynamic"},{"line":127,"address":4270545,"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":4418351,"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":4418393,"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":4418304,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":132,"address":4417920,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":133,"address":4417940,"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":4418048,"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":4418489,"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":4418656,"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":4418832,"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":4419358,"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":4270560,"length":1,"stats":{"Line":2},"fn_name":"array_2d"},{"line":148,"address":4270561,"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":4420751,"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":4420793,"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":4420304,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":153,"address":4420322,"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":4420464,"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":4420894,"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":4421061,"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":4421238,"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":4421756,"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":4422275,"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":4270576,"length":1,"stats":{"Line":2},"fn_name":"array_2d_nested"},{"line":168,"address":4270577,"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":4423695,"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":4423737,"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":4423632,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":173,"address":4423216,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":174,"address":4423231,"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":4423373,"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":4423837,"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":4424004,"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":4424180,"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":4424698,"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":4425225,"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":4270592,"length":1,"stats":{"Line":2},"fn_name":"array_2d_nested_dynamic"},{"line":190,"address":4270593,"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":4426623,"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":4426665,"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":4426576,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":195,"address":4426160,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":196,"address":4426175,"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":4426317,"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":4426765,"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":4426932,"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":4427108,"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":4427626,"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":4428153,"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":4270608,"length":1,"stats":{"Line":2},"fn_name":"array_2d_dynamic"},{"line":212,"address":4270609,"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":4429535,"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":4429577,"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":4429088,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":217,"address":4429106,"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":4429248,"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":4429673,"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":4429840,"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":4430016,"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":4430534,"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":4431061,"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":4270624,"length":1,"stats":{"Line":2},"fn_name":"array_2d_dynamic_nested"},{"line":232,"address":4270625,"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":4432463,"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":4432505,"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":4432400,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":237,"address":4431984,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":238,"address":4431999,"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":4432141,"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":4432601,"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":4432768,"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":4432945,"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":4433463,"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":4433982,"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":4270640,"length":1,"stats":{"Line":2},"fn_name":"array_2d_dynamic_nested_dynamic"},{"line":254,"address":4270641,"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":4435391,"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":4435433,"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":4435344,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":259,"address":4434928,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":260,"address":4434943,"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":4435085,"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":4435529,"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":4435696,"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":4435872,"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":4436390,"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":4436917,"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":4270656,"length":1,"stats":{"Line":2},"fn_name":"array_3d"},{"line":276,"address":4270657,"length":1,"stats":{"Line":2},"fn_name":null},{"line":277,"address":4438287,"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":4438329,"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":4437840,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":281,"address":4437858,"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":4438001,"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":4438430,"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":4438597,"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":4438774,"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":4439292,"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":4439811,"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":4440330,"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":4270672,"length":1,"stats":{"Line":2},"fn_name":"array_3d_nested"},{"line":297,"address":4270673,"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":4441775,"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":4441817,"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":4441712,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":302,"address":4441280,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":303,"address":4441298,"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":4441441,"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":4441917,"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":4442084,"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":4442260,"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":4442778,"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":4443297,"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":4443824,"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":4270688,"length":1,"stats":{"Line":2},"fn_name":"array_3d_nested_dynamic"},{"line":320,"address":4270689,"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":4445247,"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":4445289,"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":4445200,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":325,"address":4444768,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":326,"address":4444786,"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":4444929,"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":4445389,"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":4445556,"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":4445732,"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":4446250,"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":4446769,"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":4447296,"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":4270704,"length":1,"stats":{"Line":2},"fn_name":"array_3d_dynamic"},{"line":343,"address":4270705,"length":1,"stats":{"Line":2},"fn_name":null},{"line":344,"address":4448687,"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":4448729,"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":4448240,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":348,"address":4448258,"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":4448401,"length":1,"stats":{"Line":1},"fn_name":null},{"line":353,"address":4448825,"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":4448992,"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":4449168,"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":4449686,"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":4450205,"length":1,"stats":{"Line":1},"fn_name":null},{"line":358,"address":4450732,"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":4270720,"length":1,"stats":{"Line":2},"fn_name":"array_3d_dynamic_nested"},{"line":364,"address":4270721,"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":4452159,"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":4452201,"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":4452096,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":369,"address":4451664,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":370,"address":4451682,"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":4451825,"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":4452297,"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":4452464,"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":4452641,"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":4453159,"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":4453678,"length":1,"stats":{"Line":1},"fn_name":null},{"line":381,"address":4454197,"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":4270736,"length":1,"stats":{"Line":2},"fn_name":"array_3d_dynamic_nested_dynamic"},{"line":387,"address":4270737,"length":1,"stats":{"Line":2},"fn_name":null},{"line":388,"address":4455631,"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":4455673,"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":4455584,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":392,"address":4455152,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":393,"address":4455170,"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":4455313,"length":1,"stats":{"Line":1},"fn_name":null},{"line":399,"address":4455769,"length":1,"stats":{"Line":1},"fn_name":null},{"line":400,"address":4455936,"length":1,"stats":{"Line":1},"fn_name":null},{"line":401,"address":4456112,"length":1,"stats":{"Line":1},"fn_name":null},{"line":402,"address":4456630,"length":1,"stats":{"Line":1},"fn_name":null},{"line":403,"address":4457149,"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":4457676,"length":1,"stats":{"Line":1},"fn_name":null},{"line":409,"address":4270752,"length":1,"stats":{"Line":2},"fn_name":"array_4d"},{"line":410,"address":4270753,"length":1,"stats":{"Line":2},"fn_name":null},{"line":411,"address":4459071,"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":4459113,"length":1,"stats":{"Line":1},"fn_name":null},{"line":414,"address":4458608,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":415,"address":4458626,"length":1,"stats":{"Line":1},"fn_name":null},{"line":416,"address":4458778,"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":4459214,"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":4459381,"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":4459558,"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":4460076,"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":4460595,"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":4461114,"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":4461633,"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":4270768,"length":1,"stats":{"Line":2},"fn_name":"array_4d_nested"},{"line":432,"address":4270769,"length":1,"stats":{"Line":2},"fn_name":null},{"line":433,"address":4463071,"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":4463113,"length":1,"stats":{"Line":1},"fn_name":null},{"line":436,"address":4463008,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":437,"address":4462576,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":438,"address":4462594,"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":4462746,"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":4463213,"length":1,"stats":{"Line":1},"fn_name":null},{"line":445,"address":4463380,"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":4463556,"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":4464074,"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":4464593,"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":4465112,"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":4465639,"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":4270784,"length":1,"stats":{"Line":2},"fn_name":"array_4d_nested_dynamic"},{"line":456,"address":4270785,"length":1,"stats":{"Line":2},"fn_name":null},{"line":457,"address":4467055,"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":4467097,"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":4467008,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":461,"address":4466576,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":462,"address":4466594,"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":4466746,"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":4467197,"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":4467364,"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":4467540,"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":4468058,"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":4468577,"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":4469096,"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":4469623,"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":4270800,"length":1,"stats":{"Line":2},"fn_name":"array_4d_dynamic"},{"line":480,"address":4270801,"length":1,"stats":{"Line":2},"fn_name":null},{"line":481,"address":4471023,"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":4471065,"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":4470560,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":485,"address":4470578,"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":4470730,"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":4471161,"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":4471328,"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":4471504,"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":4472022,"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":4472541,"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":4473060,"length":1,"stats":{"Line":1},"fn_name":null},{"line":496,"address":4473587,"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":4270816,"length":1,"stats":{"Line":2},"fn_name":"array_4d_dynamic_nested"},{"line":502,"address":4270817,"length":1,"stats":{"Line":2},"fn_name":null},{"line":503,"address":4475007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":4475049,"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":4474944,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":507,"address":4474512,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":508,"address":4474530,"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":4474682,"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":4475145,"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":4475312,"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":4475489,"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":4476007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":4476526,"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":4477045,"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":4477564,"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":4270832,"length":1,"stats":{"Line":2},"fn_name":"array_4d_dynamic_nested_dynamic"},{"line":526,"address":4270833,"length":1,"stats":{"Line":2},"fn_name":null},{"line":527,"address":4478991,"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":4479033,"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":4478944,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":531,"address":4478512,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":532,"address":4478530,"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":4478682,"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":4479129,"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":4479296,"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":4479472,"length":1,"stats":{"Line":1},"fn_name":null},{"line":541,"address":4479990,"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":4480509,"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":4481028,"length":1,"stats":{"Line":1},"fn_name":null},{"line":544,"address":4481555,"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":4270848,"length":1,"stats":{"Line":2},"fn_name":"array_of_bools"},{"line":550,"address":4270849,"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":4482959,"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":4483001,"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":4482912,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":555,"address":4482480,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":556,"address":4482498,"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":4482650,"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":4483097,"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":4483264,"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":4483440,"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":4483958,"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":4484477,"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":4484996,"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":4485523,"length":1,"stats":{"Line":1},"fn_name":null},{"line":573,"address":4270864,"length":1,"stats":{"Line":2},"fn_name":"array_of_chars"},{"line":574,"address":4270865,"length":1,"stats":{"Line":2},"fn_name":null},{"line":575,"address":4486927,"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":4486969,"length":1,"stats":{"Line":1},"fn_name":null},{"line":578,"address":4486880,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":579,"address":4486448,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":580,"address":4486466,"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":4486618,"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":4487065,"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":4487232,"length":1,"stats":{"Line":1},"fn_name":null},{"line":588,"address":4487408,"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":4487926,"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":4488445,"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":4488964,"length":1,"stats":{"Line":1},"fn_name":null},{"line":592,"address":4489491,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":358,"coverable":358},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","module.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\nuse std::borrow::Cow;\n\n#[test]\nfn core_module() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(0, |global, _| {\n            let module = Module::core(global);\n            let func = module.function(\"isa\");\n            let int64 = module.global(\"Float64\");\n            assert!(func.is_ok());\n            assert!(int64.is_ok());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn core_module_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|global, _| {\n            let module = Module::core(global);\n            let func = module.function(\"isa\");\n            assert!(func.is_ok());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn base_module() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(0, |global, _| {\n            let module = Module::base(global);\n            let func = module.function(\"+\");\n            let int64 = module.global(\"pi\");\n            assert!(func.is_ok());\n            assert!(int64.is_ok());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn base_module_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|global, _| {\n            let module = Module::base(global);\n            let func = module.function(\"+\");\n            assert!(func.is_ok());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn main_module() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(0, |global, _| {\n            let main_module = Module::main(global);\n            let jlrs_module = main_module.submodule(\"Jlrs\");\n            assert!(jlrs_module.is_ok());\n            let func = jlrs_module.unwrap().function(\"attachstacktrace\");\n            assert!(func.is_ok());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn main_module_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|global, _| {\n            let main_module = Module::main(global);\n            let jlrs_module = main_module.submodule(\"Jlrs\");\n            assert!(jlrs_module.is_ok());\n            let func = jlrs_module.unwrap().function(\"attachstacktrace\");\n            assert!(func.is_ok());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn error_nonexistent_function() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(0, |global, _| {\n            assert!(Module::base(global).function(\"foo\").is_err());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn error_nonexistent_function_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|global, _| {\n            assert!(Module::base(global).function(\"foo\").is_err());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn error_nonexistent_submodule() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(0, |global, _| {\n            assert!(Module::base(global).submodule(\"foo\").is_err());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn error_nonexistent_submodule_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|global, _| {\n            assert!(Module::base(global).submodule(\"foo\").is_err());\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n\n#[test]\nfn function_returns_module() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |global, frame| {\n            let base = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"base\")?;\n            let base_val = base.call0(frame)?.unwrap();\n\n            assert!(base_val.is::\u003cModule\u003e());\n            assert!(base_val.cast::\u003cModule\u003e().is_ok());\n            assert!(base_val.cast::\u003cSymbol\u003e().is_err());\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn use_string_for_access() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |global, _frame| {\n            assert!(Module::main(global)\n                .submodule(\"JlrsTests\".to_string())\n                .is_ok());\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn use_cow_for_access() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |global, _frame| {\n            assert!(Module::main(global)\n                .submodule(Cow::from(\"JlrsTests\"))\n                .is_ok());\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\nstruct MyString(String);\nimpl AsRef\u003cstr\u003e for MyString {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        \u0026self.0\n    }\n}\n\n#[test]\nfn use_dyn_str_for_access() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |global, _frame| {\n            let name = MyString(\"JlrsTests\".to_string());\n            assert!(Module::main(global)\n                .submodule(\u0026name as \u0026dyn AsRef\u003cstr\u003e)\n                .is_ok());\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn set_global() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |global, frame| {\n            let main = Module::main(global);\n            let value = Value::new(frame, 1usize)?;\n            unsafe {\n                main.set_global(\"one\", value);\n            }\n\n            let value = main.global(\"one\")?;\n            assert_eq!(value.cast::\u003cusize\u003e()?, 1);\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn set_const() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |global, frame| {\n            let main = Module::main(global);\n            let value = Value::new(frame, 2usize)?;\n            main.set_const(\"ONE\", value)?;\n\n            let value = main.global(\"ONE\")?;\n            assert_eq!(value.cast::\u003cusize\u003e()?, 2);\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn set_const_twice() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        let err = jlrs.frame(2, |global, frame| {\n            let main = Module::main(global);\n            let value1 = Value::new(frame, 3usize)?;\n            let value2 = Value::new(frame, 4usize)?;\n            main.set_const(\"TWICE\", value1)?;\n            main.set_const(\"TWICE\", value2)?;\n\n            let value = main.global(\"TWICE\")?;\n            assert_eq!(value.cast::\u003cusize\u003e()?, 2);\n            Ok(())\n        });\n\n        assert!(err.is_err());\n    })\n}\n","traces":[{"line":6,"address":4222368,"length":1,"stats":{"Line":2},"fn_name":"core_module"},{"line":7,"address":4222369,"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":4233977,"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":4233632,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":11,"address":4233641,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4233671,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4233707,"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":4233770,"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":4233825,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4222384,"length":1,"stats":{"Line":2},"fn_name":"core_module_dynamic"},{"line":24,"address":4222385,"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":4234361,"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":4234160,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":28,"address":4234169,"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":4234199,"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":4234240,"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":4222400,"length":1,"stats":{"Line":2},"fn_name":"base_module"},{"line":39,"address":4222401,"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":4234873,"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":4234528,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":43,"address":4234537,"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":4234567,"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":4234603,"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":4234666,"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":4234721,"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":4222416,"length":1,"stats":{"Line":2},"fn_name":"base_module_dynamic"},{"line":56,"address":4222417,"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":4235257,"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":4235056,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":60,"address":4235065,"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":4235095,"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":4235136,"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":4222432,"length":1,"stats":{"Line":2},"fn_name":"main_module"},{"line":71,"address":4222433,"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":4235833,"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":4235424,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":75,"address":4235436,"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":4235471,"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":4235513,"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":4235534,"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":4235664,"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":4222448,"length":1,"stats":{"Line":2},"fn_name":"main_module_dynamic"},{"line":88,"address":4222449,"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":4236425,"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":4236016,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":92,"address":4236028,"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":4236063,"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":4236105,"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":4236126,"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":4236256,"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":4222464,"length":1,"stats":{"Line":2},"fn_name":"error_nonexistent_function"},{"line":105,"address":4222465,"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":4236793,"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":4236592,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":109,"address":4236601,"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":4222480,"length":1,"stats":{"Line":2},"fn_name":"error_nonexistent_function_dynamic"},{"line":118,"address":4222481,"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":4237177,"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":4236976,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":122,"address":4236985,"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":4222496,"length":1,"stats":{"Line":2},"fn_name":"error_nonexistent_submodule"},{"line":131,"address":4222497,"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":4237529,"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":4237344,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":135,"address":4237353,"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":4222512,"length":1,"stats":{"Line":2},"fn_name":"error_nonexistent_submodule_dynamic"},{"line":144,"address":4222513,"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":4237897,"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":4237712,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":148,"address":4237721,"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":4222528,"length":1,"stats":{"Line":2},"fn_name":"function_returns_module"},{"line":157,"address":4222529,"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":4239177,"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":4238064,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":160,"address":4238084,"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":4238178,"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":4238195,"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":4238441,"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":4238730,"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":4238758,"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":4238888,"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":4239013,"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":4222544,"length":1,"stats":{"Line":2},"fn_name":"use_string_for_access"},{"line":177,"address":4222545,"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":4239561,"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":4239360,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":180,"address":4239369,"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":4239401,"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":4222560,"length":1,"stats":{"Line":2},"fn_name":"use_cow_for_access"},{"line":192,"address":4222561,"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":4239945,"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":4239744,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":195,"address":4239753,"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":4239785,"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":4222576,"length":1,"stats":{"Line":2},"fn_name":"use_dyn_str_for_access"},{"line":214,"address":4222577,"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":4240441,"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":4240128,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":217,"address":4240147,"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":4240199,"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":4222592,"length":1,"stats":{"Line":2},"fn_name":"set_global"},{"line":230,"address":4222593,"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":4241801,"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":4240624,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":233,"address":4240647,"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":4240694,"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":4240819,"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":4240950,"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":4241061,"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":4241393,"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":4222608,"length":1,"stats":{"Line":2},"fn_name":"set_const"},{"line":249,"address":4222609,"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":4243369,"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":4241984,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":252,"address":4242007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":4242054,"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":4242179,"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":4242405,"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":4242606,"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":4242938,"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":4222624,"length":1,"stats":{"Line":2},"fn_name":"set_const_twice"},{"line":266,"address":4222625,"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":4245417,"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":4243552,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":269,"address":4243575,"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":4243622,"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":4243740,"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":4243979,"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":4244211,"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":4244432,"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":4244627,"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":4244959,"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":4245521,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":131,"coverable":135},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","move_array.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn move_array_1d() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let data = vec![1.0f32, 2., 3.];\n                let array = Value::move_array(frame, data, 3)?;\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cf32\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data, vec![1., 2., 3.]);\n    });\n}\n\n#[test]\nfn move_array_1d_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let output = frame.output()?;\n                let data = vec![1.0f32, 2., 3.];\n                let array = Value::move_array_output(frame, output, data, 3)?;\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cf32\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data, vec![1., 2., 3.]);\n    });\n}\n\n#[test]\nfn move_array_1d_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.frame(1, |frame| {\n                    let data = vec![1.0f64, 2., 3.];\n                    let array = Value::move_array(frame, data, 3)?;\n                    array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cf64\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data, vec![1., 2., 3.]);\n    });\n}\n\n#[test]\nfn move_array_1d_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let data = vec![1i8, 2, 3];\n                    let array = Value::move_array(frame, data, 3)?;\n                    array.cast::\u003cArray\u003e()?.copy_inline_data::\u003ci8\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data, vec![1, 2, 3]);\n    });\n}\n\n#[test]\nfn move_array_1d_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                let data = vec![1i16, 2, 3];\n                let array = Value::move_array(frame, data, 3)?;\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003ci16\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data, vec![1, 2, 3]);\n    });\n}\n\n#[test]\nfn move_array_1d_dynamic_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.frame(1, |frame| {\n                    let data = vec![1i32, 2, 3];\n                    let array = Value::move_array(frame, data, 3)?;\n                    array.cast::\u003cArray\u003e()?.copy_inline_data::\u003ci32\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data, vec![1, 2, 3]);\n    });\n}\n\n#[test]\nfn move_array_1d_dynamic_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let data = vec![1i64, 2, 3];\n                    let array = Value::move_array(frame, data, 3)?;\n                    array.cast::\u003cArray\u003e()?.copy_inline_data::\u003ci64\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 1);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(data, vec![1, 2, 3]);\n    });\n}\n\n#[test]\nfn move_array_2d() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(1, |_, frame| {\n                let data = vec![1u8, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4];\n                let array = Value::move_array(frame, data, (3, 4))?;\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu8\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data, vec![1u8, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4]);\n    });\n}\n\n#[test]\nfn move_array_2d_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.frame(1, |frame| {\n                    let data = vec![1u16, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4];\n                    let array = Value::move_array(frame, data, (3, 4))?;\n                    array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu16\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data, vec![1u16, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4]);\n    });\n}\n\n#[test]\nfn move_array_2d_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .frame(0, |_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let data = vec![1u32, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4];\n                    let array = Value::move_array(frame, data, (3, 4))?;\n                    array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu32\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data, vec![1u32, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4]);\n    });\n}\n\n#[test]\nfn move_array_2d_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                let data = vec![1u64, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4];\n                let array = Value::move_array(frame, data, (3, 4))?;\n                array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cu64\u003e()\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data, vec![1u64, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4]);\n    });\n}\n\n#[test]\nfn move_array_2d_dynamic_nested() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.frame(1, |frame| {\n                    let data = vec![1usize, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4];\n                    let array = Value::move_array(frame, data, (3, 4))?;\n                    array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cusize\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data, vec![1usize, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4]);\n    });\n}\n\n#[test]\nfn move_array_2d_dynamic_nested_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unboxed = jlrs\n            .dynamic_frame(|_, frame| {\n                frame.dynamic_frame(|frame| {\n                    let data = vec![1isize, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4];\n                    let array = Value::move_array(frame, data, (3, 4))?;\n                    array.cast::\u003cArray\u003e()?.copy_inline_data::\u003cisize\u003e()\n                })\n            })\n            .unwrap();\n\n        let (data, dims) = unboxed.splat();\n        assert_eq!(dims.n_dimensions(), 2);\n        assert_eq!(dims.n_elements(0), 3);\n        assert_eq!(dims.n_elements(1), 4);\n        assert_eq!(data, vec![1isize, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4]);\n    });\n}\n","traces":[{"line":5,"address":4220880,"length":1,"stats":{"Line":2},"fn_name":"move_array_1d"},{"line":6,"address":4220881,"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":4222447,"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":4222489,"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":4221888,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":11,"address":4221906,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4222018,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4222147,"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":4222590,"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":4222757,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4222933,"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":4223461,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4220896,"length":1,"stats":{"Line":2},"fn_name":"move_array_1d_output"},{"line":26,"address":4220897,"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":4225231,"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":4225273,"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":4224480,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":31,"address":4224498,"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":4224597,"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":4224749,"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":4224916,"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":4225374,"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":4225541,"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":4225717,"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":4226245,"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":4220912,"length":1,"stats":{"Line":2},"fn_name":"move_array_1d_nested"},{"line":47,"address":4220913,"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":4227871,"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":4227913,"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":4227808,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":52,"address":4227264,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":53,"address":4227282,"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":4227394,"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":4227526,"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":4228013,"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":4228180,"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":4228356,"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":4228884,"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":4220928,"length":1,"stats":{"Line":2},"fn_name":"move_array_1d_nested_dynamic"},{"line":69,"address":4220929,"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":4230479,"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":4230521,"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":4230432,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":74,"address":4229920,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":75,"address":4229938,"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":4230023,"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":4230155,"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":4230621,"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":4230788,"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":4230964,"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":4231492,"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":4220944,"length":1,"stats":{"Line":2},"fn_name":"move_array_1d_dynamic"},{"line":91,"address":4220945,"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":4233023,"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":4233065,"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":4232496,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":96,"address":4232514,"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":4232605,"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":4232734,"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":4233161,"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":4233328,"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":4233504,"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":4234032,"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":4220960,"length":1,"stats":{"Line":2},"fn_name":"move_array_1d_dynamic_nested"},{"line":111,"address":4220961,"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":4235631,"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":4235673,"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":4235568,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":116,"address":4235040,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":117,"address":4235058,"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":4235152,"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":4235284,"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":4235769,"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":4235936,"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":4236112,"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":4236640,"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":4220976,"length":1,"stats":{"Line":2},"fn_name":"move_array_1d_dynamic_nested_dynamic"},{"line":133,"address":4220977,"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":4238223,"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":4238265,"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":4238176,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":138,"address":4237648,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":139,"address":4237666,"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":4237763,"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":4237895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":4238361,"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":4238528,"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":4238704,"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":4239232,"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":4220992,"length":1,"stats":{"Line":2},"fn_name":"move_array_2d"},{"line":155,"address":4220993,"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":4240863,"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":4240905,"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":4240256,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":160,"address":4240274,"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":4240395,"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":4240562,"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":4241006,"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":4241173,"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":4241350,"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":4241868,"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":4242397,"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":4221008,"length":1,"stats":{"Line":2},"fn_name":"move_array_2d_nested"},{"line":176,"address":4221009,"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":4244127,"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":4244169,"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":4244064,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":181,"address":4243456,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":182,"address":4243474,"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":4243619,"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":4243789,"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":4244269,"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":4244436,"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":4244612,"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":4245130,"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":4245659,"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":4221024,"length":1,"stats":{"Line":2},"fn_name":"move_array_2d_nested_dynamic"},{"line":199,"address":4221025,"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":4247391,"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":4247433,"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":4247344,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":204,"address":4246720,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":205,"address":4246738,"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":4246895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":4247065,"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":4247533,"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":4247700,"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":4247876,"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":4248394,"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":4248923,"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":4221040,"length":1,"stats":{"Line":2},"fn_name":"move_array_2d_dynamic"},{"line":222,"address":4221041,"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":4250639,"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":4250681,"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":4249984,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":227,"address":4250002,"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":4250171,"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":4250338,"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":4250777,"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":4250944,"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":4251120,"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":4251638,"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":4252171,"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":4221056,"length":1,"stats":{"Line":2},"fn_name":"move_array_2d_dynamic_nested"},{"line":243,"address":4221057,"length":1,"stats":{"Line":2},"fn_name":null},{"line":244,"address":4253951,"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":4253993,"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":4253888,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":248,"address":4253248,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":249,"address":4253266,"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":4253435,"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":4253605,"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":4254089,"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":4254256,"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":4254433,"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":4254951,"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":4255484,"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":4221072,"length":1,"stats":{"Line":2},"fn_name":"move_array_2d_dynamic_nested_dynamic"},{"line":266,"address":4221073,"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":4257263,"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":4257305,"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":4257216,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":271,"address":4256576,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":272,"address":4256594,"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":4256763,"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":4256933,"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":4257401,"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":4257568,"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":4257744,"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":4258262,"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":4258795,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":171,"coverable":171},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","primitives.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn create_and_cast_uints() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(5, |_, frame| {\n            let p1 = Value::new(frame, 1u8)?;\n            let p2 = Value::new(frame, 2u16)?;\n            let p3 = Value::new(frame, 3u32)?;\n            let p4 = Value::new(frame, 4u64)?;\n            let p5 = Value::new(frame, 5usize)?;\n\n            let u1 = p1.cast::\u003cu8\u003e()?;\n            let u2 = p2.cast::\u003cu16\u003e()?;\n            let u3 = p3.cast::\u003cu32\u003e()?;\n            let u4 = p4.cast::\u003cu64\u003e()?;\n            let u5 = p5.cast::\u003cusize\u003e()?;\n\n            assert_eq!(u1, 1);\n            assert_eq!(u2, 2);\n            assert_eq!(u3, 3);\n            assert_eq!(u4, 4);\n            assert_eq!(u5, 5);\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_output() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_, frame| {\n            let output = frame.output()?;\n            let p1 = Value::new_output(frame, output, 1u8);\n            let u1 = p1.cast::\u003cu8\u003e()?;\n            assert_eq!(u1, 1);\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_uints_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|_, frame| {\n            let p1 = Value::new(frame, 1u8)?;\n            let p2 = Value::new(frame, 2u16)?;\n            let p3 = Value::new(frame, 3u32)?;\n            let p4 = Value::new(frame, 4u64)?;\n            let p5 = Value::new(frame, 5usize)?;\n\n            let u1 = p1.cast::\u003cu8\u003e()?;\n            let u2 = p2.cast::\u003cu16\u003e()?;\n            let u3 = p3.cast::\u003cu32\u003e()?;\n            let u4 = p4.cast::\u003cu64\u003e()?;\n            let u5 = p5.cast::\u003cusize\u003e()?;\n\n            assert_eq!(u1, 1);\n            assert_eq!(u2, 2);\n            assert_eq!(u3, 3);\n            assert_eq!(u4, 4);\n            assert_eq!(u5, 5);\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_ints() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(5, |_, frame| {\n            let p1 = Value::new(frame, 1i8)?;\n            let p2 = Value::new(frame, 2i16)?;\n            let p3 = Value::new(frame, 3i32)?;\n            let p4 = Value::new(frame, 4i64)?;\n            let p5 = Value::new(frame, 5isize)?;\n\n            let u1 = p1.cast::\u003ci8\u003e()?;\n            let u2 = p2.cast::\u003ci16\u003e()?;\n            let u3 = p3.cast::\u003ci32\u003e()?;\n            let u4 = p4.cast::\u003ci64\u003e()?;\n            let u5 = p5.cast::\u003cisize\u003e()?;\n\n            assert_eq!(u1, 1);\n            assert_eq!(u2, 2);\n            assert_eq!(u3, 3);\n            assert_eq!(u4, 4);\n            assert_eq!(u5, 5);\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_ints_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|_, frame| {\n            let p1 = Value::new(frame, 1i8)?;\n            let p2 = Value::new(frame, 2i16)?;\n            let p3 = Value::new(frame, 3i32)?;\n            let p4 = Value::new(frame, 4i64)?;\n            let p5 = Value::new(frame, 5isize)?;\n\n            let u1 = p1.cast::\u003ci8\u003e()?;\n            let u2 = p2.cast::\u003ci16\u003e()?;\n            let u3 = p3.cast::\u003ci32\u003e()?;\n            let u4 = p4.cast::\u003ci64\u003e()?;\n            let u5 = p5.cast::\u003cisize\u003e()?;\n\n            assert_eq!(u1, 1);\n            assert_eq!(u2, 2);\n            assert_eq!(u3, 3);\n            assert_eq!(u4, 4);\n            assert_eq!(u5, 5);\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_floats() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(5, |_, frame| {\n            let p1 = Value::new(frame, 1f32)?;\n            let p2 = Value::new(frame, 2f64)?;\n\n            let u1 = p1.cast::\u003cf32\u003e()?;\n            let u2 = p2.cast::\u003cf64\u003e()?;\n\n            assert_eq!(u1, 1.);\n            assert_eq!(u2, 2.);\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_floats_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|_, frame| {\n            let p1 = Value::new(frame, 1f32)?;\n            let p2 = Value::new(frame, 2f64)?;\n\n            let u1 = p1.cast::\u003cf32\u003e()?;\n            let u2 = p2.cast::\u003cf64\u003e()?;\n\n            assert_eq!(u1, 1.);\n            assert_eq!(u2, 2.);\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_bool() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(5, |_, frame| {\n            let p1 = Value::new(frame, true)?;\n            let u1 = p1.cast::\u003cbool\u003e()?;\n            assert_eq!(u1, true);\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_bool_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|_, frame| {\n            let p1 = Value::new(frame, false)?;\n            let u1 = p1.cast::\u003cbool\u003e()?;\n            assert_eq!(u1, false);\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_char() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(5, |_, frame| {\n            let p1 = Value::new(frame, 'a')?;\n            let u1 = p1.cast::\u003cchar\u003e()?;\n            assert_eq!(u1, 'a');\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_char_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|_, frame| {\n            let p1 = Value::new(frame, 'a')?;\n            let u1 = p1.cast::\u003cchar\u003e()?;\n            assert_eq!(u1, 'a');\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_values() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |_, frame| {\n            let p1 = Values::new(frame, ['a', 'b'])?;\n            let u1 = p1.value(0)?.cast::\u003cchar\u003e()?;\n            let u2 = p1.value(1)?.cast::\u003cchar\u003e()?;\n            assert_eq!(u1, 'a');\n            assert_eq!(u2, 'b');\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_values_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|_, frame| {\n            let p1 = Values::new(frame, ['a', 'b'])?;\n            let u1 = p1.value(0)?.cast::\u003cchar\u003e()?;\n            let u2 = p1.value(1)?.cast::\u003cchar\u003e()?;\n            assert_eq!(u1, 'a');\n            assert_eq!(u2, 'b');\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_dyn_values() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |_, frame| {\n            let p1 = Values::new_dyn(frame, [\u00261u32 as _, \u00262u64 as _])?;\n            let u1 = p1.value(0)?.cast::\u003cu32\u003e()?;\n            let u2 = p1.value(1)?.cast::\u003cu64\u003e()?;\n            assert_eq!(u1, 1u32);\n            assert_eq!(u2, 2u64);\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_and_cast_dyn_values_dynamic() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.dynamic_frame(|_, frame| {\n            let p1 = Values::new_dyn(frame, [\u00261u32 as _, \u00262u64 as _])?;\n            let u1 = p1.value(0)?.cast::\u003cu32\u003e()?;\n            let u2 = p1.value(1)?.cast::\u003cu64\u003e()?;\n            assert_eq!(u1, 1u32);\n            assert_eq!(u2, 2u64);\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_values_get_out_of_bounds() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |_, frame| {\n            let p1 = Values::new(frame, ['a'])?;\n            assert_eq!(p1.len(), 1);\n            let u2 = p1.value(1);\n            assert!(u2.is_err());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_values_too_many() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |_, frame| {\n            let p1 = Values::new(frame, ['a', 'b', 'c']);\n            assert!(p1.is_err());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_values_too_many_dyn() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |_, frame| {\n            let p1 = Values::new_dyn(frame, [\u0026'a' as _, \u00261usize as _, \u00261isize as _]);\n            assert!(p1.is_err());\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\n#[test]\nfn create_nothing() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(0, |_global, frame| {\n            let nothing = Value::nothing(frame);\n            assert!(nothing.is_nothing());\n            assert!(!nothing.is::\u003cf32\u003e());\n            assert!(nothing.datatype().is_some());\n            assert_eq!(nothing.type_name(), \"Nothing\");\n            assert!(!nothing.is_array_of::\u003cf32\u003e());\n            assert_eq!(nothing.field_names().len(), 0);\n            assert_eq!(nothing.n_fields(), 0);\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n\nmacro_rules! cannot_cast_wrong_type {\n    ($name:ident, $val:expr, $from:ty, $to:ty) =\u003e {\n        #[test]\n        fn $name() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n\n                jlrs.frame(1, |_global, frame| {\n                    let val = Value::new(frame, $val)?;\n                    assert!(val.is::\u003c$from\u003e());\n                    assert!(val.cast::\u003c$to\u003e().is_err());\n                    Ok(())\n                })\n                .unwrap();\n            });\n        }\n    };\n}\n\ncannot_cast_wrong_type!(cannot_cast_u8_as_u16, 1u8, u8, u16);\ncannot_cast_wrong_type!(cannot_cast_u16_as_u32, 1u16, u16, u32);\ncannot_cast_wrong_type!(cannot_cast_u32_as_u64, 1u32, u32, u64);\ncannot_cast_wrong_type!(cannot_cast_u64_as_i8, 1u64, u64, i8);\ncannot_cast_wrong_type!(cannot_cast_i8_as_i16, 1i8, i8, i16);\ncannot_cast_wrong_type!(cannot_cast_i16_as_i32, 1i16, i16, i32);\ncannot_cast_wrong_type!(cannot_cast_i32_as_i64, 1i32, i32, i64);\ncannot_cast_wrong_type!(cannot_cast_i64_as_u8, 1i64, i64, u8);\ncannot_cast_wrong_type!(cannot_cast_bool_as_char, true, bool, char);\ncannot_cast_wrong_type!(cannot_cast_char_as_bool, 'a', char, bool);\ncannot_cast_wrong_type!(cannot_cast_f32_as_64, 1f32, f32, f64);\ncannot_cast_wrong_type!(cannot_cast_f64_as_32, 1f64, f64, f32);\n\nunsafe extern \"C\" fn func() -\u003e bool {\n    true\n}\n\n#[test]\nfn function_pointer() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(2, |global, frame| {\n            let val = Value::new(frame, func as *mut std::ffi::c_void)?;\n            assert!(val.is::\u003c*mut std::ffi::c_void\u003e());\n\n            let res = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"callrust\")?\n                .call1(frame, val)?\n                .unwrap()\n                .cast::\u003cbool\u003e()?;\n\n            assert!(res);\n            val.cast::\u003c*mut std::ffi::c_void\u003e()?;\n\n            Ok(())\n        })\n        .unwrap();\n    });\n}\n","traces":[{"line":5,"address":4225824,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":6,"address":4230208,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":7,"address":4230217,"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":4225856,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":10,"address":4225879,"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":4226014,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4226246,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4226465,"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":4226684,"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":4226895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":4227080,"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":4227260,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4227436,"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":4227614,"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":4227795,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4227983,"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":4228423,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4228861,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4229301,"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":4229693,"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":4230368,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":36,"address":4231248,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":37,"address":4231257,"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":4230400,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":40,"address":4230415,"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":4230529,"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":4230646,"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":4230730,"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":4230894,"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":4231408,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":53,"address":4235792,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":54,"address":4235801,"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":4231440,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":57,"address":4231463,"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":4231598,"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":4231830,"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":4232049,"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":4232268,"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":4232479,"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":4232664,"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":4232844,"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":4233020,"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":4233198,"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":4233379,"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":4233567,"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":4234007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":4234445,"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":4234885,"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":4235277,"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":4235936,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":83,"address":4240304,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":84,"address":4240313,"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":4235968,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":87,"address":4235991,"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":4236126,"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":4236358,"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":4236577,"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":4236796,"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":4237007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":4237192,"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":4237372,"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":4237548,"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":4237726,"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":4237907,"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":4238095,"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":4238535,"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":4238973,"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":4239413,"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":4239805,"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":4240464,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":113,"address":4244832,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":114,"address":4244841,"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":4240496,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":117,"address":4240519,"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":4240654,"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":4240886,"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":4241105,"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":4241324,"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":4241535,"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":4241720,"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":4241900,"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":4242076,"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":4242254,"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":4242435,"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":4242623,"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":4243063,"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":4243501,"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":4243941,"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":4244333,"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":4244976,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":143,"address":4246752,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":144,"address":4246761,"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":4245008,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":147,"address":4245039,"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":4245185,"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":4245396,"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":4245586,"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":4245770,"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":4245968,"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":4246366,"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":4246912,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":164,"address":4248688,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":165,"address":4248697,"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":4246944,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":168,"address":4246975,"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":4247121,"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":4247332,"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":4247522,"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":4247706,"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":4247904,"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":4248302,"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":4248832,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":185,"address":4249664,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":186,"address":4249673,"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":4248864,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":189,"address":4248879,"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":4248994,"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":4249161,"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":4249325,"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":4249824,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":200,"address":4250656,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":201,"address":4250665,"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":4249856,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":204,"address":4249873,"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":4249983,"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":4250150,"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":4250314,"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":4250800,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":215,"address":4251648,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":216,"address":4251657,"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":4250832,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":219,"address":4250847,"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":4250962,"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":4251128,"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":4251294,"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":4251808,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":230,"address":4252656,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":231,"address":4252665,"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":4251840,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":234,"address":4251855,"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":4251970,"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":4252136,"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":4252302,"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":4252800,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":245,"address":4254800,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":246,"address":4254809,"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":4252832,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":249,"address":4252847,"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":4253018,"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":4253430,"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":4253802,"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":4253993,"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":4254386,"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":4254960,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":262,"address":4256960,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":263,"address":4256969,"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":4254992,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":266,"address":4255007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":4255178,"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":4255590,"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":4255962,"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":4256153,"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":4256546,"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":4257104,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":279,"address":4259136,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":280,"address":4259145,"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":4257136,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":283,"address":4257165,"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":4257360,"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":4257772,"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":4258146,"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":4258337,"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":4258732,"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":4259296,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":296,"address":4261328,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":297,"address":4261337,"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":4259328,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":300,"address":4259357,"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":4259552,"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":4259964,"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":4260338,"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":4260529,"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":4260924,"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":4261472,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":313,"address":4262368,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":314,"address":4262377,"length":1,"stats":{"Line":1},"fn_name":null},{"line":316,"address":4261504,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":317,"address":4261519,"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":4261668,"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":4261882,"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":4262221,"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":4262262,"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":4262528,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":329,"address":4262752,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":330,"address":4262761,"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":4262560,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":333,"address":4262569,"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":4262640,"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":4262912,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":343,"address":4263184,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":344,"address":4263193,"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":4262944,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":347,"address":4262977,"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":4263075,"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":4263344,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":357,"address":4265072,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":358,"address":4265081,"length":1,"stats":{"Line":1},"fn_name":null},{"line":360,"address":4263376,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":361,"address":4263391,"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":4263420,"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":4263454,"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":4263514,"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":4263612,"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":4263795,"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":4264170,"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":4264360,"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":4265232,"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":380,"address":4265680,"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":381,"address":4265689,"length":1,"stats":{"Line":12},"fn_name":null},{"line":383,"address":4265264,"length":1,"stats":{"Line":24},"fn_name":"{{closure}}"},{"line":384,"address":4265276,"length":1,"stats":{"Line":12},"fn_name":null},{"line":385,"address":4265379,"length":1,"stats":{"Line":12},"fn_name":null},{"line":386,"address":4265489,"length":1,"stats":{"Line":12},"fn_name":null},{"line":387,"address":4265599,"length":1,"stats":{"Line":12},"fn_name":null},{"line":408,"address":4289984,"length":1,"stats":{"Line":1},"fn_name":"func"},{"line":413,"address":4272560,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":414,"address":4274112,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":415,"address":4274121,"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":4272592,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":418,"address":4272622,"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":4272747,"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":4272887,"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":4273014,"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":4273239,"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":4273432,"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":4273031,"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":4273685,"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":4273777,"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":4273893,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":238,"coverable":239},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","runtime.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn error_include_nonexistent() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        assert!(jlrs.include(\"nonexistent/path/\").is_err());\n    });\n}\n\n#[test]\nfn change_stack_size() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        assert_ne!(jlrs.stack_size(), 48);\n        jlrs.set_stack_size(48);\n        assert_eq!(jlrs.stack_size(), 48);\n    });\n}\n\n#[test]\nfn cannot_init_again() {\n    JULIA.with(|_j| unsafe {\n        assert!(Julia::init(42).is_err());\n    });\n}\n\n#[test]\nfn include_error() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        assert!(jlrs.include(\"Cargo.toml\").is_err());\n    });\n}\n","traces":[{"line":5,"address":4215456,"length":1,"stats":{"Line":2},"fn_name":"error_include_nonexistent"},{"line":6,"address":4215457,"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":4221417,"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":4221450,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4215472,"length":1,"stats":{"Line":2},"fn_name":"change_stack_size"},{"line":14,"address":4215473,"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":4221711,"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":4221761,"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":4221922,"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":4222329,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4215488,"length":1,"stats":{"Line":2},"fn_name":"cannot_init_again"},{"line":24,"address":4215489,"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":4222873,"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":4215504,"length":1,"stats":{"Line":2},"fn_name":"include_error"},{"line":31,"address":4215505,"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":4223065,"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":4223098,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":17,"coverable":17},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","stacktrace.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn bounds_error() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(0, |global, frame| {\n            frame.frame(8, |frame| {\n                let idx = Value::new(frame, 4usize)?;\n                let data = vec![1.0f64, 2., 3.];\n                let array = Value::move_array(frame, data, 3)?;\n                let func = Module::base(global)\n                    .function(\"getindex\")?\n                    .attach_stacktrace(frame)?\n                    .unwrap();\n                let out = func.call2(frame, array, idx)?.unwrap_err();\n\n                assert_eq!(out.type_name(), \"TracedException\");\n\n                let field_names = out.field_names();\n                let f0: String = field_names[0].into();\n                assert_eq!(f0, \"exc\");\n                let f1: String = field_names[1].into();\n                assert_eq!(f1, \"stacktrace\");\n\n                let stacktrace = out.get_field(frame, \"stacktrace\");\n                assert!(stacktrace.is_ok());\n\n                let getindex = Module::base(global).function(\"getindex\")?;\n                let idx = Value::new(frame, 1usize)?;\n                let base = getindex.call2(frame, stacktrace?, idx)?.unwrap();\n                assert!(base.get_field(frame, \"from_c\")?.cast::\u003cbool\u003e().is_ok());\n\n                Ok(())\n            })\n        })\n        .unwrap();\n    });\n}\n","traces":[{"line":5,"address":4215408,"length":1,"stats":{"Line":2},"fn_name":"bounds_error"},{"line":6,"address":4215409,"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":4245305,"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":4245248,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":9,"address":4240272,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":10,"address":4240295,"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":4240444,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4240632,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4240817,"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":4241007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":4241186,"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":4241024,"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":4241372,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4241620,"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":4241766,"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":4242156,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4242199,"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":4242332,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4242761,"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":4242894,"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":4243361,"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":4243388,"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":4243629,"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":4243919,"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":4244431,"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":4244725,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":26},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","strings.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::traits::ValidLayout;\nuse jlrs::util::JULIA;\nuse jlrs::value::string::JuliaString;\nuse std::borrow::Cow;\n\n#[test]\nfn create_and_unbox_str_data() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unwrapped_string = jlrs\n            .frame(1, |_, frame| {\n                frame.frame(1, |frame| {\n                    let string = Value::new(frame, \"Hell world!\")?;\n                    string.cast::\u003cString\u003e()\n                })\n            })\n            .unwrap();\n\n        assert_eq!(unwrapped_string, \"Hell world!\");\n    });\n}\n\n#[test]\nfn create_and_unbox_string_data() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unwrapped_string = jlrs\n            .frame(1, |_, frame| {\n                frame.frame(1, |frame| {\n                    let string = Value::new(frame, String::from(\"Hell world!\"))?;\n                    string.cast::\u003cString\u003e()\n                })\n            })\n            .unwrap();\n\n        assert_eq!(unwrapped_string, \"Hell world!\");\n    });\n}\n\n#[test]\nfn create_and_unbox_cow_data() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        let unwrapped_string = jlrs\n            .frame(1, |_, frame| {\n                frame.frame(1, |frame| {\n                    let string = Value::new(frame, Cow::from(\"Hell world!\"))?;\n                    string.cast::\u003cString\u003e()\n                })\n            })\n            .unwrap();\n\n        assert_eq!(unwrapped_string, \"Hell world!\");\n    });\n}\n\n#[test]\nfn create_and_cast_jl_string() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n\n        jlrs.frame(1, |_global, frame| {\n            let v = Value::new(frame, \"Foo bar\")?;\n            assert!(v.is::\u003cJuliaString\u003e());\n            let string = v.cast::\u003cJuliaString\u003e()?;\n            assert!(unsafe { JuliaString::valid_layout(v.datatype().unwrap().into()) });\n            assert_eq!(string.len(), 7);\n            assert_eq!(string.as_c_str().to_str().unwrap(), \"Foo bar\");\n            assert_eq!(string.as_str().unwrap(), \"Foo bar\");\n            assert_eq!(unsafe { string.as_str_unchecked() }, \"Foo bar\");\n            assert_eq!(string.as_slice(), b\"Foo bar\".as_ref());\n\n            Ok(())\n        })\n        .unwrap()\n    });\n}\n","traces":[{"line":8,"address":4217856,"length":1,"stats":{"Line":2},"fn_name":"create_and_unbox_str_data"},{"line":9,"address":4217857,"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":4220575,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4220611,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4220512,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":14,"address":4220288,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":15,"address":4220312,"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":4220418,"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":4220697,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4217872,"length":1,"stats":{"Line":2},"fn_name":"create_and_unbox_string_data"},{"line":27,"address":4217873,"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":4221567,"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":4221603,"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":4221504,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":32,"address":4221232,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":33,"address":4221254,"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":4221396,"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":4221689,"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":4217888,"length":1,"stats":{"Line":2},"fn_name":"create_and_unbox_cow_data"},{"line":45,"address":4217889,"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":4222559,"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":4222595,"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":4222496,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":50,"address":4222224,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":51,"address":4222246,"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":4222389,"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":4222681,"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":4217904,"length":1,"stats":{"Line":2},"fn_name":"create_and_cast_jl_string"},{"line":63,"address":4217905,"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":4226393,"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":4223216,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":67,"address":4223238,"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":4223368,"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":4223516,"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":4223668,"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":4223884,"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":4224037,"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":4224578,"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":4225086,"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":4225569,"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":4226039,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":41,"coverable":41},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","symbols.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn create_symbol() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(0, |global, _frame| {\n            let smb = Symbol::new(global, \"a\");\n            smb.extend(global);\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn function_returns_symbol() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |global, frame| {\n            let smb = Module::main(global)\n                .submodule(\"JlrsTests\")?\n                .function(\"symbol\")?;\n            let smb_val = smb.call0(frame)?.unwrap();\n\n            assert!(smb_val.is::\u003cSymbol\u003e());\n            assert!(smb_val.cast::\u003cSymbol\u003e().is_ok());\n            assert!(smb_val.cast::\u003cModule\u003e().is_err());\n            assert!(smb_val.cast::\u003cArray\u003e().is_err());\n            assert!(smb_val.cast::\u003cDataType\u003e().is_err());\n\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n","traces":[{"line":5,"address":4215408,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":6,"address":4215504,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":7,"address":4215513,"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":4215440,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":9,"address":4215456,"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":4215482,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4215664,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":20,"address":4217120,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":21,"address":4217129,"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":4215696,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":23,"address":4215719,"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":4215819,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4215836,"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":4216082,"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":4216374,"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":4216402,"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":4216532,"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":4216662,"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":4216787,"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":4216923,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":20},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","tuple.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\n#[test]\nfn create_cast_tuple0() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |_global, frame| {\n            let t0 = Tuple0();\n            let v = Value::new(frame, t0)?;\n            assert!(v.is::\u003cTuple0\u003e());\n            assert!(v.cast::\u003cTuple0\u003e().is_ok());\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn create_cast_tuple1() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |_global, frame| {\n            let t1 = Tuple1(1u64);\n            let v = Value::new(frame, t1)?;\n            assert!(v.is::\u003cTuple1\u003cu64\u003e\u003e());\n            assert!(v.cast::\u003cTuple1\u003cu64\u003e\u003e().is_ok());\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n\n#[test]\nfn create_cast_tuple2() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.frame(1, |_global, frame| {\n            let t2 = Tuple2(1u64, -3i32);\n            let v = Value::new(frame, t2)?;\n            assert!(v.is::\u003cTuple2\u003cu64, i32\u003e\u003e());\n            assert!(v.cast::\u003cTuple2\u003cu64, i32\u003e\u003e().is_ok());\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n","traces":[{"line":5,"address":4215536,"length":1,"stats":{"Line":2},"fn_name":"create_cast_tuple0"},{"line":6,"address":4215537,"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":4225881,"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":4225456,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":10,"address":4225468,"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":4225566,"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":4225680,"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":4225785,"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":4215552,"length":1,"stats":{"Line":2},"fn_name":"create_cast_tuple1"},{"line":21,"address":4215553,"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":4226521,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4226064,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":24,"address":4226079,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4226088,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4226201,"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":4226310,"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":4226420,"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":4215568,"length":1,"stats":{"Line":2},"fn_name":"create_cast_tuple2"},{"line":36,"address":4215569,"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":4227161,"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":4226704,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":39,"address":4226719,"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":4226736,"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":4226843,"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":4226952,"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":4227062,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs","tests","valid_layout.rs"],"content":"use jlrs::prelude::*;\nuse jlrs::util::JULIA;\n\nmacro_rules! impl_valid_layout_test {\n    ($name:ident, $t:ty, $v:expr) =\u003e {\n        #[test]\n        fn $name() {\n            JULIA.with(|j| {\n                let mut jlrs = j.borrow_mut();\n                jlrs.frame(1, |_global, frame| {\n                    unsafe {\n                        let i = $v;\n                        let v = Value::new(frame, i)?;\n                        assert!(\u003c$t\u003e::valid_layout(v.datatype().unwrap().into()));\n                    }\n                    Ok(())\n                })\n                .unwrap();\n            })\n        }\n    };\n}\n\nimpl_valid_layout_test!(valid_layout_u8, u8, 1u8);\nimpl_valid_layout_test!(valid_layout_u16, u16, 1u16);\nimpl_valid_layout_test!(valid_layout_u32, u32, 1u32);\nimpl_valid_layout_test!(valid_layout_u64, u64, 1u64);\nimpl_valid_layout_test!(valid_layout_usize, usize, 1usize);\nimpl_valid_layout_test!(valid_layout_i8, i8, 1i8);\nimpl_valid_layout_test!(valid_layout_i16, i16, 1i16);\nimpl_valid_layout_test!(valid_layout_i32, i32, 1i32);\nimpl_valid_layout_test!(valid_layout_i64, i64, 1i64);\nimpl_valid_layout_test!(valid_layout_isize, isize, 1isize);\nimpl_valid_layout_test!(valid_layout_f32, f32, 1.0f32);\nimpl_valid_layout_test!(valid_layout_f64, f64, 1.0f64);\nimpl_valid_layout_test!(valid_layout_bool, bool, true);\nimpl_valid_layout_test!(valid_layout_char, char, 'a');\n\n#[test]\nfn valid_layout_array() {\n    JULIA.with(|j| {\n        let mut jlrs = j.borrow_mut();\n        jlrs.dynamic_frame(|global, frame| {\n            unsafe {\n                let v = Value::new_array::\u003ci32, _, _\u003e(frame, (2, 2))?;\n                assert!(Array::valid_layout(v.datatype().unwrap().into()));\n\n                let ua = Module::base(global).global(\"Array\")?;\n\n                assert!(Array::valid_layout(ua));\n            }\n            Ok(())\n        })\n        .unwrap();\n    })\n}\n","traces":[{"line":7,"address":4232624,"length":1,"stats":{"Line":28},"fn_name":"valid_layout_u8"},{"line":8,"address":4232625,"length":1,"stats":{"Line":28},"fn_name":null},{"line":9,"address":4246537,"length":1,"stats":{"Line":14},"fn_name":null},{"line":10,"address":4246160,"length":1,"stats":{"Line":28},"fn_name":"{{closure}}"},{"line":13,"address":4246177,"length":1,"stats":{"Line":14},"fn_name":null},{"line":14,"address":4246276,"length":1,"stats":{"Line":14},"fn_name":null},{"line":16,"address":4246449,"length":1,"stats":{"Line":14},"fn_name":null},{"line":24,"address":4246172,"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":4246732,"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":4247292,"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":4247852,"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":4248412,"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":4248972,"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":4249532,"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":4250092,"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":4250652,"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":4251212,"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":4251780,"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":4252340,"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":4252892,"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":4253452,"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":4232848,"length":1,"stats":{"Line":2},"fn_name":"valid_layout_array"},{"line":41,"address":4232849,"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":4254697,"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":4254000,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":45,"address":4254015,"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":4254165,"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":4254341,"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":4254501,"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":4254597,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":30,"coverable":30},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs_derive_tests","src","lib.rs"],"content":"mod impls;\nmod util;\n\n#[cfg(test)]\nmod tests {\n    use super::impls::*;\n    use super::util::JULIA;\n    use jlrs::prelude::*;\n\n    #[test]\n    fn derive_bits_type_bool() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeBool { a: true };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cbool\u003e().unwrap(), true);\n                    assert!(v.is::\u003cBitsTypeBool\u003e());\n                    assert!(v.cast::\u003cBitsTypeBool\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_char() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeChar { a: 'b' };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cchar\u003e().unwrap(), 'b');\n                    assert!(v.is::\u003cBitsTypeChar\u003e());\n                    assert!(v.cast::\u003cBitsTypeChar\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_uint8() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeUInt8 { a: 1 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cu8\u003e().unwrap(), 1);\n                    assert!(v.is::\u003cBitsTypeUInt8\u003e());\n                    assert!(v.cast::\u003cBitsTypeUInt8\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_uint16() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeUInt16 { a: 2 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cu16\u003e().unwrap(), 2);\n                    assert!(v.is::\u003cBitsTypeUInt16\u003e());\n                    assert!(v.cast::\u003cBitsTypeUInt16\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_uint32() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeUInt32 { a: 3 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cu32\u003e().unwrap(), 3);\n                    assert!(v.is::\u003cBitsTypeUInt32\u003e());\n                    assert!(v.cast::\u003cBitsTypeUInt32\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_uint64() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeUInt64 { a: 4 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cu64\u003e().unwrap(), 4);\n                    assert!(v.is::\u003cBitsTypeUInt64\u003e());\n                    assert!(v.cast::\u003cBitsTypeUInt64\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_uint() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeUInt { a: 5 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cu64\u003e().unwrap(), 5);\n                    assert!(v.is::\u003cBitsTypeUInt\u003e());\n                    assert!(v.cast::\u003cBitsTypeUInt\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_int8() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeInt8 { a: -1 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003ci8\u003e().unwrap(), -1);\n                    assert!(v.is::\u003cBitsTypeInt8\u003e());\n                    assert!(v.cast::\u003cBitsTypeInt8\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_int16() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeInt16 { a: -2 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003ci16\u003e().unwrap(), -2);\n                    assert!(v.is::\u003cBitsTypeInt16\u003e());\n                    assert!(v.cast::\u003cBitsTypeInt16\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_int32() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeInt32 { a: -3 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003ci32\u003e().unwrap(), -3);\n                    assert!(v.is::\u003cBitsTypeInt32\u003e());\n                    assert!(v.cast::\u003cBitsTypeInt32\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_int64() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeInt64 { a: -4 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003ci64\u003e().unwrap(), -4);\n                    assert!(v.is::\u003cBitsTypeInt64\u003e());\n                    assert!(v.cast::\u003cBitsTypeInt64\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_int() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeInt { a: -5 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003ci64\u003e().unwrap(), -5);\n                    assert!(v.is::\u003cBitsTypeInt\u003e());\n                    assert!(v.cast::\u003cBitsTypeInt\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_float32() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeFloat32 { a: 1.2 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cf32\u003e().unwrap(), 1.2);\n                    assert!(v.is::\u003cBitsTypeFloat32\u003e());\n                    assert!(v.cast::\u003cBitsTypeFloat32\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_type_float64() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsTypeFloat64 { a: -2.3 };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cf64\u003e().unwrap(), -2.3);\n                    assert!(v.is::\u003cBitsTypeFloat64\u003e());\n                    assert!(v.cast::\u003cBitsTypeFloat64\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_char_float32_float64() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsCharFloat32Float64 {\n                        a: 'a',\n                        b: 3.0,\n                        c: 4.0,\n                    };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003cchar\u003e().unwrap(), 'a');\n                    assert!(v.is::\u003cBitsCharFloat32Float64\u003e());\n                    assert!(v.cast::\u003cBitsCharFloat32Float64\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_int_bool() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsIntBool { a: 1, b: true };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n\n                    assert_eq!(first.cast::\u003ci64\u003e().unwrap(), 1);\n                    assert!(v.is::\u003cBitsIntBool\u003e());\n                    assert!(v.cast::\u003cBitsIntBool\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_char_bits_int_char() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsCharBitsIntChar {\n                        a: 'a',\n                        b: BitsIntChar { a: 1, b: 'b' },\n                    };\n                    let v = Value::new(frame, s).unwrap();\n                    let first = v.get_nth_field(frame, 0).unwrap();\n                    assert_eq!(first.cast::\u003cchar\u003e().unwrap(), 'a');\n                    assert!(v.is::\u003cBitsCharBitsIntChar\u003e());\n                    assert!(v.cast::\u003cBitsCharBitsIntChar\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_uint8_tuple_int32_int64() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let s = BitsUInt8TupleInt32Int64 {\n                        a: 0,\n                        b: Tuple2(-1, -3),\n                    };\n                    let v = Value::new(frame, s).unwrap();\n\n                    let first = v.get_nth_field(frame, 0).unwrap();\n                    let second = v.get_nth_field(frame, 1).unwrap();\n\n                    assert_eq!(first.cast::\u003cu8\u003e().unwrap(), 0);\n                    assert_eq!(second.cast::\u003cTuple2\u003ci32, i64\u003e\u003e().unwrap(), Tuple2(-1, -3));\n                    assert!(v.is::\u003cBitsUInt8TupleInt32Int64\u003e());\n                    assert!(v.cast::\u003cBitsUInt8TupleInt32Int64\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_bits_uint8_tuple_int32_tuple_int16_uint16() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let rs_val = BitsUInt8TupleInt32TupleInt16UInt16 {\n                        a: 0,\n                        b: Tuple2(-1, Tuple2(-1, 3)),\n                    };\n                    let jl_val = Value::new(frame, rs_val).unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cBitsUInt8TupleInt32TupleInt16UInt16\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert_eq!(first.cast::\u003cu8\u003e().unwrap(), rs_val.a);\n\n                    let second = jl_val.get_nth_field(frame, 1).unwrap();\n                    assert_eq!(\n                        second.cast::\u003cTuple2\u003ci32, Tuple2\u003ci16, u16\u003e\u003e\u003e().unwrap(),\n                        rs_val.b\n                    );\n\n                    assert!(jl_val.is::\u003cBitsUInt8TupleInt32TupleInt16UInt16\u003e());\n                    assert!(jl_val.cast::\u003cBitsUInt8TupleInt32TupleInt16UInt16\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_single_variant() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let constr = Module::main(global)\n                        .submodule(\"WithBitsUnion\")?\n                        .function(\"SingleVariant\")?;\n                    let v1 = Value::new(frame, 1i8)?;\n                    let v2 = Value::new(frame, 2i32)?;\n                    let v3 = Value::new(frame, 3i8)?;\n                    let jl_val = constr.call3(frame, v1, v2, v3)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cSingleVariant\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert_eq!(first.cast::\u003ci8\u003e().unwrap(), 1);\n\n                    let third = jl_val.get_nth_field(frame, 2).unwrap();\n                    assert_eq!(third.cast::\u003ci8\u003e().unwrap(), 3);\n\n                    assert!(jl_val.is::\u003cSingleVariant\u003e());\n                    assert!(jl_val.cast::\u003cSingleVariant\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_double_variant() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let constr = Module::main(global)\n                        .submodule(\"WithBitsUnion\")?\n                        .function(\"DoubleVariant\")?;\n\n                    let v1 = Value::new(frame, 1i8)?;\n                    let v2 = Value::new(frame, 2i16)?;\n                    let v3 = Value::new(frame, 3i8)?;\n                    let jl_val = constr.call3(frame, v1, v2, v3)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cDoubleVariant\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert_eq!(first.cast::\u003ci8\u003e().unwrap(), 1);\n\n                    let second = jl_val.get_nth_field(frame, 1).unwrap();\n                    assert_eq!(second.cast::\u003ci16\u003e().unwrap(), 2);\n\n                    let third = jl_val.get_nth_field(frame, 2).unwrap();\n                    assert_eq!(third.cast::\u003ci8\u003e().unwrap(), 3);\n\n                    assert!(jl_val.is::\u003cDoubleVariant\u003e());\n                    assert!(jl_val.cast::\u003cDoubleVariant\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_size_align_mismatch() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let constr = Module::main(global)\n                        .submodule(\"WithBitsUnion\")?\n                        .function(\"SizeAlignMismatch\")?;\n\n                    let v1 = Value::new(frame, 1i8)?;\n                    let v2 = Value::new(frame, 2i32)?;\n                    let v3 = Value::new(frame, 3i8)?;\n                    let jl_val = constr.call3(frame, v1, v2, v3)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cSizeAlignMismatch\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert_eq!(first.cast::\u003ci8\u003e().unwrap(), 1);\n\n                    let second = jl_val.get_nth_field(frame, 1).unwrap();\n                    assert_eq!(second.cast::\u003ci32\u003e().unwrap(), 2);\n\n                    let third = jl_val.get_nth_field(frame, 2).unwrap();\n                    assert_eq!(third.cast::\u003ci8\u003e().unwrap(), 3);\n\n                    assert!(jl_val.is::\u003cSizeAlignMismatch\u003e());\n                    assert!(jl_val.cast::\u003cSizeAlignMismatch\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_union_in_tuple() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let constr = Module::main(global)\n                        .submodule(\"WithBitsUnion\")?\n                        .function(\"UnionInTuple\")?;\n\n                    let v1 = Value::new(frame, 1i8)?;\n                    let v2 = Value::new(frame, Tuple1(2i16))?;\n                    let v3 = Value::new(frame, 3i8)?;\n                    let jl_val = constr.call3(frame, v1, v2, v3)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cUnionInTuple\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert_eq!(first.cast::\u003ci8\u003e().unwrap(), 1);\n\n                    let second = jl_val.get_nth_field(frame, 1).unwrap();\n                    assert_eq!(second.cast::\u003cTuple1\u003ci16\u003e\u003e().unwrap(), Tuple1(2));\n\n                    let third = jl_val.get_nth_field(frame, 2).unwrap();\n                    assert_eq!(third.cast::\u003ci8\u003e().unwrap(), 3);\n\n                    assert!(jl_val.is::\u003cUnionInTuple\u003e());\n                    let uit = jl_val.cast::\u003cUnionInTuple\u003e()?;\n                    assert_eq!(uit.a, 1);\n                    assert_eq!(uit.c, 3);\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_non_bits_union() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let constr = Module::main(global)\n                        .submodule(\"WithNonBitsUnion\")?\n                        .function(\"NonBitsUnion\")?;\n\n                    let v1 = Value::new(frame, 1i8)?;\n                    let jl_val = constr.call1(frame, v1)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cNonBitsUnion\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert_eq!(first.cast::\u003ci8\u003e().unwrap(), 1);\n\n                    assert!(jl_val.is::\u003cNonBitsUnion\u003e());\n                    assert!(jl_val.cast::\u003cNonBitsUnion\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_with_generic_t_i32() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithGenericT\")?;\n\n                    let v1 = Value::new(frame, 1i32)?;\n                    let jl_val = constr.call1(frame, v1)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cWithGenericT\u003ci32\u003e\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert_eq!(first.cast::\u003ci32\u003e().unwrap(), 1);\n\n                    assert!(jl_val.is::\u003cWithGenericT\u003ci32\u003e\u003e());\n                    assert!(jl_val.cast::\u003cWithGenericT\u003ci32\u003e\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_with_unionall() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithGenericT\")?;\n\n                    let v1 = Value::new(frame, 1i32)?;\n                    let wgt = constr.call1(frame, v1)?.unwrap();\n\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithGenericUnionAll\")?;\n\n                    let jl_val = constr.call1(frame, wgt)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cWithGenericUnionAll\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert!(first.cast::\u003cWithGenericT\u003ci32\u003e\u003e().is_ok());\n\n                    assert!(jl_val.is::\u003cWithGenericUnionAll\u003e());\n                    assert!(jl_val.cast::\u003cWithGenericUnionAll\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_with_nested_generic() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithGenericT\")?;\n\n                    let v1 = Value::new(frame, 1i32)?;\n                    let wgt = constr.call1(frame, v1)?.unwrap();\n\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithNestedGenericT\")?;\n\n                    let jl_val = constr.call1(frame, wgt)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cWithNestedGenericT\u003ci32\u003e\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert!(first.cast::\u003cWithGenericT\u003ci32\u003e\u003e().is_ok());\n\n                    assert!(jl_val.is::\u003cWithNestedGenericT\u003ci32\u003e\u003e());\n                    assert!(jl_val.cast::\u003cWithNestedGenericT\u003ci32\u003e\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_with_propagated_lifetime() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithGenericT\")?;\n\n                    let wgt = constr.call1(frame, Module::base(global).into())?.unwrap();\n\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithPropagatedLifetime\")?;\n\n                    let jl_val = constr.call1(frame, wgt)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cWithPropagatedLifetime\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert!(first.cast::\u003cWithGenericT\u003cModule\u003e\u003e().is_ok());\n\n                    assert!(jl_val.is::\u003cWithPropagatedLifetime\u003e());\n                    assert!(jl_val.cast::\u003cWithPropagatedLifetime\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_with_propagated_lifetimes() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let arr = Value::new_array::\u003ci32, _, _\u003e(frame, (2, 2))?;\n\n                    let wgt_constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithGenericT\")?;\n\n                    let wgt = wgt_constr.call1(frame, arr)?.unwrap();\n\n                    let constr = Module::base(global).function(\"tuple\")?;\n                    let int = Value::new(frame, 2i32)?;\n                    let tup = constr.call2(frame, int, wgt)?.unwrap();\n\n                    let a = wgt_constr.call1(frame, tup)?.unwrap();\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithPropagatedLifetimes\")?;\n\n                    let jl_val = constr.call1(frame, a)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cWithPropagatedLifetimes\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert!(first\n                        .cast::\u003cWithGenericT\u003cTuple2\u003ci32, WithGenericT\u003cArray\u003e\u003e\u003e\u003e()\n                        .is_ok());\n\n                    assert!(jl_val.is::\u003cWithPropagatedLifetimes\u003e());\n                    assert!(jl_val.cast::\u003cWithPropagatedLifetimes\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_with_set_generic() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let wgt_constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithGenericT\")?;\n\n                    let v1 = Value::new(frame, 1i64)?;\n                    let wgt = wgt_constr.call1(frame, v1)?.unwrap();\n\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithSetGeneric\")?;\n\n                    let jl_val = constr.call1(frame, wgt)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cWithSetGeneric\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert!(first.cast::\u003cWithGenericT\u003ci64\u003e\u003e().is_ok());\n\n                    assert!(jl_val.is::\u003cWithSetGeneric\u003e());\n                    assert!(jl_val.cast::\u003cWithSetGeneric\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_with_set_generic_tuple() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let wgt_constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithGenericT\")?;\n\n                    let v1 = Value::new(frame, 1i64)?;\n                    let wgt = wgt_constr.call1(frame, v1)?.unwrap();\n\n                    let tup_constr = Module::base(global).function(\"tuple\")?;\n                    let v2 = tup_constr.call1(frame, wgt)?.unwrap();\n\n                    let constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"WithSetGenericTuple\")?;\n\n                    let jl_val = constr.call1(frame, v2)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cWithSetGenericTuple\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert!(first.cast::\u003cTuple1\u003cWithGenericT\u003ci64\u003e\u003e\u003e().is_ok());\n\n                    assert!(jl_val.is::\u003cWithSetGenericTuple\u003e());\n                    assert!(jl_val.cast::\u003cWithSetGenericTuple\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n\n    #[test]\n    fn derive_with_value_type() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|global, frame| {\n                    let wvt_constr = Module::main(global)\n                        .submodule(\"WithGeneric\")?\n                        .function(\"withvaluetype\")?;\n\n                    let v1 = Value::new(frame, 1i64)?;\n                    let jl_val = wvt_constr.call1(frame, v1)?.unwrap();\n\n                    assert!(Module::base(global)\n                        .function(\"typeof\")?\n                        .call1(frame, jl_val)?\n                        .unwrap()\n                        .cast::\u003cDataType\u003e()?\n                        .is::\u003cWithValueType\u003e());\n\n                    let first = jl_val.get_nth_field(frame, 0).unwrap();\n                    assert!(first.cast::\u003ci64\u003e().is_ok());\n\n                    assert!(jl_val.is::\u003cWithValueType\u003e());\n                    assert!(jl_val.cast::\u003cWithValueType\u003e().is_ok());\n\n                    Ok(())\n                })\n                .unwrap()\n        })\n    }\n}\n","traces":[{"line":11,"address":4215408,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":12,"address":4216288,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":13,"address":4216297,"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":4216330,"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":4215440,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":17,"address":4215455,"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":4215463,"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":4215592,"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":4215645,"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":4215792,"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":4216103,"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":4216432,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":33,"address":4217312,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":34,"address":4217321,"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":4217354,"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":4216464,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":38,"address":4216479,"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":4216490,"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":4216618,"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":4216671,"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":4216815,"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":4217126,"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":4217456,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":54,"address":4218336,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":55,"address":4218345,"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":4218378,"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":4217488,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":59,"address":4217503,"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":4217511,"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":4217640,"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":4217693,"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":4217834,"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":4218142,"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":4218480,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":75,"address":4219360,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":76,"address":4219369,"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":4219402,"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":4218512,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":80,"address":4218527,"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":4218537,"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":4218668,"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":4218721,"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":4218868,"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":4219176,"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":4219504,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":96,"address":4220384,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":97,"address":4220393,"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":4220426,"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":4219536,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":101,"address":4219551,"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":4219562,"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":4219690,"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":4219743,"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":4219887,"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":4220195,"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":4220528,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":117,"address":4221408,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":118,"address":4221417,"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":4221450,"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":4220560,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":122,"address":4220575,"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":4220587,"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":4220718,"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":4220771,"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":4220918,"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":4221226,"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":4221552,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":138,"address":4222432,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":139,"address":4222441,"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":4222474,"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":4221584,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":143,"address":4221599,"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":4221611,"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":4221742,"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":4221795,"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":4221942,"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":4222250,"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":4222576,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":159,"address":4223456,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":160,"address":4223465,"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":4223498,"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":4222608,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":164,"address":4222623,"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":4222631,"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":4222760,"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":4222813,"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":4222954,"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":4223262,"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":4223600,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":180,"address":4224480,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":181,"address":4224489,"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":4224522,"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":4223632,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":185,"address":4223647,"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":4223657,"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":4223788,"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":4223841,"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":4223988,"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":4224296,"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":4224624,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":201,"address":4225504,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":202,"address":4225513,"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":4225546,"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":4224656,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":206,"address":4224671,"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":4224682,"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":4224810,"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":4224863,"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":4225007,"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":4225315,"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":4225648,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":222,"address":4226528,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":223,"address":4226537,"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":4226570,"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":4225680,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":227,"address":4225695,"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":4225707,"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":4225838,"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":4225891,"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":4226038,"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":4226346,"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":4226672,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":243,"address":4227552,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":244,"address":4227561,"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":4227594,"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":4226704,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":248,"address":4226719,"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":4226731,"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":4226862,"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":4226915,"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":4227062,"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":4227370,"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":4227696,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":264,"address":4228592,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":265,"address":4228601,"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":4228634,"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":4227728,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":269,"address":4227751,"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":4227760,"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":4227888,"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":4227941,"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":4228094,"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":4228402,"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":4228736,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":285,"address":4229632,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":286,"address":4229641,"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":4229674,"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":4228768,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":290,"address":4228791,"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":4228800,"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":4228931,"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":4228984,"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":4229138,"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":4229446,"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":4229776,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":306,"address":4230704,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":307,"address":4230713,"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":4230746,"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":4229808,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":311,"address":4229839,"length":1,"stats":{"Line":1},"fn_name":null},{"line":316,"address":4229868,"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":4230009,"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":4230062,"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":4230206,"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":4230517,"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":4230848,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":331,"address":4231728,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":332,"address":4231737,"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":4231770,"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":4230880,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":336,"address":4230895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":4230915,"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":4231036,"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":4231089,"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":4231236,"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":4231544,"length":1,"stats":{"Line":1},"fn_name":null},{"line":351,"address":4231872,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":352,"address":4232848,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":353,"address":4232857,"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":4232890,"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":4231904,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":357,"address":4231942,"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":4231919,"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":4231983,"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":4232146,"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":4232199,"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":4232343,"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":4232654,"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":4232992,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":375,"address":4234544,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":376,"address":4234553,"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":4234586,"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":4233024,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":380,"address":4233062,"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":4233039,"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":4233100,"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":4233269,"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":4233353,"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":4233426,"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":4233571,"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":4234046,"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":4234357,"length":1,"stats":{"Line":1},"fn_name":null},{"line":401,"address":4234688,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":402,"address":4237104,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":403,"address":4237113,"length":1,"stats":{"Line":1},"fn_name":null},{"line":405,"address":4237146,"length":1,"stats":{"Line":1},"fn_name":null},{"line":406,"address":4234720,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":407,"address":4234798,"length":1,"stats":{"Line":1},"fn_name":null},{"line":409,"address":4234735,"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":4234822,"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":4234953,"length":1,"stats":{"Line":1},"fn_name":null},{"line":414,"address":4235053,"length":1,"stats":{"Line":1},"fn_name":null},{"line":415,"address":4235253,"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":4235529,"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":4235705,"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":4235805,"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":4235967,"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":4236421,"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":4236356,"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":4236534,"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":4236845,"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":4236970,"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":4237248,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":440,"address":4240944,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":441,"address":4240953,"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":4240986,"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":4237280,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":445,"address":4237303,"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":4237415,"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":4237432,"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":4237722,"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":4237941,"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":4238160,"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":4238371,"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":4238717,"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":4238817,"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":4239004,"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":4239280,"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":4239456,"length":1,"stats":{"Line":1},"fn_name":null},{"line":461,"address":4239556,"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":4239717,"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":4240106,"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":4240250,"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":4240558,"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":4240683,"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":4241088,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":477,"address":4245360,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":478,"address":4245369,"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":4245402,"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":4241120,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":482,"address":4241143,"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":4241255,"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":4241272,"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":4241562,"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":4241781,"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":4242000,"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":4242211,"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":4242557,"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":4242657,"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":4242844,"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":4243120,"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":4243296,"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":4243396,"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":4243557,"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":4243967,"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":4244134,"length":1,"stats":{"Line":1},"fn_name":null},{"line":505,"address":4244523,"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":4244667,"length":1,"stats":{"Line":1},"fn_name":null},{"line":508,"address":4244975,"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":4245100,"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":4245504,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":518,"address":4249760,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":519,"address":4249769,"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":4249802,"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":4245536,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":523,"address":4245559,"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":4245671,"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":4245688,"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":4245978,"length":1,"stats":{"Line":1},"fn_name":null},{"line":528,"address":4246197,"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":4246416,"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":4246627,"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":4246973,"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":4247073,"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":4247260,"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":4247536,"length":1,"stats":{"Line":1},"fn_name":null},{"line":539,"address":4247712,"length":1,"stats":{"Line":1},"fn_name":null},{"line":540,"address":4247812,"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":4247973,"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":4248383,"length":1,"stats":{"Line":1},"fn_name":null},{"line":545,"address":4248547,"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":4248936,"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":4249080,"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":4249388,"length":1,"stats":{"Line":1},"fn_name":null},{"line":551,"address":4249513,"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":4249904,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":559,"address":4255200,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":560,"address":4255209,"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":4255242,"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":4249936,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":564,"address":4249959,"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":4250071,"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":4250088,"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":4250378,"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":4250589,"length":1,"stats":{"Line":1},"fn_name":null},{"line":570,"address":4250829,"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":4251040,"length":1,"stats":{"Line":1},"fn_name":null},{"line":573,"address":4251386,"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":4251486,"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":4251673,"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":4251949,"length":1,"stats":{"Line":1},"fn_name":null},{"line":580,"address":4252125,"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":4252225,"length":1,"stats":{"Line":1},"fn_name":null},{"line":583,"address":4252386,"length":1,"stats":{"Line":1},"fn_name":null},{"line":584,"address":4252796,"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":4252990,"length":1,"stats":{"Line":1},"fn_name":null},{"line":587,"address":4253403,"length":1,"stats":{"Line":1},"fn_name":null},{"line":589,"address":4253556,"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":4253918,"length":1,"stats":{"Line":1},"fn_name":null},{"line":591,"address":4254113,"length":1,"stats":{"Line":1},"fn_name":null},{"line":592,"address":4254301,"length":1,"stats":{"Line":1},"fn_name":null},{"line":594,"address":4254694,"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":4255344,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":602,"address":4257968,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":603,"address":4257977,"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":4258010,"length":1,"stats":{"Line":1},"fn_name":null},{"line":606,"address":4255376,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":607,"address":4255399,"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":4255511,"length":1,"stats":{"Line":1},"fn_name":null},{"line":609,"address":4255528,"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":4255818,"length":1,"stats":{"Line":1},"fn_name":null},{"line":612,"address":4256029,"length":1,"stats":{"Line":1},"fn_name":null},{"line":614,"address":4256359,"length":1,"stats":{"Line":1},"fn_name":null},{"line":615,"address":4256459,"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":4256646,"length":1,"stats":{"Line":1},"fn_name":null},{"line":618,"address":4256922,"length":1,"stats":{"Line":1},"fn_name":null},{"line":621,"address":4257092,"length":1,"stats":{"Line":1},"fn_name":null},{"line":622,"address":4257177,"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":4257321,"length":1,"stats":{"Line":1},"fn_name":null},{"line":625,"address":4257629,"length":1,"stats":{"Line":1},"fn_name":null},{"line":627,"address":4257754,"length":1,"stats":{"Line":1},"fn_name":null},{"line":634,"address":4258112,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":635,"address":4260736,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":636,"address":4260745,"length":1,"stats":{"Line":1},"fn_name":null},{"line":638,"address":4260778,"length":1,"stats":{"Line":1},"fn_name":null},{"line":639,"address":4258144,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":640,"address":4258167,"length":1,"stats":{"Line":1},"fn_name":null},{"line":641,"address":4258279,"length":1,"stats":{"Line":1},"fn_name":null},{"line":642,"address":4258296,"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":4258586,"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":4258797,"length":1,"stats":{"Line":1},"fn_name":null},{"line":647,"address":4259127,"length":1,"stats":{"Line":1},"fn_name":null},{"line":648,"address":4259227,"length":1,"stats":{"Line":1},"fn_name":null},{"line":649,"address":4259414,"length":1,"stats":{"Line":1},"fn_name":null},{"line":651,"address":4259690,"length":1,"stats":{"Line":1},"fn_name":null},{"line":654,"address":4259860,"length":1,"stats":{"Line":1},"fn_name":null},{"line":655,"address":4259945,"length":1,"stats":{"Line":1},"fn_name":null},{"line":657,"address":4260092,"length":1,"stats":{"Line":1},"fn_name":null},{"line":658,"address":4260400,"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":4260525,"length":1,"stats":{"Line":1},"fn_name":null},{"line":667,"address":4260880,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":668,"address":4263936,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":669,"address":4263945,"length":1,"stats":{"Line":1},"fn_name":null},{"line":671,"address":4263978,"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":4260912,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":673,"address":4260935,"length":1,"stats":{"Line":1},"fn_name":null},{"line":674,"address":4261047,"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":4261064,"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":4261354,"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":4261565,"length":1,"stats":{"Line":1},"fn_name":null},{"line":680,"address":4261895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":681,"address":4261990,"length":1,"stats":{"Line":1},"fn_name":null},{"line":682,"address":4262007,"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":4262279,"length":1,"stats":{"Line":1},"fn_name":null},{"line":686,"address":4262609,"length":1,"stats":{"Line":1},"fn_name":null},{"line":687,"address":4262709,"length":1,"stats":{"Line":1},"fn_name":null},{"line":688,"address":4262890,"length":1,"stats":{"Line":1},"fn_name":null},{"line":690,"address":4263124,"length":1,"stats":{"Line":1},"fn_name":null},{"line":693,"address":4263282,"length":1,"stats":{"Line":1},"fn_name":null},{"line":694,"address":4263367,"length":1,"stats":{"Line":1},"fn_name":null},{"line":696,"address":4263465,"length":1,"stats":{"Line":1},"fn_name":null},{"line":697,"address":4263516,"length":1,"stats":{"Line":1},"fn_name":null},{"line":699,"address":4263641,"length":1,"stats":{"Line":1},"fn_name":null},{"line":706,"address":4264080,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":707,"address":4267136,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":708,"address":4267145,"length":1,"stats":{"Line":1},"fn_name":null},{"line":710,"address":4267178,"length":1,"stats":{"Line":1},"fn_name":null},{"line":711,"address":4264112,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":712,"address":4264135,"length":1,"stats":{"Line":1},"fn_name":null},{"line":713,"address":4264247,"length":1,"stats":{"Line":1},"fn_name":null},{"line":714,"address":4264264,"length":1,"stats":{"Line":0},"fn_name":null},{"line":716,"address":4264554,"length":1,"stats":{"Line":1},"fn_name":null},{"line":717,"address":4264765,"length":1,"stats":{"Line":1},"fn_name":null},{"line":719,"address":4265095,"length":1,"stats":{"Line":1},"fn_name":null},{"line":720,"address":4265190,"length":1,"stats":{"Line":1},"fn_name":null},{"line":721,"address":4265207,"length":1,"stats":{"Line":0},"fn_name":null},{"line":723,"address":4265479,"length":1,"stats":{"Line":1},"fn_name":null},{"line":725,"address":4265809,"length":1,"stats":{"Line":1},"fn_name":null},{"line":726,"address":4265909,"length":1,"stats":{"Line":1},"fn_name":null},{"line":727,"address":4266090,"length":1,"stats":{"Line":1},"fn_name":null},{"line":729,"address":4266324,"length":1,"stats":{"Line":1},"fn_name":null},{"line":732,"address":4266482,"length":1,"stats":{"Line":1},"fn_name":null},{"line":733,"address":4266567,"length":1,"stats":{"Line":1},"fn_name":null},{"line":735,"address":4266665,"length":1,"stats":{"Line":1},"fn_name":null},{"line":736,"address":4266716,"length":1,"stats":{"Line":1},"fn_name":null},{"line":738,"address":4266841,"length":1,"stats":{"Line":1},"fn_name":null},{"line":745,"address":4267280,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":746,"address":4270144,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":747,"address":4270153,"length":1,"stats":{"Line":1},"fn_name":null},{"line":749,"address":4270186,"length":1,"stats":{"Line":1},"fn_name":null},{"line":750,"address":4267312,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":751,"address":4267335,"length":1,"stats":{"Line":1},"fn_name":null},{"line":752,"address":4267447,"length":1,"stats":{"Line":1},"fn_name":null},{"line":753,"address":4267464,"length":1,"stats":{"Line":0},"fn_name":null},{"line":755,"address":4267754,"length":1,"stats":{"Line":1},"fn_name":null},{"line":757,"address":4268125,"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":4268220,"length":1,"stats":{"Line":1},"fn_name":null},{"line":759,"address":4268237,"length":1,"stats":{"Line":0},"fn_name":null},{"line":761,"address":4268509,"length":1,"stats":{"Line":1},"fn_name":null},{"line":763,"address":4268839,"length":1,"stats":{"Line":1},"fn_name":null},{"line":764,"address":4268939,"length":1,"stats":{"Line":1},"fn_name":null},{"line":765,"address":4269114,"length":1,"stats":{"Line":1},"fn_name":null},{"line":767,"address":4269348,"length":1,"stats":{"Line":1},"fn_name":null},{"line":770,"address":4269506,"length":1,"stats":{"Line":1},"fn_name":null},{"line":771,"address":4269591,"length":1,"stats":{"Line":1},"fn_name":null},{"line":773,"address":4269689,"length":1,"stats":{"Line":1},"fn_name":null},{"line":774,"address":4269740,"length":1,"stats":{"Line":1},"fn_name":null},{"line":776,"address":4269865,"length":1,"stats":{"Line":1},"fn_name":null},{"line":783,"address":4270288,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":784,"address":4274400,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":785,"address":4274409,"length":1,"stats":{"Line":1},"fn_name":null},{"line":787,"address":4274442,"length":1,"stats":{"Line":1},"fn_name":null},{"line":788,"address":4270320,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":789,"address":4270335,"length":1,"stats":{"Line":1},"fn_name":null},{"line":791,"address":4270513,"length":1,"stats":{"Line":1},"fn_name":null},{"line":792,"address":4270711,"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":4270728,"length":1,"stats":{"Line":0},"fn_name":null},{"line":795,"address":4271000,"length":1,"stats":{"Line":1},"fn_name":null},{"line":797,"address":4271338,"length":1,"stats":{"Line":1},"fn_name":null},{"line":798,"address":4271492,"length":1,"stats":{"Line":1},"fn_name":null},{"line":799,"address":4271703,"length":1,"stats":{"Line":1},"fn_name":null},{"line":801,"address":4272041,"length":1,"stats":{"Line":1},"fn_name":null},{"line":802,"address":4272281,"length":1,"stats":{"Line":1},"fn_name":null},{"line":803,"address":4272376,"length":1,"stats":{"Line":1},"fn_name":null},{"line":804,"address":4272393,"length":1,"stats":{"Line":0},"fn_name":null},{"line":806,"address":4272665,"length":1,"stats":{"Line":1},"fn_name":null},{"line":808,"address":4272995,"length":1,"stats":{"Line":1},"fn_name":null},{"line":809,"address":4273095,"length":1,"stats":{"Line":1},"fn_name":null},{"line":810,"address":4273270,"length":1,"stats":{"Line":1},"fn_name":null},{"line":812,"address":4273504,"length":1,"stats":{"Line":1},"fn_name":null},{"line":815,"address":4273662,"length":1,"stats":{"Line":1},"fn_name":null},{"line":816,"address":4273747,"length":1,"stats":{"Line":1},"fn_name":null},{"line":820,"address":4273845,"length":1,"stats":{"Line":1},"fn_name":null},{"line":821,"address":4273896,"length":1,"stats":{"Line":1},"fn_name":null},{"line":823,"address":4274021,"length":1,"stats":{"Line":1},"fn_name":null},{"line":830,"address":4274544,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":831,"address":4277600,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":832,"address":4277609,"length":1,"stats":{"Line":1},"fn_name":null},{"line":834,"address":4277642,"length":1,"stats":{"Line":1},"fn_name":null},{"line":835,"address":4274576,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":836,"address":4274599,"length":1,"stats":{"Line":1},"fn_name":null},{"line":837,"address":4274711,"length":1,"stats":{"Line":1},"fn_name":null},{"line":838,"address":4274728,"length":1,"stats":{"Line":0},"fn_name":null},{"line":840,"address":4275018,"length":1,"stats":{"Line":1},"fn_name":null},{"line":841,"address":4275229,"length":1,"stats":{"Line":1},"fn_name":null},{"line":843,"address":4275559,"length":1,"stats":{"Line":1},"fn_name":null},{"line":844,"address":4275654,"length":1,"stats":{"Line":1},"fn_name":null},{"line":845,"address":4275671,"length":1,"stats":{"Line":0},"fn_name":null},{"line":847,"address":4275943,"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":4276273,"length":1,"stats":{"Line":1},"fn_name":null},{"line":850,"address":4276373,"length":1,"stats":{"Line":1},"fn_name":null},{"line":851,"address":4276554,"length":1,"stats":{"Line":1},"fn_name":null},{"line":853,"address":4276788,"length":1,"stats":{"Line":1},"fn_name":null},{"line":856,"address":4276946,"length":1,"stats":{"Line":1},"fn_name":null},{"line":857,"address":4277031,"length":1,"stats":{"Line":1},"fn_name":null},{"line":859,"address":4277129,"length":1,"stats":{"Line":1},"fn_name":null},{"line":860,"address":4277180,"length":1,"stats":{"Line":1},"fn_name":null},{"line":862,"address":4277305,"length":1,"stats":{"Line":1},"fn_name":null},{"line":869,"address":4277744,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":870,"address":4281312,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":871,"address":4281321,"length":1,"stats":{"Line":1},"fn_name":null},{"line":873,"address":4281354,"length":1,"stats":{"Line":1},"fn_name":null},{"line":874,"address":4277776,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":875,"address":4277799,"length":1,"stats":{"Line":1},"fn_name":null},{"line":876,"address":4277911,"length":1,"stats":{"Line":1},"fn_name":null},{"line":877,"address":4277928,"length":1,"stats":{"Line":0},"fn_name":null},{"line":879,"address":4278218,"length":1,"stats":{"Line":1},"fn_name":null},{"line":880,"address":4278429,"length":1,"stats":{"Line":1},"fn_name":null},{"line":882,"address":4278759,"length":1,"stats":{"Line":1},"fn_name":null},{"line":883,"address":4278905,"length":1,"stats":{"Line":1},"fn_name":null},{"line":885,"address":4279235,"length":1,"stats":{"Line":1},"fn_name":null},{"line":886,"address":4279330,"length":1,"stats":{"Line":1},"fn_name":null},{"line":887,"address":4279347,"length":1,"stats":{"Line":0},"fn_name":null},{"line":889,"address":4279619,"length":1,"stats":{"Line":1},"fn_name":null},{"line":891,"address":4279949,"length":1,"stats":{"Line":1},"fn_name":null},{"line":892,"address":4280049,"length":1,"stats":{"Line":1},"fn_name":null},{"line":893,"address":4280224,"length":1,"stats":{"Line":1},"fn_name":null},{"line":895,"address":4280458,"length":1,"stats":{"Line":1},"fn_name":null},{"line":898,"address":4280616,"length":1,"stats":{"Line":1},"fn_name":null},{"line":899,"address":4280701,"length":1,"stats":{"Line":1},"fn_name":null},{"line":901,"address":4280799,"length":1,"stats":{"Line":1},"fn_name":null},{"line":902,"address":4280850,"length":1,"stats":{"Line":1},"fn_name":null},{"line":904,"address":4280975,"length":1,"stats":{"Line":1},"fn_name":null},{"line":911,"address":4281456,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":912,"address":4283728,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":913,"address":4283737,"length":1,"stats":{"Line":1},"fn_name":null},{"line":915,"address":4283770,"length":1,"stats":{"Line":1},"fn_name":null},{"line":916,"address":4281488,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":917,"address":4281511,"length":1,"stats":{"Line":1},"fn_name":null},{"line":918,"address":4281623,"length":1,"stats":{"Line":1},"fn_name":null},{"line":919,"address":4281640,"length":1,"stats":{"Line":0},"fn_name":null},{"line":921,"address":4281930,"length":1,"stats":{"Line":1},"fn_name":null},{"line":922,"address":4282141,"length":1,"stats":{"Line":1},"fn_name":null},{"line":924,"address":4282471,"length":1,"stats":{"Line":1},"fn_name":null},{"line":925,"address":4282571,"length":1,"stats":{"Line":1},"fn_name":null},{"line":926,"address":4282746,"length":1,"stats":{"Line":1},"fn_name":null},{"line":928,"address":4282980,"length":1,"stats":{"Line":1},"fn_name":null},{"line":931,"address":4283138,"length":1,"stats":{"Line":1},"fn_name":null},{"line":932,"address":4283223,"length":1,"stats":{"Line":1},"fn_name":null},{"line":934,"address":4283321,"length":1,"stats":{"Line":1},"fn_name":null},{"line":935,"address":4283372,"length":1,"stats":{"Line":1},"fn_name":null},{"line":937,"address":4283497,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":503,"coverable":522},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs_derive_tests","src","util.rs"],"content":"use jlrs::prelude::*;\nuse std::cell::RefCell;\n\nthread_local! {\n    pub static JULIA: RefCell\u003cJulia\u003e = {\n        let r = RefCell::new(unsafe { Julia::init(32).unwrap() });\n        r.borrow_mut().include(\"JlrsDeriveTests.jl\").unwrap();\n        r\n    };\n}\n","traces":[{"line":6,"address":4327111,"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":4327206,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","thomas","Projects","Git","jlrs","jlrs_ndarray","src","lib.rs"],"content":"//! Borrow data from Julia arrays as `ndarray`'s `ArrayView` and `ArrayViewMut`.\n//!\n//! This crate defines a single trait, `NdArray`, that provides methods that return an immutable\n//! or a mutable view of the array data and is implemented by `Array` and `TypedArray` from jlrs.\n//! It's easier to use this trait with `TypedArray`, you'll likely have to provide type\n//! annotations with `Array`.\n\nuse jlrs::error::other;\nuse jlrs::prelude::*;\nuse ndarray::{ArrayView, ArrayViewMut, Dim, IntoDimension, IxDynImpl, ShapeBuilder};\n\nmod private {\n    use jlrs::traits::ValidLayout;\n    use jlrs::value::array::{Array, TypedArray};\n\n    pub trait Sealed {}\n    impl\u003c'frame, 'data\u003e Sealed for Array\u003c'frame, 'data\u003e {}\n    impl\u003c'frame, 'data, T\u003e Sealed for TypedArray\u003c'frame, 'data, T\u003e where T: Copy + ValidLayout {}\n}\n\n/// Trait to borrow Julia arrays with inline data as `ndarray`'s `ArrayView` and `ArrayViewMut`.\npub trait NdArray\u003c'borrow, T\u003e: private::Sealed {\n    /// Borrow the data in the array as an `ArrayView`. Returns an error if the wrong type is\n    /// provided or the data is not stored inline.\n    fn inline_array_view\u003c'frame: 'borrow, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cArrayView\u003c'borrow, T, Dim\u003cIxDynImpl\u003e\u003e\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n        T: ValidLayout + Copy;\n\n    /// Mutably borrow the data in the array as an `ArrayViewMut`. Returns an error if the wrong\n    /// type is provided or the data is not stored inline.\n    fn inline_array_view_mut\u003c'frame: 'borrow, F\u003e(\n        self,\n        frame: \u0026'borrow mut F,\n    ) -\u003e JlrsResult\u003cArrayViewMut\u003c'borrow, T, Dim\u003cIxDynImpl\u003e\u003e\u003e\n    where\n        F: Frame\u003c'frame\u003e,\n        T: ValidLayout + Copy;\n}\n\nimpl\u003c'frame: 'borrow, 'data: 'borrow, 'borrow, T: ValidLayout + Copy\u003e NdArray\u003c'borrow, T\u003e\n    for Array\u003c'frame, 'data\u003e\n{\n    fn inline_array_view\u003c'fr: 'borrow, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cArrayView\u003c'borrow, T, Dim\u003cIxDynImpl\u003e\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n        T: ValidLayout + Copy,\n    {\n        let data = self.inline_data::\u003cT, _\u003e(frame)?;\n        let shape = data.dimensions().as_slice().into_dimension().f();\n        match ArrayView::from_shape(shape, data.into_slice()) {\n            Ok(arr) =\u003e Ok(arr),\n            Err(e) =\u003e Err(other(e).unwrap_err()),\n        }\n    }\n\n    fn inline_array_view_mut\u003c'fr: 'borrow, F\u003e(\n        self,\n        frame: \u0026'borrow mut F,\n    ) -\u003e JlrsResult\u003cArrayViewMut\u003c'borrow, T, Dim\u003cIxDynImpl\u003e\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n        T: ValidLayout + Copy,\n    {\n        let data = self.inline_data_mut::\u003cT, _\u003e(frame)?;\n        let shape = data.dimensions().as_slice().into_dimension().f();\n        let raw = data.into_mut_slice();\n        match ArrayViewMut::from_shape(shape, raw) {\n            Ok(arr) =\u003e Ok(arr),\n            Err(e) =\u003e Err(other(e).unwrap_err()),\n        }\n    }\n}\n\nimpl\u003c'frame: 'borrow, 'data: 'borrow, 'borrow, T: ValidLayout + Copy\u003e NdArray\u003c'borrow, T\u003e\n    for TypedArray\u003c'frame, 'data, T\u003e\n{\n    fn inline_array_view\u003c'fr: 'borrow, F\u003e(\n        self,\n        frame: \u0026'borrow F,\n    ) -\u003e JlrsResult\u003cArrayView\u003c'borrow, T, Dim\u003cIxDynImpl\u003e\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n        T: ValidLayout,\n    {\n        let data = self.inline_data(frame)?;\n        let shape = data.dimensions().as_slice().into_dimension().f();\n        match ArrayView::from_shape(shape, data.into_slice()) {\n            Ok(arr) =\u003e Ok(arr),\n            Err(e) =\u003e Err(other(e).unwrap_err()),\n        }\n    }\n\n    fn inline_array_view_mut\u003c'fr: 'borrow, F\u003e(\n        self,\n        frame: \u0026'borrow mut F,\n    ) -\u003e JlrsResult\u003cArrayViewMut\u003c'borrow, T, Dim\u003cIxDynImpl\u003e\u003e\u003e\n    where\n        F: Frame\u003c'fr\u003e,\n        T: ValidLayout,\n    {\n        let data = self.inline_data_mut(frame)?;\n        let shape = data.dimensions().as_slice().into_dimension().f();\n        let raw = data.into_mut_slice();\n        match ArrayViewMut::from_shape(shape, raw) {\n            Ok(arr) =\u003e Ok(arr),\n            Err(e) =\u003e Err(other(e).unwrap_err()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::NdArray;\n    use jlrs::prelude::*;\n    use ndarray::{ArrayView, ArrayViewMut, IxDyn};\n\n    use std::cell::RefCell;\n\n    thread_local! {\n        pub static JULIA: RefCell\u003cJulia\u003e = RefCell::new(unsafe { Julia::init(32).unwrap() });\n    }\n\n    #[test]\n    fn array_view() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let mut data = vec![1usize, 2, 3, 4, 5, 6];\n                    let slice = \u0026mut data.as_mut_slice();\n                    let borrowed = Value::borrow_array(frame, slice, (3, 2))?;\n\n                    let jl_array = borrowed.cast::\u003cArray\u003e()?;\n                    let x = jl_array.inline_data::\u003cusize, _\u003e(frame)?[(1, 0)];\n\n                    let array: ArrayView\u003cusize, _\u003e = jl_array.inline_array_view(frame)?;\n                    assert_eq!(array[IxDyn(\u0026[1, 0])], x);\n\n                    Ok(())\n                })\n                .unwrap();\n        });\n    }\n\n    #[test]\n    fn array_view_wrong_type() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let mut data = vec![1usize, 2, 3, 4, 5, 6];\n                    let slice = \u0026mut data.as_mut_slice();\n                    let borrowed = Value::borrow_array(frame, slice, (3, 2))?;\n\n                    let jl_array = borrowed.cast::\u003cArray\u003e()?;\n                    let view: Result\u003cArrayView\u003cisize, _\u003e, _\u003e = jl_array.inline_array_view(frame);\n                    assert!(view.is_err());\n                    Ok(())\n                })\n                .unwrap();\n        });\n    }\n\n    #[test]\n    fn array_view_mut() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let mut data = vec![1usize, 2, 3, 4, 5, 6];\n                    let slice = \u0026mut data.as_mut_slice();\n                    let borrowed = Value::borrow_array(frame, slice, (3, 2))?;\n\n                    let jl_array = borrowed.cast::\u003cArray\u003e()?;\n                    let mut inline = jl_array.inline_data_mut::\u003cusize, _\u003e(frame)?;\n                    let x = inline[(1, 0)];\n\n                    inline[(1, 0)] = x + 1;\n\n                    let mut array: ArrayViewMut\u003cusize, _\u003e =\n                        jl_array.inline_array_view_mut(frame)?;\n                    assert_eq!(array[IxDyn(\u0026[1, 0])], x + 1);\n                    array[IxDyn(\u0026[1, 0])] -= 1;\n\n                    let inline = jl_array.inline_data_mut::\u003cusize, _\u003e(frame)?;\n                    assert_eq!(inline[(1, 0)], x);\n                    Ok(())\n                })\n                .unwrap();\n        });\n    }\n\n    #[test]\n    fn array_view_mut_wrong_type() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let mut data = vec![1usize, 2, 3, 4, 5, 6];\n                    let slice = \u0026mut data.as_mut_slice();\n                    let borrowed = Value::borrow_array(frame, slice, (3, 2))?;\n\n                    let jl_array = borrowed.cast::\u003cArray\u003e()?;\n                    let view: Result\u003cArrayViewMut\u003cisize, _\u003e, _\u003e =\n                        jl_array.inline_array_view_mut(frame);\n                    assert!(view.is_err());\n                    Ok(())\n                })\n                .unwrap();\n        });\n    }\n\n    #[test]\n    fn typed_array_view() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let mut data = vec![1usize, 2, 3, 4, 5, 6];\n                    let slice = \u0026mut data.as_mut_slice();\n                    let borrowed = Value::borrow_array(frame, slice, (3, 2))?;\n\n                    let jl_array = borrowed.cast::\u003cTypedArray\u003cusize\u003e\u003e()?;\n                    let x = jl_array.inline_data(frame)?[(1, 0)];\n\n                    let array: ArrayView\u003cusize, _\u003e = jl_array.inline_array_view(frame)?;\n                    assert_eq!(array[IxDyn(\u0026[1, 0])], x);\n\n                    Ok(())\n                })\n                .unwrap();\n        });\n    }\n\n    #[test]\n    fn typed_array_view_mut() {\n        JULIA.with(|j| {\n            let mut julia = j.borrow_mut();\n\n            julia\n                .dynamic_frame(|_global, frame| {\n                    let mut data = vec![1usize, 2, 3, 4, 5, 6];\n                    let slice = \u0026mut data.as_mut_slice();\n                    let borrowed = Value::borrow_array(frame, slice, (3, 2))?;\n\n                    let jl_array = borrowed.cast::\u003cTypedArray\u003cusize\u003e\u003e()?;\n                    let mut inline = jl_array.inline_data_mut(frame)?;\n                    let x = inline[(1, 0)];\n\n                    inline[(1, 0)] = x + 1;\n\n                    let mut array: ArrayViewMut\u003cusize, _\u003e =\n                        jl_array.inline_array_view_mut(frame)?;\n                    assert_eq!(array[IxDyn(\u0026[1, 0])], x + 1);\n                    array[IxDyn(\u0026[1, 0])] -= 1;\n\n                    let inline = jl_array.inline_data_mut(frame)?;\n                    assert_eq!(inline[(1, 0)], x);\n                    Ok(())\n                })\n                .unwrap();\n        });\n    }\n}\n","traces":[{"line":47,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":null,"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":null,"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":null,"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":4220551,"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":4220688,"length":1,"stats":{"Line":2},"fn_name":"array_view"},{"line":132,"address":4220689,"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":4228633,"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":4228666,"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":4226384,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":137,"address":4226399,"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":4226521,"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":4226592,"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":4226819,"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":4227085,"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":4227586,"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":4227810,"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":4228086,"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":4220704,"length":1,"stats":{"Line":2},"fn_name":"array_view_wrong_type"},{"line":155,"address":4220705,"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":4229737,"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":4229770,"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":4228800,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":160,"address":4228815,"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":4228937,"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":4228996,"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":4229193,"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":4229423,"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":4229525,"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":4229566,"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":4220720,"length":1,"stats":{"Line":2},"fn_name":"array_view_mut"},{"line":175,"address":4220721,"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":4233513,"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":4233546,"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":4229904,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":180,"address":4229919,"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":4230041,"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":4230112,"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":4230339,"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":4230605,"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":4230895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":4231090,"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":4231238,"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":4231485,"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":4231850,"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":4232382,"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":4232565,"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":4232832,"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":4220736,"length":1,"stats":{"Line":2},"fn_name":"array_view_mut_wrong_type"},{"line":205,"address":4220737,"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":4234617,"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":4234650,"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":4233680,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":210,"address":4233695,"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":4233817,"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":4233876,"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":4234073,"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":4234303,"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":4234405,"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":4234446,"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":4220752,"length":1,"stats":{"Line":2},"fn_name":"typed_array_view"},{"line":226,"address":4220753,"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":4237033,"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":4237066,"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":4234784,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":231,"address":4234799,"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":4234921,"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":4234992,"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":4235219,"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":4235485,"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":4235986,"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":4236210,"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":4236486,"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":4220768,"length":1,"stats":{"Line":2},"fn_name":"typed_array_view_mut"},{"line":249,"address":4220769,"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":4240809,"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":4240842,"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":4237200,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":254,"address":4237215,"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":4237337,"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":4237408,"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":4237635,"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":4237901,"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":4238191,"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":4238386,"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":4238534,"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":4238781,"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":4239146,"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":4239678,"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":4239861,"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":4240128,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":109,"coverable":113}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
  };

  ReactDOM.render(e(App, {root}), document.getElementById('root'));
}());
</script>
</body>
</html>